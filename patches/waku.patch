diff --git a/dist/lib/context.d.ts b/dist/lib/context.d.ts
index 65a69cec7658fc53adf339532a04a6fbfdf873bf..b1794682bb6277f2102ff9152408eb45dc2ad96e 100644
--- a/dist/lib/context.d.ts
+++ b/dist/lib/context.d.ts
@@ -1,5 +1,6 @@
 type Context = {
     readonly req: Request;
+    nonce: string | undefined;
     readonly data: Record<string, unknown>;
 };
 export declare function INTERNAL_runWithContext<T>(req: Request, next: () => T): T;
diff --git a/dist/lib/context.js b/dist/lib/context.js
index 43deb13fa408995c10bc89340fbcf82b7ffb33aa..3c1f1cace6c83b7eb7e1362520788420fbe5f34a 100644
--- a/dist/lib/context.js
+++ b/dist/lib/context.js
@@ -3,6 +3,7 @@ const contextStorage = new AsyncLocalStorage();
 export function INTERNAL_runWithContext(req, next) {
     const context = {
         req,
+        nonce: undefined,
         data: {}
     };
     return contextStorage.run(context, next);
diff --git a/dist/lib/context.js.map b/dist/lib/context.js.map
index bb016f7231a68cbfc8afa0e4ca2e2cd449c56f2e..0657c72cbfc356ae4dd2be2662e4fb273be69ca9 100644
--- a/dist/lib/context.js.map
+++ b/dist/lib/context.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/lib/context.ts"],"sourcesContent":["import { AsyncLocalStorage } from 'node:async_hooks';\n\ntype Context = {\n  readonly req: Request;\n  readonly data: Record<string, unknown>;\n};\n\nconst contextStorage = new AsyncLocalStorage<Context>();\n\nexport function INTERNAL_runWithContext<T>(req: Request, next: () => T): T {\n  const context: Context = {\n    req,\n    data: {},\n  };\n  return contextStorage.run(context, next);\n}\n\nexport function getContext() {\n  const context = contextStorage.getStore();\n  if (!context) {\n    throw new Error(\n      'Context is not available. Make sure to use the context middleware.',\n    );\n  }\n  return context;\n}\n\nexport function getContextData(): Record<string, unknown> {\n  const context = contextStorage.getStore();\n  if (!context) {\n    return {};\n  }\n  return context.data;\n}\n"],"names":["AsyncLocalStorage","contextStorage","INTERNAL_runWithContext","req","next","context","data","run","getContext","getStore","Error","getContextData"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,mBAAmB;AAOrD,MAAMC,iBAAiB,IAAID;AAE3B,OAAO,SAASE,wBAA2BC,GAAY,EAAEC,IAAa;IACpE,MAAMC,UAAmB;QACvBF;QACAG,MAAM,CAAC;IACT;IACA,OAAOL,eAAeM,GAAG,CAACF,SAASD;AACrC;AAEA,OAAO,SAASI;IACd,MAAMH,UAAUJ,eAAeQ,QAAQ;IACvC,IAAI,CAACJ,SAAS;QACZ,MAAM,IAAIK,MACR;IAEJ;IACA,OAAOL;AACT;AAEA,OAAO,SAASM;IACd,MAAMN,UAAUJ,eAAeQ,QAAQ;IACvC,IAAI,CAACJ,SAAS;QACZ,OAAO,CAAC;IACV;IACA,OAAOA,QAAQC,IAAI;AACrB"}
\ No newline at end of file
+{"version":3,"sources":["../../src/lib/context.ts"],"sourcesContent":["import { AsyncLocalStorage } from 'node:async_hooks';\n\ntype Context = {\n  readonly req: Request;\n  nonce: string | undefined;\n  readonly data: Record<string, unknown>;\n};\n\nconst contextStorage = new AsyncLocalStorage<Context>();\n\nexport function INTERNAL_runWithContext<T>(req: Request, next: () => T): T {\n  const context: Context = {\n    req,\n    nonce: undefined,\n    data: {},\n  };\n  return contextStorage.run(context, next);\n}\n\nexport function getContext() {\n  const context = contextStorage.getStore();\n  if (!context) {\n    throw new Error(\n      'Context is not available. Make sure to use the context middleware.',\n    );\n  }\n  return context;\n}\n\nexport function getContextData(): Record<string, unknown> {\n  const context = contextStorage.getStore();\n  if (!context) {\n    return {};\n  }\n  return context.data;\n}\n"],"names":["AsyncLocalStorage","contextStorage","INTERNAL_runWithContext","req","next","context","nonce","undefined","data","run","getContext","getStore","Error","getContextData"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,mBAAmB;AAQrD,MAAMC,iBAAiB,IAAID;AAE3B,OAAO,SAASE,wBAA2BC,GAAY,EAAEC,IAAa;IACpE,MAAMC,UAAmB;QACvBF;QACAG,OAAOC;QACPC,MAAM,CAAC;IACT;IACA,OAAOP,eAAeQ,GAAG,CAACJ,SAASD;AACrC;AAEA,OAAO,SAASM;IACd,MAAML,UAAUJ,eAAeU,QAAQ;IACvC,IAAI,CAACN,SAAS;QACZ,MAAM,IAAIO,MACR;IAEJ;IACA,OAAOP;AACT;AAEA,OAAO,SAASQ;IACd,MAAMR,UAAUJ,eAAeU,QAAQ;IACvC,IAAI,CAACN,SAAS;QACZ,OAAO,CAAC;IACV;IACA,OAAOA,QAAQG,IAAI;AACrB"}
\ No newline at end of file
diff --git a/dist/lib/types.d.ts b/dist/lib/types.d.ts
index 546862f013cd5823e6a5ff74037a1689f1b2cf81..50fd6aacc82954ae0c33100913703df7f988d990 100644
--- a/dist/lib/types.d.ts
+++ b/dist/lib/types.d.ts
@@ -1,12 +1,16 @@
 import type { ReactNode } from 'react';
 import type { Config } from '../config.js';
 type Elements = Record<string, unknown>;
-export type Unstable_RenderRsc = (elements: Elements) => Promise<ReadableStream>;
+export type Unstable_RenderRsc = (elements: Elements, options?: {
+    unstable_clientModuleCallback?: (ids: string[]) => void;
+}) => Promise<ReadableStream>;
 export type Unstable_ParseRsc = (rscStream: ReadableStream) => Promise<Elements>;
 export type Unstable_RenderHtml = (elementsStream: ReadableStream, html: ReactNode, options: {
     rscPath: string;
-    actionResult?: unknown;
+    formState?: unknown;
     status?: number;
+    nonce?: string;
+    unstable_extraScriptContent?: string;
 }) => Promise<Response>;
 export type Unstable_EmitFile = (filePath: string, body: ReadableStream | string) => Promise<void>;
 export type Unstable_HandleRequest = (input: ({
diff --git a/dist/lib/types.js.map b/dist/lib/types.js.map
index f211aed525be80c7d2c250bcedad319638ac7286..4a4f5995861d9e0732ce5011f65463af9bec76ae 100644
--- a/dist/lib/types.js.map
+++ b/dist/lib/types.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/lib/types.ts"],"sourcesContent":["import type { ReactNode } from 'react';\nimport type { Config } from '../config.js';\n\ntype Elements = Record<string, unknown>;\n\nexport type Unstable_RenderRsc = (\n  elements: Elements,\n) => Promise<ReadableStream>;\n\nexport type Unstable_ParseRsc = (\n  rscStream: ReadableStream,\n) => Promise<Elements>;\n\nexport type Unstable_RenderHtml = (\n  elementsStream: ReadableStream,\n  html: ReactNode,\n  options: { rscPath: string; actionResult?: unknown; status?: number },\n) => Promise<Response>;\n\nexport type Unstable_EmitFile = (\n  filePath: string,\n  body: ReadableStream | string,\n) => Promise<void>;\n\nexport type Unstable_HandleRequest = (\n  input: (\n    | { type: 'component'; rscPath: string; rscParams: unknown }\n    | {\n        type: 'function';\n        fn: (...args: unknown[]) => Promise<unknown>;\n        args: unknown[];\n      }\n    | {\n        type: 'action';\n        fn: () => Promise<unknown>;\n      }\n    | { type: 'custom' }\n  ) & {\n    pathname: string;\n    req: Request;\n  },\n  utils: {\n    renderRsc: Unstable_RenderRsc;\n    parseRsc: Unstable_ParseRsc;\n    renderHtml: Unstable_RenderHtml;\n    loadBuildMetadata: (key: string) => Promise<string | undefined>;\n  },\n) => Promise<ReadableStream | Response | 'fallback' | null | undefined>;\n\nexport type Unstable_HandleBuild = (utils: {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n  rscPath2pathname: (rscPath: string) => string;\n  saveBuildMetadata: (key: string, value: string) => Promise<void>;\n  withRequest: <T>(req: Request, fn: () => T) => T;\n  generateFile: (\n    fileName: string,\n    body: ReadableStream | string,\n  ) => Promise<void>;\n  generateDefaultHtml: (fileName: string) => Promise<void>;\n}) => Promise<void>;\n\nexport type Unstable_Handlers = {\n  handleRequest: Unstable_HandleRequest;\n  handleBuild: Unstable_HandleBuild;\n  [someOtherProperty: string]: unknown;\n};\n\nexport type Unstable_ServerEntry = {\n  fetch: (req: Request, ...args: any[]) => Response | Promise<Response>;\n  build: (\n    utils: {\n      emitFile: Unstable_EmitFile;\n    },\n    ...args: any[]\n  ) => Promise<void>;\n  buildOptions?: Record<string, unknown>;\n  buildEnhancers?: string[]; // enhancer module ids\n  [someOtherProperty: string]: unknown;\n};\n\nexport type Unstable_ProcessRequest = (\n  req: Request,\n) => Promise<Response | null>;\n\nexport type Unstable_ProcessBuild = (utils: {\n  emitFile: Unstable_EmitFile;\n}) => Promise<void>;\n\nexport type Unstable_CreateServerEntryAdapter = <Options>(\n  fn: (\n    args: {\n      handlers: Unstable_Handlers;\n      processRequest: Unstable_ProcessRequest;\n      processBuild: Unstable_ProcessBuild;\n      config: Omit<Required<Config>, 'vite'>;\n      isBuild: boolean;\n      notFoundHtml: string;\n    },\n    options?: Options,\n  ) => Unstable_ServerEntry,\n) => (handlers: Unstable_Handlers, options?: Options) => Unstable_ServerEntry;\n"],"names":[],"mappings":"AA0FA,WAY8E"}
\ No newline at end of file
+{"version":3,"sources":["../../src/lib/types.ts"],"sourcesContent":["import type { ReactNode } from 'react';\nimport type { Config } from '../config.js';\n\ntype Elements = Record<string, unknown>;\n\nexport type Unstable_RenderRsc = (\n  elements: Elements,\n  options?: {\n    unstable_clientModuleCallback?: (ids: string[]) => void;\n  },\n) => Promise<ReadableStream>;\n\nexport type Unstable_ParseRsc = (\n  rscStream: ReadableStream,\n) => Promise<Elements>;\n\nexport type Unstable_RenderHtml = (\n  elementsStream: ReadableStream,\n  html: ReactNode,\n  options: {\n    rscPath: string;\n    formState?: unknown;\n    status?: number;\n    nonce?: string;\n    unstable_extraScriptContent?: string;\n  },\n) => Promise<Response>;\n\nexport type Unstable_EmitFile = (\n  filePath: string,\n  body: ReadableStream | string,\n) => Promise<void>;\n\nexport type Unstable_HandleRequest = (\n  input: (\n    | { type: 'component'; rscPath: string; rscParams: unknown }\n    | {\n        type: 'function';\n        fn: (...args: unknown[]) => Promise<unknown>;\n        args: unknown[];\n      }\n    | {\n        type: 'action';\n        fn: () => Promise<unknown>;\n      }\n    | { type: 'custom' }\n  ) & {\n    pathname: string;\n    req: Request;\n  },\n  utils: {\n    renderRsc: Unstable_RenderRsc;\n    parseRsc: Unstable_ParseRsc;\n    renderHtml: Unstable_RenderHtml;\n    loadBuildMetadata: (key: string) => Promise<string | undefined>;\n  },\n) => Promise<ReadableStream | Response | 'fallback' | null | undefined>;\n\nexport type Unstable_HandleBuild = (utils: {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n  rscPath2pathname: (rscPath: string) => string;\n  saveBuildMetadata: (key: string, value: string) => Promise<void>;\n  withRequest: <T>(req: Request, fn: () => T) => T;\n  generateFile: (\n    fileName: string,\n    body: ReadableStream | string,\n  ) => Promise<void>;\n  generateDefaultHtml: (fileName: string) => Promise<void>;\n}) => Promise<void>;\n\nexport type Unstable_Handlers = {\n  handleRequest: Unstable_HandleRequest;\n  handleBuild: Unstable_HandleBuild;\n  [someOtherProperty: string]: unknown;\n};\n\nexport type Unstable_ServerEntry = {\n  fetch: (req: Request, ...args: any[]) => Response | Promise<Response>;\n  build: (\n    utils: {\n      emitFile: Unstable_EmitFile;\n    },\n    ...args: any[]\n  ) => Promise<void>;\n  buildOptions?: Record<string, unknown>;\n  buildEnhancers?: string[]; // enhancer module ids\n  [someOtherProperty: string]: unknown;\n};\n\nexport type Unstable_ProcessRequest = (\n  req: Request,\n) => Promise<Response | null>;\n\nexport type Unstable_ProcessBuild = (utils: {\n  emitFile: Unstable_EmitFile;\n}) => Promise<void>;\n\nexport type Unstable_CreateServerEntryAdapter = <Options>(\n  fn: (\n    args: {\n      handlers: Unstable_Handlers;\n      processRequest: Unstable_ProcessRequest;\n      processBuild: Unstable_ProcessBuild;\n      config: Omit<Required<Config>, 'vite'>;\n      isBuild: boolean;\n      notFoundHtml: string;\n    },\n    options?: Options,\n  ) => Unstable_ServerEntry,\n) => (handlers: Unstable_Handlers, options?: Options) => Unstable_ServerEntry;\n"],"names":[],"mappings":"AAmGA,WAY8E"}
\ No newline at end of file
diff --git a/dist/lib/utils/managed.js b/dist/lib/utils/managed.js
index a43ada14dab106df617ea32de4079581a973aa01..90a9e6e104f84314efab85db620a0237474d1304 100644
--- a/dist/lib/utils/managed.js
+++ b/dist/lib/utils/managed.js
@@ -1,8 +1,12 @@
 import { EXTENSIONS, SRC_MIDDLEWARE, SRC_PAGES } from '../constants.js';
 export const getManagedServerEntry = (srcDir)=>{
     const globBase = `/${srcDir}/${SRC_PAGES}`;
-    const globPattern = `${globBase}/**/*.{${EXTENSIONS.map((ext)=>ext.slice(1)).join(',')}}`;
-    const middlewareGlob = `/${srcDir}/${SRC_MIDDLEWARE}/*.{${EXTENSIONS.map((ext)=>ext.slice(1)).join(',')}}`;
+    const exts = EXTENSIONS.map((ext)=>ext.slice(1)).join(',');
+    const globPattern = `${globBase}/**/*.{${exts}}`;
+    const middlewareGlob = [
+        `/${srcDir}/${SRC_MIDDLEWARE}/*.{${exts}}`,
+        `!/${srcDir}/${SRC_MIDDLEWARE}/*.{test,spec}.{${exts}}`
+    ];
     return `
 import { fsRouter } from 'waku';
 import adapter from 'waku/adapters/default';
diff --git a/dist/lib/utils/managed.js.map b/dist/lib/utils/managed.js.map
index a9074adaafc9a33b1d2133ce80b2e0916b39710e..e03f77d7922f85fb73881a36eb742b048a8bc6d7 100644
--- a/dist/lib/utils/managed.js.map
+++ b/dist/lib/utils/managed.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/utils/managed.ts"],"sourcesContent":["import { EXTENSIONS, SRC_MIDDLEWARE, SRC_PAGES } from '../constants.js';\n\nexport const getManagedServerEntry = (srcDir: string) => {\n  const globBase = `/${srcDir}/${SRC_PAGES}`;\n  const globPattern = `${globBase}/**/*.{${EXTENSIONS.map((ext) => ext.slice(1)).join(',')}}`;\n  const middlewareGlob = `/${srcDir}/${SRC_MIDDLEWARE}/*.{${EXTENSIONS.map((ext) => ext.slice(1)).join(',')}}`;\n  return `\nimport { fsRouter } from 'waku';\nimport adapter from 'waku/adapters/default';\n\nexport default adapter(\n  fsRouter(\n    import.meta.glob(\n      ${JSON.stringify(globPattern)},\n      { base: ${JSON.stringify(globBase)} }\n    )\n  ),\n  {\n    middlewareModules: import.meta.glob(${JSON.stringify(middlewareGlob)}),\n  },\n);\n`;\n};\n\nexport const getManagedClientEntry = () => {\n  return `\nimport { StrictMode, createElement } from 'react';\nimport { createRoot, hydrateRoot } from 'react-dom/client';\nimport { Router } from 'waku/router/client';\n\nconst rootElement = createElement(StrictMode, null, createElement(Router));\n\nif (globalThis.__WAKU_HYDRATE__) {\n  hydrateRoot(document, rootElement);\n} else {\n  createRoot(document).render(rootElement);\n}\n`;\n};\n"],"names":["EXTENSIONS","SRC_MIDDLEWARE","SRC_PAGES","getManagedServerEntry","srcDir","globBase","globPattern","map","ext","slice","join","middlewareGlob","JSON","stringify","getManagedClientEntry"],"mappings":"AAAA,SAASA,UAAU,EAAEC,cAAc,EAAEC,SAAS,QAAQ,kBAAkB;AAExE,OAAO,MAAMC,wBAAwB,CAACC;IACpC,MAAMC,WAAW,CAAC,CAAC,EAAED,OAAO,CAAC,EAAEF,WAAW;IAC1C,MAAMI,cAAc,GAAGD,SAAS,OAAO,EAAEL,WAAWO,GAAG,CAAC,CAACC,MAAQA,IAAIC,KAAK,CAAC,IAAIC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC3F,MAAMC,iBAAiB,CAAC,CAAC,EAAEP,OAAO,CAAC,EAAEH,eAAe,IAAI,EAAED,WAAWO,GAAG,CAAC,CAACC,MAAQA,IAAIC,KAAK,CAAC,IAAIC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5G,OAAO,CAAC;;;;;;;MAOJ,EAAEE,KAAKC,SAAS,CAACP,aAAa;cACtB,EAAEM,KAAKC,SAAS,CAACR,UAAU;;;;wCAID,EAAEO,KAAKC,SAAS,CAACF,gBAAgB;;;AAGzE,CAAC;AACD,EAAE;AAEF,OAAO,MAAMG,wBAAwB;IACnC,OAAO,CAAC;;;;;;;;;;;;AAYV,CAAC;AACD,EAAE"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/utils/managed.ts"],"sourcesContent":["import { EXTENSIONS, SRC_MIDDLEWARE, SRC_PAGES } from '../constants.js';\n\nexport const getManagedServerEntry = (srcDir: string) => {\n  const globBase = `/${srcDir}/${SRC_PAGES}`;\n  const exts = EXTENSIONS.map((ext) => ext.slice(1)).join(',');\n  const globPattern = `${globBase}/**/*.{${exts}}`;\n  const middlewareGlob = [\n    `/${srcDir}/${SRC_MIDDLEWARE}/*.{${exts}}`,\n    `!/${srcDir}/${SRC_MIDDLEWARE}/*.{test,spec}.{${exts}}`,\n  ];\n  return `\nimport { fsRouter } from 'waku';\nimport adapter from 'waku/adapters/default';\n\nexport default adapter(\n  fsRouter(\n    import.meta.glob(\n      ${JSON.stringify(globPattern)},\n      { base: ${JSON.stringify(globBase)} }\n    )\n  ),\n  {\n    middlewareModules: import.meta.glob(${JSON.stringify(middlewareGlob)}),\n  },\n);\n`;\n};\n\nexport const getManagedClientEntry = () => {\n  return `\nimport { StrictMode, createElement } from 'react';\nimport { createRoot, hydrateRoot } from 'react-dom/client';\nimport { Router } from 'waku/router/client';\n\nconst rootElement = createElement(StrictMode, null, createElement(Router));\n\nif (globalThis.__WAKU_HYDRATE__) {\n  hydrateRoot(document, rootElement);\n} else {\n  createRoot(document).render(rootElement);\n}\n`;\n};\n"],"names":["EXTENSIONS","SRC_MIDDLEWARE","SRC_PAGES","getManagedServerEntry","srcDir","globBase","exts","map","ext","slice","join","globPattern","middlewareGlob","JSON","stringify","getManagedClientEntry"],"mappings":"AAAA,SAASA,UAAU,EAAEC,cAAc,EAAEC,SAAS,QAAQ,kBAAkB;AAExE,OAAO,MAAMC,wBAAwB,CAACC;IACpC,MAAMC,WAAW,CAAC,CAAC,EAAED,OAAO,CAAC,EAAEF,WAAW;IAC1C,MAAMI,OAAON,WAAWO,GAAG,CAAC,CAACC,MAAQA,IAAIC,KAAK,CAAC,IAAIC,IAAI,CAAC;IACxD,MAAMC,cAAc,GAAGN,SAAS,OAAO,EAAEC,KAAK,CAAC,CAAC;IAChD,MAAMM,iBAAiB;QACrB,CAAC,CAAC,EAAER,OAAO,CAAC,EAAEH,eAAe,IAAI,EAAEK,KAAK,CAAC,CAAC;QAC1C,CAAC,EAAE,EAAEF,OAAO,CAAC,EAAEH,eAAe,gBAAgB,EAAEK,KAAK,CAAC,CAAC;KACxD;IACD,OAAO,CAAC;;;;;;;MAOJ,EAAEO,KAAKC,SAAS,CAACH,aAAa;cACtB,EAAEE,KAAKC,SAAS,CAACT,UAAU;;;;wCAID,EAAEQ,KAAKC,SAAS,CAACF,gBAAgB;;;AAGzE,CAAC;AACD,EAAE;AAEF,OAAO,MAAMG,wBAAwB;IACnC,OAAO,CAAC;;;;;;;;;;;;AAYV,CAAC;AACD,EAAE"}
\ No newline at end of file
diff --git a/dist/lib/utils/render.d.ts b/dist/lib/utils/render.d.ts
index 5659b74dd5edceeb9a622ad63830ee64b9f62f35..21060f7038fdd6f0f31bc0ebe37d50f58f6dee3f 100644
--- a/dist/lib/utils/render.d.ts
+++ b/dist/lib/utils/render.d.ts
@@ -1,5 +1,5 @@
 import type { Unstable_ParseRsc, Unstable_RenderHtml, Unstable_RenderRsc } from '../types.js';
-export declare function createRenderUtils(temporaryReferences: unknown, renderToReadableStream: (data: unknown, options?: object) => ReadableStream, createFromReadableStream: (stream: ReadableStream, options?: object) => Promise<unknown>, loadSsrEntryModule: () => Promise<typeof import('../vite-entries/entry.ssr.js')>): {
+export declare function createRenderUtils(temporaryReferences: unknown, renderToReadableStream: (data: unknown, options?: object, extraOptions?: object) => ReadableStream, createFromReadableStream: (stream: ReadableStream, options?: object) => Promise<unknown>, loadSsrEntryModule: () => Promise<typeof import('../vite-entries/entry.ssr.js')>): {
     renderRsc: Unstable_RenderRsc;
     parseRsc: Unstable_ParseRsc;
     renderHtml: Unstable_RenderHtml;
diff --git a/dist/lib/utils/render.js b/dist/lib/utils/render.js
index dd1d832361b297579b7536bd1397346757940e7f..91eec131d6c8aebf3916d3cc09d7a574d576f73a 100644
--- a/dist/lib/utils/render.js
+++ b/dist/lib/utils/render.js
@@ -6,10 +6,14 @@ export function createRenderUtils(temporaryReferences, renderToReadableStream, c
         }
     };
     return {
-        async renderRsc (elements) {
+        async renderRsc (elements, options) {
             return renderToReadableStream(elements, {
                 temporaryReferences,
                 onError
+            }, {
+                onClientReference (metadata) {
+                    options?.unstable_clientModuleCallback?.(metadata.deps.js);
+                }
             });
         },
         async parseRsc (stream) {
@@ -21,11 +25,13 @@ export function createRenderUtils(temporaryReferences, renderToReadableStream, c
                 onError
             });
             const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {
-                formState: options?.actionResult,
-                rscPath: options?.rscPath
+                rscPath: options.rscPath,
+                formState: options.formState,
+                nonce: options.nonce,
+                extraScriptContent: options.unstable_extraScriptContent
             });
             return new Response(htmlResult.stream, {
-                status: htmlResult.status || options?.status || 200,
+                status: htmlResult.status || options.status || 200,
                 headers: {
                     'content-type': 'text/html'
                 }
diff --git a/dist/lib/utils/render.js.map b/dist/lib/utils/render.js.map
index 54e9f4b0ccbbbc0383d457dc897018814abce1a2..4287086dd588f36e7749142c3d5891fec1d24f03 100644
--- a/dist/lib/utils/render.js.map
+++ b/dist/lib/utils/render.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/utils/render.ts"],"sourcesContent":["import type {\n  Unstable_ParseRsc,\n  Unstable_RenderHtml,\n  Unstable_RenderRsc,\n} from '../types.js';\n\nexport function createRenderUtils(\n  temporaryReferences: unknown,\n  renderToReadableStream: (data: unknown, options?: object) => ReadableStream,\n  createFromReadableStream: (\n    stream: ReadableStream,\n    options?: object,\n  ) => Promise<unknown>,\n  loadSsrEntryModule: () => Promise<\n    typeof import('../vite-entries/entry.ssr.js')\n  >,\n): {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n} {\n  const onError = (e: unknown) => {\n    console.error('Error during rendering:', e);\n    if (\n      e &&\n      typeof e === 'object' &&\n      'digest' in e &&\n      typeof e.digest === 'string'\n    ) {\n      return e.digest;\n    }\n  };\n\n  return {\n    async renderRsc(elements) {\n      return renderToReadableStream(elements, {\n        temporaryReferences,\n        onError,\n      });\n    },\n    async parseRsc(stream) {\n      return createFromReadableStream(stream, {}) as Promise<\n        Record<string, unknown>\n      >;\n    },\n    async renderHtml(\n      elementsStream,\n      html,\n      options?: { rscPath?: string; actionResult?: any; status?: number },\n    ) {\n      const { INTERNAL_renderHtmlStream: renderHtmlStream } =\n        await loadSsrEntryModule();\n\n      const rscHtmlStream = renderToReadableStream(html, {\n        onError,\n      });\n      const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {\n        formState: options?.actionResult,\n        rscPath: options?.rscPath,\n      });\n      return new Response(htmlResult.stream, {\n        status: htmlResult.status || options?.status || 200,\n        headers: { 'content-type': 'text/html' },\n      });\n    },\n  };\n}\n"],"names":["createRenderUtils","temporaryReferences","renderToReadableStream","createFromReadableStream","loadSsrEntryModule","onError","e","console","error","digest","renderRsc","elements","parseRsc","stream","renderHtml","elementsStream","html","options","INTERNAL_renderHtmlStream","renderHtmlStream","rscHtmlStream","htmlResult","formState","actionResult","rscPath","Response","status","headers"],"mappings":"AAMA,OAAO,SAASA,kBACdC,mBAA4B,EAC5BC,sBAA2E,EAC3EC,wBAGqB,EACrBC,kBAEC;IAMD,MAAMC,UAAU,CAACC;QACfC,QAAQC,KAAK,CAAC,2BAA2BF;QACzC,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEG,MAAM,KAAK,UACpB;YACA,OAAOH,EAAEG,MAAM;QACjB;IACF;IAEA,OAAO;QACL,MAAMC,WAAUC,QAAQ;YACtB,OAAOT,uBAAuBS,UAAU;gBACtCV;gBACAI;YACF;QACF;QACA,MAAMO,UAASC,MAAM;YACnB,OAAOV,yBAAyBU,QAAQ,CAAC;QAG3C;QACA,MAAMC,YACJC,cAAc,EACdC,IAAI,EACJC,OAAmE;YAEnE,MAAM,EAAEC,2BAA2BC,gBAAgB,EAAE,GACnD,MAAMf;YAER,MAAMgB,gBAAgBlB,uBAAuBc,MAAM;gBACjDX;YACF;YACA,MAAMgB,aAAa,MAAMF,iBAAiBJ,gBAAgBK,eAAe;gBACvEE,WAAWL,SAASM;gBACpBC,SAASP,SAASO;YACpB;YACA,OAAO,IAAIC,SAASJ,WAAWR,MAAM,EAAE;gBACrCa,QAAQL,WAAWK,MAAM,IAAIT,SAASS,UAAU;gBAChDC,SAAS;oBAAE,gBAAgB;gBAAY;YACzC;QACF;IACF;AACF"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/utils/render.ts"],"sourcesContent":["import type {\n  Unstable_ParseRsc,\n  Unstable_RenderHtml,\n  Unstable_RenderRsc,\n} from '../types.js';\n\nexport function createRenderUtils(\n  temporaryReferences: unknown,\n  renderToReadableStream: (\n    data: unknown,\n    options?: object,\n    extraOptions?: object,\n  ) => ReadableStream,\n  createFromReadableStream: (\n    stream: ReadableStream,\n    options?: object,\n  ) => Promise<unknown>,\n  loadSsrEntryModule: () => Promise<\n    typeof import('../vite-entries/entry.ssr.js')\n  >,\n): {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n} {\n  const onError = (e: unknown) => {\n    console.error('Error during rendering:', e);\n    if (\n      e &&\n      typeof e === 'object' &&\n      'digest' in e &&\n      typeof e.digest === 'string'\n    ) {\n      return e.digest;\n    }\n  };\n\n  return {\n    async renderRsc(elements, options) {\n      return renderToReadableStream(\n        elements,\n        {\n          temporaryReferences,\n          onError,\n        },\n        {\n          onClientReference(metadata: {\n            id: string;\n            name: string;\n            deps: { js: string[]; css: string[] };\n          }) {\n            options?.unstable_clientModuleCallback?.(metadata.deps.js);\n          },\n        },\n      );\n    },\n    async parseRsc(stream) {\n      return createFromReadableStream(stream, {}) as Promise<\n        Record<string, unknown>\n      >;\n    },\n    async renderHtml(elementsStream, html, options) {\n      const { INTERNAL_renderHtmlStream: renderHtmlStream } =\n        await loadSsrEntryModule();\n\n      const rscHtmlStream = renderToReadableStream(html, {\n        onError,\n      });\n      const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {\n        rscPath: options.rscPath,\n        formState: options.formState as never,\n        nonce: options.nonce,\n        extraScriptContent: options.unstable_extraScriptContent,\n      });\n      return new Response(htmlResult.stream, {\n        status: htmlResult.status || options.status || 200,\n        headers: { 'content-type': 'text/html' },\n      });\n    },\n  };\n}\n"],"names":["createRenderUtils","temporaryReferences","renderToReadableStream","createFromReadableStream","loadSsrEntryModule","onError","e","console","error","digest","renderRsc","elements","options","onClientReference","metadata","unstable_clientModuleCallback","deps","js","parseRsc","stream","renderHtml","elementsStream","html","INTERNAL_renderHtmlStream","renderHtmlStream","rscHtmlStream","htmlResult","rscPath","formState","nonce","extraScriptContent","unstable_extraScriptContent","Response","status","headers"],"mappings":"AAMA,OAAO,SAASA,kBACdC,mBAA4B,EAC5BC,sBAImB,EACnBC,wBAGqB,EACrBC,kBAEC;IAMD,MAAMC,UAAU,CAACC;QACfC,QAAQC,KAAK,CAAC,2BAA2BF;QACzC,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEG,MAAM,KAAK,UACpB;YACA,OAAOH,EAAEG,MAAM;QACjB;IACF;IAEA,OAAO;QACL,MAAMC,WAAUC,QAAQ,EAAEC,OAAO;YAC/B,OAAOV,uBACLS,UACA;gBACEV;gBACAI;YACF,GACA;gBACEQ,mBAAkBC,QAIjB;oBACCF,SAASG,gCAAgCD,SAASE,IAAI,CAACC,EAAE;gBAC3D;YACF;QAEJ;QACA,MAAMC,UAASC,MAAM;YACnB,OAAOhB,yBAAyBgB,QAAQ,CAAC;QAG3C;QACA,MAAMC,YAAWC,cAAc,EAAEC,IAAI,EAAEV,OAAO;YAC5C,MAAM,EAAEW,2BAA2BC,gBAAgB,EAAE,GACnD,MAAMpB;YAER,MAAMqB,gBAAgBvB,uBAAuBoB,MAAM;gBACjDjB;YACF;YACA,MAAMqB,aAAa,MAAMF,iBAAiBH,gBAAgBI,eAAe;gBACvEE,SAASf,QAAQe,OAAO;gBACxBC,WAAWhB,QAAQgB,SAAS;gBAC5BC,OAAOjB,QAAQiB,KAAK;gBACpBC,oBAAoBlB,QAAQmB,2BAA2B;YACzD;YACA,OAAO,IAAIC,SAASN,WAAWP,MAAM,EAAE;gBACrCc,QAAQP,WAAWO,MAAM,IAAIrB,QAAQqB,MAAM,IAAI;gBAC/CC,SAAS;oBAAE,gBAAgB;gBAAY;YACzC;QACF;IACF;AACF"}
\ No newline at end of file
diff --git a/dist/lib/vite-plugins/allow-server.js b/dist/lib/vite-plugins/allow-server.js
index 414b5b684efb25c6ca651966a80095eeef5b9d66..cd5f625e8d4d587a15c9977df284d59812ea7298 100644
--- a/dist/lib/vite-plugins/allow-server.js
+++ b/dist/lib/vite-plugins/allow-server.js
@@ -2,8 +2,6 @@ import MagicString from 'magic-string';
 import { parseAstAsync } from 'vite';
 const isNode = (value)=>typeof value?.type === 'string'; // heuristic
 const isNodeWithRange = (node)=>typeof node?.start === 'number' && typeof node?.end === 'number';
-const isIdentifierWithRange = (node)=>node.type === 'Identifier' && typeof node.start === 'number' && typeof node.end === 'number';
-const isExpressionWithRange = (node)=>typeof node.start === 'number' && typeof node.end === 'number';
 const getImportedName = (specifier)=>specifier.imported.type === 'Identifier' ? specifier.imported.name : String(specifier.imported.value);
 const getExportedName = (specifier)=>specifier.exported.type === 'Identifier' ? specifier.exported.name : String(specifier.exported.value);
 const getLocalExportName = (specifier)=>specifier.local.type === 'Identifier' ? specifier.local.name : typeof specifier.local.value === 'string' ? specifier.local.value : null;
@@ -13,13 +11,13 @@ const getExpressionFromArguments = (args)=>{
     }
     const arg = args[0];
     const argument = arg.type === 'SpreadElement' ? arg.argument : arg;
-    if (!isExpressionWithRange(argument)) {
-        throw new Error('allowServer should have exactly one argument');
+    if (!isNodeWithRange(argument)) {
+        throw new Error('Missing range');
     }
     return argument;
 };
 const isUseDirective = (stmt, directive)=>stmt.type === 'ExpressionStatement' && stmt.expression.type === 'Literal' && stmt.expression.value === directive;
-const getDeclarationId = (item)=>(item.type === 'FunctionDeclaration' || item.type === 'ClassDeclaration') && isIdentifierWithRange(item.id) && item.id;
+const getDeclarationId = (item)=>(item.type === 'FunctionDeclaration' || item.type === 'ClassDeclaration') && item.id.type === 'Identifier' && item.id;
 const transformExportedClientThings = (mod)=>{
     const exportNames = new Set();
     // HACK this doesn't cover all cases
@@ -68,7 +66,7 @@ const transformExportedClientThings = (mod)=>{
                 exportNames.add(item.declaration.id.name);
             } else if (item.declaration?.type === 'VariableDeclaration') {
                 for (const d of item.declaration.declarations){
-                    if (isIdentifierWithRange(d.id)) {
+                    if (d.id.type === 'Identifier') {
                         if (d.init?.type === 'CallExpression' && d.init.callee.type === 'Identifier' && d.init.callee.name === allowServer) {
                             const arg = getExpressionFromArguments(d.init.arguments);
                             allowServerItems.set(d.id.name, arg);
@@ -96,7 +94,7 @@ const transformExportedClientThings = (mod)=>{
             }
         } else if (item.type === 'VariableDeclaration') {
             for (const d of item.declarations){
-                if (isIdentifierWithRange(d.id) && d.init?.type === 'CallExpression' && d.init.callee.type === 'Identifier' && d.init.callee.name === allowServer) {
+                if (d.id.type === 'Identifier' && d.init?.type === 'CallExpression' && d.init.callee.type === 'Identifier' && d.init.callee.name === allowServer) {
                     const arg = getExpressionFromArguments(d.init.arguments);
                     allowServerItems.set(d.id.name, arg);
                     findDependencies(d.init);
@@ -111,7 +109,7 @@ const transformExportedClientThings = (mod)=>{
         for (const item of mod.body){
             if (item.type === 'VariableDeclaration') {
                 for (const d of item.declarations){
-                    if (isIdentifierWithRange(d.id) && allowServerDependencies.has(d.id.name)) {
+                    if (d.id.type === 'Identifier' && allowServerDependencies.has(d.id.name)) {
                         findDependencies(d);
                     }
                 }
@@ -135,7 +133,7 @@ const shouldKeepStatement = (stmt, dependencies)=>{
         return stmt.specifiers.some((s)=>s.type === 'ImportSpecifier' && (dependencies.has(getImportedName(s)) || dependencies.has(s.local.name)));
     }
     if (stmt.type === 'VariableDeclaration') {
-        return stmt.declarations.some((d)=>isIdentifierWithRange(d.id) && dependencies.has(d.id.name));
+        return stmt.declarations.some((d)=>d.id.type === 'Identifier' && dependencies.has(d.id.name));
     }
     const declId = getDeclarationId(stmt);
     if (declId) {
diff --git a/dist/lib/vite-plugins/allow-server.js.map b/dist/lib/vite-plugins/allow-server.js.map
index cd9cd5c27e0996f019b102ff5f3a0ec9b0b15963..139edd124483c530a05334c17a998efcf688974a 100644
--- a/dist/lib/vite-plugins/allow-server.js.map
+++ b/dist/lib/vite-plugins/allow-server.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/vite-plugins/allow-server.ts"],"sourcesContent":["import type * as estree from 'estree';\nimport MagicString from 'magic-string';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync } from 'vite';\n\ntype ProgramNode = Awaited<ReturnType<typeof parseAstAsync>>;\n\nconst isNode = (value: unknown): value is estree.Node =>\n  typeof (value as { type?: unknown })?.type === 'string'; // heuristic\n\nconst isNodeWithRange = (\n  node: estree.Node,\n): node is estree.Node & { start: number; end: number } =>\n  typeof (node as { start?: unknown })?.start === 'number' &&\n  typeof (node as { end?: unknown })?.end === 'number';\n\nconst isIdentifierWithRange = (\n  node: estree.Node,\n): node is estree.Identifier & { start: number; end: number } =>\n  node.type === 'Identifier' &&\n  typeof (node as { start?: unknown }).start === 'number' &&\n  typeof (node as { end?: unknown }).end === 'number';\n\nconst isExpressionWithRange = (\n  node: estree.Expression,\n): node is estree.Expression & { start: number; end: number } =>\n  typeof (node as { start?: unknown }).start === 'number' &&\n  typeof (node as { end?: unknown }).end === 'number';\n\nconst getImportedName = (specifier: estree.ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: estree.ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nconst getLocalExportName = (specifier: estree.ExportSpecifier) =>\n  specifier.local.type === 'Identifier'\n    ? specifier.local.name\n    : typeof specifier.local.value === 'string'\n      ? specifier.local.value\n      : null;\n\nconst getExpressionFromArguments = (\n  args: (estree.Expression | estree.SpreadElement)[],\n) => {\n  if (args.length !== 1) {\n    throw new Error('allowServer should have exactly one argument');\n  }\n  const arg = args[0]!;\n  const argument = arg.type === 'SpreadElement' ? arg.argument : arg;\n  if (!isExpressionWithRange(argument)) {\n    throw new Error('allowServer should have exactly one argument');\n  }\n  return argument;\n};\n\nconst isUseDirective = (stmt: estree.Node, directive: string) =>\n  stmt.type === 'ExpressionStatement' &&\n  stmt.expression.type === 'Literal' &&\n  stmt.expression.value === directive;\n\nconst getDeclarationId = (item: estree.Node) =>\n  (item.type === 'FunctionDeclaration' || item.type === 'ClassDeclaration') &&\n  isIdentifierWithRange(item.id) &&\n  item.id;\n\nconst transformExportedClientThings = (mod: ProgramNode) => {\n  const exportNames = new Set<string>();\n  // HACK this doesn't cover all cases\n  const allowServerItems = new Map<\n    string,\n    estree.Expression & { start: number; end: number }\n  >();\n  const allowServerDependencies = new Set<string>();\n  const visited = new WeakSet<estree.Node>();\n  const findDependencies = (node: estree.Node) => {\n    if (visited.has(node)) {\n      return;\n    }\n    visited.add(node);\n    if (node.type === 'Identifier') {\n      if (!allowServerItems.has(node.name) && !exportNames.has(node.name)) {\n        allowServerDependencies.add(node.name);\n      }\n    }\n    Object.values(node).forEach((value: unknown) => {\n      (Array.isArray(value) ? value : [value]).forEach((v: unknown) => {\n        if (isNode(v)) {\n          findDependencies(v);\n        }\n      });\n    });\n  };\n  // Pass 1: find allowServer identifier\n  let allowServer = 'unstable_allowServer';\n  for (const item of mod.body) {\n    if (\n      item.type === 'ImportDeclaration' &&\n      item.source.type === 'Literal' &&\n      item.source.value === 'waku/client'\n    ) {\n      for (const specifier of item.specifiers) {\n        if (\n          specifier.type === 'ImportSpecifier' &&\n          specifier.imported.type === 'Identifier' &&\n          specifier.imported.name === allowServer\n        ) {\n          allowServer = specifier.local.name;\n          break;\n        }\n      }\n      break;\n    }\n  }\n  // Pass 2: collect export names and allowServer names\n  for (const item of mod.body) {\n    if (item.type === 'ExportNamedDeclaration') {\n      if (\n        item.declaration?.type === 'FunctionDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (\n        item.declaration?.type === 'ClassDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (item.declaration?.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (isIdentifierWithRange(d.id)) {\n            if (\n              d.init?.type === 'CallExpression' &&\n              d.init.callee.type === 'Identifier' &&\n              d.init.callee.name === allowServer\n            ) {\n              const arg = getExpressionFromArguments(d.init.arguments);\n              allowServerItems.set(d.id.name, arg);\n              findDependencies(d.init);\n            } else {\n              exportNames.add(d.id.name);\n            }\n          }\n        }\n      }\n      for (const s of item.specifiers) {\n        if (s.type === 'ExportSpecifier') {\n          const localName = getLocalExportName(s);\n          if (localName && allowServerItems.has(localName)) {\n            continue;\n          }\n          exportNames.add(getExportedName(s));\n        }\n      }\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      exportNames.add('default');\n    } else if (item.type === 'ExportAllDeclaration') {\n      if (item.exported?.type === 'Identifier') {\n        exportNames.add(item.exported.name);\n      }\n    } else if (item.type === 'VariableDeclaration') {\n      for (const d of item.declarations) {\n        if (\n          isIdentifierWithRange(d.id) &&\n          d.init?.type === 'CallExpression' &&\n          d.init.callee.type === 'Identifier' &&\n          d.init.callee.name === allowServer\n        ) {\n          const arg = getExpressionFromArguments(d.init.arguments);\n          allowServerItems.set(d.id.name, arg);\n          findDependencies(d.init);\n        }\n      }\n    }\n  }\n  // Pass 3: collect dependencies\n  let dependenciesSize: number;\n  do {\n    dependenciesSize = allowServerDependencies.size;\n    for (const item of mod.body) {\n      if (item.type === 'VariableDeclaration') {\n        for (const d of item.declarations) {\n          if (\n            isIdentifierWithRange(d.id) &&\n            allowServerDependencies.has(d.id.name)\n          ) {\n            findDependencies(d);\n          }\n        }\n      } else {\n        const declId = getDeclarationId(item);\n        if (declId && allowServerDependencies.has(declId.name)) {\n          findDependencies(item);\n        }\n      }\n    }\n  } while (dependenciesSize < allowServerDependencies.size);\n  allowServerDependencies.delete(allowServer);\n  return { allowServerDependencies, allowServerItems, exportNames };\n};\n\nconst shouldKeepStatement = (stmt: estree.Node, dependencies: Set<string>) => {\n  if (stmt.type === 'ImportDeclaration') {\n    return stmt.specifiers.some(\n      (s) =>\n        s.type === 'ImportSpecifier' &&\n        (dependencies.has(getImportedName(s)) ||\n          dependencies.has(s.local.name)),\n    );\n  }\n  if (stmt.type === 'VariableDeclaration') {\n    return stmt.declarations.some(\n      (d) => isIdentifierWithRange(d.id) && dependencies.has(d.id.name),\n    );\n  }\n  const declId = getDeclarationId(stmt);\n  if (declId) {\n    return dependencies.has(declId.name);\n  }\n  return false;\n};\n\nconst hasDirective = (mod: ProgramNode, directive: string) => {\n  for (const item of mod.body) {\n    if (\n      item.type === 'ExpressionStatement' &&\n      item.expression.type === 'Literal' &&\n      item.expression.value === directive\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport function allowServerPlugin(): Plugin {\n  return {\n    name: 'waku:vite-plugins:allow-server',\n    async transform(code) {\n      if (this.environment.name !== 'rsc') {\n        return;\n      }\n      if (!code.includes('use client')) {\n        return;\n      }\n\n      const mod = await parseAstAsync(code, { jsx: true });\n      if (!hasDirective(mod, 'use client')) {\n        return;\n      }\n\n      const { allowServerDependencies, allowServerItems, exportNames } =\n        transformExportedClientThings(mod);\n\n      const s = new MagicString(code);\n      for (const item of mod.body) {\n        if (!isNodeWithRange(item)) {\n          throw new Error('Expected NodeWithRange');\n        }\n        if (isUseDirective(item, 'use client')) {\n          s.remove(item.start, item.end);\n          continue;\n        }\n        if (shouldKeepStatement(item, allowServerDependencies)) {\n          continue;\n        }\n        s.remove(item.start, item.end);\n      }\n\n      for (const [allowServerName, callExp] of allowServerItems) {\n        const expressionSource = code.slice(callExp.start, callExp.end);\n        s.append(`\\nexport const ${allowServerName} = ${expressionSource};`);\n      }\n      let newCode = s.toString().replace(/\\n+/g, '\\n');\n      for (const name of exportNames) {\n        const value = `() => { throw new Error('It is not possible to invoke a client function from the server: ${JSON.stringify(name)}') }`;\n        newCode += `\\nexport ${name === 'default' ? name : `const ${name} =`} ${value};`;\n      }\n      return '\"use client\";' + newCode.trim() + '\\n';\n    },\n  };\n}\n"],"names":["MagicString","parseAstAsync","isNode","value","type","isNodeWithRange","node","start","end","isIdentifierWithRange","isExpressionWithRange","getImportedName","specifier","imported","name","String","getExportedName","exported","getLocalExportName","local","getExpressionFromArguments","args","length","Error","arg","argument","isUseDirective","stmt","directive","expression","getDeclarationId","item","id","transformExportedClientThings","mod","exportNames","Set","allowServerItems","Map","allowServerDependencies","visited","WeakSet","findDependencies","has","add","Object","values","forEach","Array","isArray","v","allowServer","body","source","specifiers","declaration","d","declarations","init","callee","arguments","set","s","localName","dependenciesSize","size","declId","delete","shouldKeepStatement","dependencies","some","hasDirective","allowServerPlugin","transform","code","environment","includes","jsx","remove","allowServerName","callExp","expressionSource","slice","append","newCode","toString","replace","JSON","stringify","trim"],"mappings":"AACA,OAAOA,iBAAiB,eAAe;AAEvC,SAASC,aAAa,QAAQ,OAAO;AAIrC,MAAMC,SAAS,CAACC,QACd,OAAQA,OAA8BC,SAAS,UAAU,YAAY;AAEvE,MAAMC,kBAAkB,CACtBC,OAEA,OAAQA,MAA8BC,UAAU,YAChD,OAAQD,MAA4BE,QAAQ;AAE9C,MAAMC,wBAAwB,CAC5BH,OAEAA,KAAKF,IAAI,KAAK,gBACd,OAAO,AAACE,KAA6BC,KAAK,KAAK,YAC/C,OAAO,AAACD,KAA2BE,GAAG,KAAK;AAE7C,MAAME,wBAAwB,CAC5BJ,OAEA,OAAO,AAACA,KAA6BC,KAAK,KAAK,YAC/C,OAAO,AAACD,KAA2BE,GAAG,KAAK;AAE7C,MAAMG,kBAAkB,CAACC,YACvBA,UAAUC,QAAQ,CAACT,IAAI,KAAK,eACxBQ,UAAUC,QAAQ,CAACC,IAAI,GACvBC,OAAOH,UAAUC,QAAQ,CAACV,KAAK;AAErC,MAAMa,kBAAkB,CAACJ,YACvBA,UAAUK,QAAQ,CAACb,IAAI,KAAK,eACxBQ,UAAUK,QAAQ,CAACH,IAAI,GACvBC,OAAOH,UAAUK,QAAQ,CAACd,KAAK;AAErC,MAAMe,qBAAqB,CAACN,YAC1BA,UAAUO,KAAK,CAACf,IAAI,KAAK,eACrBQ,UAAUO,KAAK,CAACL,IAAI,GACpB,OAAOF,UAAUO,KAAK,CAAChB,KAAK,KAAK,WAC/BS,UAAUO,KAAK,CAAChB,KAAK,GACrB;AAER,MAAMiB,6BAA6B,CACjCC;IAEA,IAAIA,KAAKC,MAAM,KAAK,GAAG;QACrB,MAAM,IAAIC,MAAM;IAClB;IACA,MAAMC,MAAMH,IAAI,CAAC,EAAE;IACnB,MAAMI,WAAWD,IAAIpB,IAAI,KAAK,kBAAkBoB,IAAIC,QAAQ,GAAGD;IAC/D,IAAI,CAACd,sBAAsBe,WAAW;QACpC,MAAM,IAAIF,MAAM;IAClB;IACA,OAAOE;AACT;AAEA,MAAMC,iBAAiB,CAACC,MAAmBC,YACzCD,KAAKvB,IAAI,KAAK,yBACduB,KAAKE,UAAU,CAACzB,IAAI,KAAK,aACzBuB,KAAKE,UAAU,CAAC1B,KAAK,KAAKyB;AAE5B,MAAME,mBAAmB,CAACC,OACxB,AAACA,CAAAA,KAAK3B,IAAI,KAAK,yBAAyB2B,KAAK3B,IAAI,KAAK,kBAAiB,KACvEK,sBAAsBsB,KAAKC,EAAE,KAC7BD,KAAKC,EAAE;AAET,MAAMC,gCAAgC,CAACC;IACrC,MAAMC,cAAc,IAAIC;IACxB,oCAAoC;IACpC,MAAMC,mBAAmB,IAAIC;IAI7B,MAAMC,0BAA0B,IAAIH;IACpC,MAAMI,UAAU,IAAIC;IACpB,MAAMC,mBAAmB,CAACpC;QACxB,IAAIkC,QAAQG,GAAG,CAACrC,OAAO;YACrB;QACF;QACAkC,QAAQI,GAAG,CAACtC;QACZ,IAAIA,KAAKF,IAAI,KAAK,cAAc;YAC9B,IAAI,CAACiC,iBAAiBM,GAAG,CAACrC,KAAKQ,IAAI,KAAK,CAACqB,YAAYQ,GAAG,CAACrC,KAAKQ,IAAI,GAAG;gBACnEyB,wBAAwBK,GAAG,CAACtC,KAAKQ,IAAI;YACvC;QACF;QACA+B,OAAOC,MAAM,CAACxC,MAAMyC,OAAO,CAAC,CAAC5C;YAC1B6C,CAAAA,MAAMC,OAAO,CAAC9C,SAASA,QAAQ;gBAACA;aAAM,AAAD,EAAG4C,OAAO,CAAC,CAACG;gBAChD,IAAIhD,OAAOgD,IAAI;oBACbR,iBAAiBQ;gBACnB;YACF;QACF;IACF;IACA,sCAAsC;IACtC,IAAIC,cAAc;IAClB,KAAK,MAAMpB,QAAQG,IAAIkB,IAAI,CAAE;QAC3B,IACErB,KAAK3B,IAAI,KAAK,uBACd2B,KAAKsB,MAAM,CAACjD,IAAI,KAAK,aACrB2B,KAAKsB,MAAM,CAAClD,KAAK,KAAK,eACtB;YACA,KAAK,MAAMS,aAAamB,KAAKuB,UAAU,CAAE;gBACvC,IACE1C,UAAUR,IAAI,KAAK,qBACnBQ,UAAUC,QAAQ,CAACT,IAAI,KAAK,gBAC5BQ,UAAUC,QAAQ,CAACC,IAAI,KAAKqC,aAC5B;oBACAA,cAAcvC,UAAUO,KAAK,CAACL,IAAI;oBAClC;gBACF;YACF;YACA;QACF;IACF;IACA,qDAAqD;IACrD,KAAK,MAAMiB,QAAQG,IAAIkB,IAAI,CAAE;QAC3B,IAAIrB,KAAK3B,IAAI,KAAK,0BAA0B;YAC1C,IACE2B,KAAKwB,WAAW,EAAEnD,SAAS,yBAC3B2B,KAAKwB,WAAW,CAACvB,EAAE,EACnB;gBACAG,YAAYS,GAAG,CAACb,KAAKwB,WAAW,CAACvB,EAAE,CAAClB,IAAI;YAC1C,OAAO,IACLiB,KAAKwB,WAAW,EAAEnD,SAAS,sBAC3B2B,KAAKwB,WAAW,CAACvB,EAAE,EACnB;gBACAG,YAAYS,GAAG,CAACb,KAAKwB,WAAW,CAACvB,EAAE,CAAClB,IAAI;YAC1C,OAAO,IAAIiB,KAAKwB,WAAW,EAAEnD,SAAS,uBAAuB;gBAC3D,KAAK,MAAMoD,KAAKzB,KAAKwB,WAAW,CAACE,YAAY,CAAE;oBAC7C,IAAIhD,sBAAsB+C,EAAExB,EAAE,GAAG;wBAC/B,IACEwB,EAAEE,IAAI,EAAEtD,SAAS,oBACjBoD,EAAEE,IAAI,CAACC,MAAM,CAACvD,IAAI,KAAK,gBACvBoD,EAAEE,IAAI,CAACC,MAAM,CAAC7C,IAAI,KAAKqC,aACvB;4BACA,MAAM3B,MAAMJ,2BAA2BoC,EAAEE,IAAI,CAACE,SAAS;4BACvDvB,iBAAiBwB,GAAG,CAACL,EAAExB,EAAE,CAAClB,IAAI,EAAEU;4BAChCkB,iBAAiBc,EAAEE,IAAI;wBACzB,OAAO;4BACLvB,YAAYS,GAAG,CAACY,EAAExB,EAAE,CAAClB,IAAI;wBAC3B;oBACF;gBACF;YACF;YACA,KAAK,MAAMgD,KAAK/B,KAAKuB,UAAU,CAAE;gBAC/B,IAAIQ,EAAE1D,IAAI,KAAK,mBAAmB;oBAChC,MAAM2D,YAAY7C,mBAAmB4C;oBACrC,IAAIC,aAAa1B,iBAAiBM,GAAG,CAACoB,YAAY;wBAChD;oBACF;oBACA5B,YAAYS,GAAG,CAAC5B,gBAAgB8C;gBAClC;YACF;QACF,OAAO,IAAI/B,KAAK3B,IAAI,KAAK,4BAA4B;YACnD+B,YAAYS,GAAG,CAAC;QAClB,OAAO,IAAIb,KAAK3B,IAAI,KAAK,wBAAwB;YAC/C,IAAI2B,KAAKd,QAAQ,EAAEb,SAAS,cAAc;gBACxC+B,YAAYS,GAAG,CAACb,KAAKd,QAAQ,CAACH,IAAI;YACpC;QACF,OAAO,IAAIiB,KAAK3B,IAAI,KAAK,uBAAuB;YAC9C,KAAK,MAAMoD,KAAKzB,KAAK0B,YAAY,CAAE;gBACjC,IACEhD,sBAAsB+C,EAAExB,EAAE,KAC1BwB,EAAEE,IAAI,EAAEtD,SAAS,oBACjBoD,EAAEE,IAAI,CAACC,MAAM,CAACvD,IAAI,KAAK,gBACvBoD,EAAEE,IAAI,CAACC,MAAM,CAAC7C,IAAI,KAAKqC,aACvB;oBACA,MAAM3B,MAAMJ,2BAA2BoC,EAAEE,IAAI,CAACE,SAAS;oBACvDvB,iBAAiBwB,GAAG,CAACL,EAAExB,EAAE,CAAClB,IAAI,EAAEU;oBAChCkB,iBAAiBc,EAAEE,IAAI;gBACzB;YACF;QACF;IACF;IACA,+BAA+B;IAC/B,IAAIM;IACJ,GAAG;QACDA,mBAAmBzB,wBAAwB0B,IAAI;QAC/C,KAAK,MAAMlC,QAAQG,IAAIkB,IAAI,CAAE;YAC3B,IAAIrB,KAAK3B,IAAI,KAAK,uBAAuB;gBACvC,KAAK,MAAMoD,KAAKzB,KAAK0B,YAAY,CAAE;oBACjC,IACEhD,sBAAsB+C,EAAExB,EAAE,KAC1BO,wBAAwBI,GAAG,CAACa,EAAExB,EAAE,CAAClB,IAAI,GACrC;wBACA4B,iBAAiBc;oBACnB;gBACF;YACF,OAAO;gBACL,MAAMU,SAASpC,iBAAiBC;gBAChC,IAAImC,UAAU3B,wBAAwBI,GAAG,CAACuB,OAAOpD,IAAI,GAAG;oBACtD4B,iBAAiBX;gBACnB;YACF;QACF;IACF,QAASiC,mBAAmBzB,wBAAwB0B,IAAI,CAAE;IAC1D1B,wBAAwB4B,MAAM,CAAChB;IAC/B,OAAO;QAAEZ;QAAyBF;QAAkBF;IAAY;AAClE;AAEA,MAAMiC,sBAAsB,CAACzC,MAAmB0C;IAC9C,IAAI1C,KAAKvB,IAAI,KAAK,qBAAqB;QACrC,OAAOuB,KAAK2B,UAAU,CAACgB,IAAI,CACzB,CAACR,IACCA,EAAE1D,IAAI,KAAK,qBACViE,CAAAA,aAAa1B,GAAG,CAAChC,gBAAgBmD,OAChCO,aAAa1B,GAAG,CAACmB,EAAE3C,KAAK,CAACL,IAAI,CAAA;IAErC;IACA,IAAIa,KAAKvB,IAAI,KAAK,uBAAuB;QACvC,OAAOuB,KAAK8B,YAAY,CAACa,IAAI,CAC3B,CAACd,IAAM/C,sBAAsB+C,EAAExB,EAAE,KAAKqC,aAAa1B,GAAG,CAACa,EAAExB,EAAE,CAAClB,IAAI;IAEpE;IACA,MAAMoD,SAASpC,iBAAiBH;IAChC,IAAIuC,QAAQ;QACV,OAAOG,aAAa1B,GAAG,CAACuB,OAAOpD,IAAI;IACrC;IACA,OAAO;AACT;AAEA,MAAMyD,eAAe,CAACrC,KAAkBN;IACtC,KAAK,MAAMG,QAAQG,IAAIkB,IAAI,CAAE;QAC3B,IACErB,KAAK3B,IAAI,KAAK,yBACd2B,KAAKF,UAAU,CAACzB,IAAI,KAAK,aACzB2B,KAAKF,UAAU,CAAC1B,KAAK,KAAKyB,WAC1B;YACA,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEA,OAAO,SAAS4C;IACd,OAAO;QACL1D,MAAM;QACN,MAAM2D,WAAUC,IAAI;YAClB,IAAI,IAAI,CAACC,WAAW,CAAC7D,IAAI,KAAK,OAAO;gBACnC;YACF;YACA,IAAI,CAAC4D,KAAKE,QAAQ,CAAC,eAAe;gBAChC;YACF;YAEA,MAAM1C,MAAM,MAAMjC,cAAcyE,MAAM;gBAAEG,KAAK;YAAK;YAClD,IAAI,CAACN,aAAarC,KAAK,eAAe;gBACpC;YACF;YAEA,MAAM,EAAEK,uBAAuB,EAAEF,gBAAgB,EAAEF,WAAW,EAAE,GAC9DF,8BAA8BC;YAEhC,MAAM4B,IAAI,IAAI9D,YAAY0E;YAC1B,KAAK,MAAM3C,QAAQG,IAAIkB,IAAI,CAAE;gBAC3B,IAAI,CAAC/C,gBAAgB0B,OAAO;oBAC1B,MAAM,IAAIR,MAAM;gBAClB;gBACA,IAAIG,eAAeK,MAAM,eAAe;oBACtC+B,EAAEgB,MAAM,CAAC/C,KAAKxB,KAAK,EAAEwB,KAAKvB,GAAG;oBAC7B;gBACF;gBACA,IAAI4D,oBAAoBrC,MAAMQ,0BAA0B;oBACtD;gBACF;gBACAuB,EAAEgB,MAAM,CAAC/C,KAAKxB,KAAK,EAAEwB,KAAKvB,GAAG;YAC/B;YAEA,KAAK,MAAM,CAACuE,iBAAiBC,QAAQ,IAAI3C,iBAAkB;gBACzD,MAAM4C,mBAAmBP,KAAKQ,KAAK,CAACF,QAAQzE,KAAK,EAAEyE,QAAQxE,GAAG;gBAC9DsD,EAAEqB,MAAM,CAAC,CAAC,eAAe,EAAEJ,gBAAgB,GAAG,EAAEE,iBAAiB,CAAC,CAAC;YACrE;YACA,IAAIG,UAAUtB,EAAEuB,QAAQ,GAAGC,OAAO,CAAC,QAAQ;YAC3C,KAAK,MAAMxE,QAAQqB,YAAa;gBAC9B,MAAMhC,QAAQ,CAAC,yFAAyF,EAAEoF,KAAKC,SAAS,CAAC1E,MAAM,IAAI,CAAC;gBACpIsE,WAAW,CAAC,SAAS,EAAEtE,SAAS,YAAYA,OAAO,CAAC,MAAM,EAAEA,KAAK,EAAE,CAAC,CAAC,CAAC,EAAEX,MAAM,CAAC,CAAC;YAClF;YACA,OAAO,kBAAkBiF,QAAQK,IAAI,KAAK;QAC5C;IACF;AACF"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/vite-plugins/allow-server.ts"],"sourcesContent":["import MagicString from 'magic-string';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync } from 'vite';\n\ntype ProgramNode = Awaited<ReturnType<typeof parseAstAsync>>;\ntype BodyItem = ProgramNode['body'][number];\ntype VariableDeclaration = BodyItem & {\n  type: 'VariableDeclaration';\n};\ntype VariableDeclarator = VariableDeclaration['declarations'][number];\ntype ImportDeclaration = BodyItem & {\n  type: 'ImportDeclaration';\n};\ntype ImportSpecifier = ImportDeclaration['specifiers'][number] & {\n  type: 'ImportSpecifier';\n};\ntype ExportNamedDeclaration = BodyItem & {\n  type: 'ExportNamedDeclaration';\n};\ntype ExportSpecifier = ExportNamedDeclaration['specifiers'][number] & {\n  type: 'ExportSpecifier';\n};\ntype ExpressionStatement = BodyItem & {\n  type: 'ExpressionStatement';\n};\ntype Expression = ExpressionStatement['expression'];\ntype AstNode = BodyItem | Expression | VariableDeclarator; // not fully covered\ntype CallExpression = Expression & { type: 'CallExpression' };\ntype CallArguments = CallExpression['arguments'];\n\nconst isNode = (value: unknown): value is AstNode =>\n  typeof (value as { type?: unknown })?.type === 'string'; // heuristic\n\nconst isNodeWithRange = (\n  node: AstNode,\n): node is AstNode & { start: number; end: number } =>\n  typeof (node as { start?: unknown })?.start === 'number' &&\n  typeof (node as { end?: unknown })?.end === 'number';\n\nconst getImportedName = (specifier: ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nconst getLocalExportName = (specifier: ExportSpecifier) =>\n  specifier.local.type === 'Identifier'\n    ? specifier.local.name\n    : typeof specifier.local.value === 'string'\n      ? specifier.local.value\n      : null;\n\nconst getExpressionFromArguments = (args: CallArguments) => {\n  if (args.length !== 1) {\n    throw new Error('allowServer should have exactly one argument');\n  }\n  const arg = args[0]!;\n  const argument = arg.type === 'SpreadElement' ? arg.argument : arg;\n  if (!isNodeWithRange(argument)) {\n    throw new Error('Missing range');\n  }\n  return argument;\n};\n\nconst isUseDirective = (stmt: BodyItem, directive: string) =>\n  stmt.type === 'ExpressionStatement' &&\n  stmt.expression.type === 'Literal' &&\n  stmt.expression.value === directive;\n\nconst getDeclarationId = (item: BodyItem) =>\n  (item.type === 'FunctionDeclaration' || item.type === 'ClassDeclaration') &&\n  item.id.type === 'Identifier' &&\n  item.id;\n\nconst transformExportedClientThings = (mod: ProgramNode) => {\n  const exportNames = new Set<string>();\n  // HACK this doesn't cover all cases\n  const allowServerItems = new Map<\n    string,\n    Expression & { start: number; end: number }\n  >();\n  const allowServerDependencies = new Set<string>();\n  const visited = new WeakSet<AstNode>();\n  const findDependencies = (node: AstNode) => {\n    if (visited.has(node)) {\n      return;\n    }\n    visited.add(node);\n    if (node.type === 'Identifier') {\n      if (!allowServerItems.has(node.name) && !exportNames.has(node.name)) {\n        allowServerDependencies.add(node.name);\n      }\n    }\n    Object.values(node).forEach((value: unknown) => {\n      (Array.isArray(value) ? value : [value]).forEach((v: unknown) => {\n        if (isNode(v)) {\n          findDependencies(v);\n        }\n      });\n    });\n  };\n  // Pass 1: find allowServer identifier\n  let allowServer = 'unstable_allowServer';\n  for (const item of mod.body) {\n    if (\n      item.type === 'ImportDeclaration' &&\n      item.source.type === 'Literal' &&\n      item.source.value === 'waku/client'\n    ) {\n      for (const specifier of item.specifiers) {\n        if (\n          specifier.type === 'ImportSpecifier' &&\n          specifier.imported.type === 'Identifier' &&\n          specifier.imported.name === allowServer\n        ) {\n          allowServer = specifier.local.name;\n          break;\n        }\n      }\n      break;\n    }\n  }\n  // Pass 2: collect export names and allowServer names\n  for (const item of mod.body) {\n    if (item.type === 'ExportNamedDeclaration') {\n      if (\n        item.declaration?.type === 'FunctionDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (\n        item.declaration?.type === 'ClassDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (item.declaration?.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (d.id.type === 'Identifier') {\n            if (\n              d.init?.type === 'CallExpression' &&\n              d.init.callee.type === 'Identifier' &&\n              d.init.callee.name === allowServer\n            ) {\n              const arg = getExpressionFromArguments(d.init.arguments);\n              allowServerItems.set(d.id.name, arg);\n              findDependencies(d.init);\n            } else {\n              exportNames.add(d.id.name);\n            }\n          }\n        }\n      }\n      for (const s of item.specifiers) {\n        if (s.type === 'ExportSpecifier') {\n          const localName = getLocalExportName(s);\n          if (localName && allowServerItems.has(localName)) {\n            continue;\n          }\n          exportNames.add(getExportedName(s));\n        }\n      }\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      exportNames.add('default');\n    } else if (item.type === 'ExportAllDeclaration') {\n      if (item.exported?.type === 'Identifier') {\n        exportNames.add(item.exported.name);\n      }\n    } else if (item.type === 'VariableDeclaration') {\n      for (const d of item.declarations) {\n        if (\n          d.id.type === 'Identifier' &&\n          d.init?.type === 'CallExpression' &&\n          d.init.callee.type === 'Identifier' &&\n          d.init.callee.name === allowServer\n        ) {\n          const arg = getExpressionFromArguments(d.init.arguments);\n          allowServerItems.set(d.id.name, arg);\n          findDependencies(d.init);\n        }\n      }\n    }\n  }\n  // Pass 3: collect dependencies\n  let dependenciesSize: number;\n  do {\n    dependenciesSize = allowServerDependencies.size;\n    for (const item of mod.body) {\n      if (item.type === 'VariableDeclaration') {\n        for (const d of item.declarations) {\n          if (\n            d.id.type === 'Identifier' &&\n            allowServerDependencies.has(d.id.name)\n          ) {\n            findDependencies(d);\n          }\n        }\n      } else {\n        const declId = getDeclarationId(item);\n        if (declId && allowServerDependencies.has(declId.name)) {\n          findDependencies(item);\n        }\n      }\n    }\n  } while (dependenciesSize < allowServerDependencies.size);\n  allowServerDependencies.delete(allowServer);\n  return { allowServerDependencies, allowServerItems, exportNames };\n};\n\nconst shouldKeepStatement = (stmt: BodyItem, dependencies: Set<string>) => {\n  if (stmt.type === 'ImportDeclaration') {\n    return stmt.specifiers.some(\n      (s) =>\n        s.type === 'ImportSpecifier' &&\n        (dependencies.has(getImportedName(s)) ||\n          dependencies.has(s.local.name)),\n    );\n  }\n  if (stmt.type === 'VariableDeclaration') {\n    return stmt.declarations.some(\n      (d) => d.id.type === 'Identifier' && dependencies.has(d.id.name),\n    );\n  }\n  const declId = getDeclarationId(stmt);\n  if (declId) {\n    return dependencies.has(declId.name);\n  }\n  return false;\n};\n\nconst hasDirective = (mod: ProgramNode, directive: string) => {\n  for (const item of mod.body) {\n    if (\n      item.type === 'ExpressionStatement' &&\n      item.expression.type === 'Literal' &&\n      item.expression.value === directive\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport function allowServerPlugin(): Plugin {\n  return {\n    name: 'waku:vite-plugins:allow-server',\n    async transform(code) {\n      if (this.environment.name !== 'rsc') {\n        return;\n      }\n      if (!code.includes('use client')) {\n        return;\n      }\n\n      const mod = await parseAstAsync(code, { jsx: true });\n      if (!hasDirective(mod, 'use client')) {\n        return;\n      }\n\n      const { allowServerDependencies, allowServerItems, exportNames } =\n        transformExportedClientThings(mod);\n\n      const s = new MagicString(code);\n      for (const item of mod.body) {\n        if (!isNodeWithRange(item)) {\n          throw new Error('Expected NodeWithRange');\n        }\n        if (isUseDirective(item, 'use client')) {\n          s.remove(item.start, item.end);\n          continue;\n        }\n        if (shouldKeepStatement(item, allowServerDependencies)) {\n          continue;\n        }\n        s.remove(item.start, item.end);\n      }\n\n      for (const [allowServerName, callExp] of allowServerItems) {\n        const expressionSource = code.slice(callExp.start, callExp.end);\n        s.append(`\\nexport const ${allowServerName} = ${expressionSource};`);\n      }\n      let newCode = s.toString().replace(/\\n+/g, '\\n');\n      for (const name of exportNames) {\n        const value = `() => { throw new Error('It is not possible to invoke a client function from the server: ${JSON.stringify(name)}') }`;\n        newCode += `\\nexport ${name === 'default' ? name : `const ${name} =`} ${value};`;\n      }\n      return '\"use client\";' + newCode.trim() + '\\n';\n    },\n  };\n}\n"],"names":["MagicString","parseAstAsync","isNode","value","type","isNodeWithRange","node","start","end","getImportedName","specifier","imported","name","String","getExportedName","exported","getLocalExportName","local","getExpressionFromArguments","args","length","Error","arg","argument","isUseDirective","stmt","directive","expression","getDeclarationId","item","id","transformExportedClientThings","mod","exportNames","Set","allowServerItems","Map","allowServerDependencies","visited","WeakSet","findDependencies","has","add","Object","values","forEach","Array","isArray","v","allowServer","body","source","specifiers","declaration","d","declarations","init","callee","arguments","set","s","localName","dependenciesSize","size","declId","delete","shouldKeepStatement","dependencies","some","hasDirective","allowServerPlugin","transform","code","environment","includes","jsx","remove","allowServerName","callExp","expressionSource","slice","append","newCode","toString","replace","JSON","stringify","trim"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/vite-plugins/fs-router-typegen.js.map b/dist/lib/vite-plugins/fs-router-typegen.js.map
index 4187d72051d3bbc052d2b084d126d90f0335c5bf..395c7a492fffd92a08fcdec1c0202ac0799a8d17 100644
--- a/dist/lib/vite-plugins/fs-router-typegen.js.map
+++ b/dist/lib/vite-plugins/fs-router-typegen.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/vite-plugins/fs-router-typegen.ts"],"sourcesContent":["import { existsSync, readFileSync } from 'node:fs';\nimport { readdir, writeFile } from 'node:fs/promises';\nimport type * as estree from 'estree';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync, transformWithEsbuild } from 'vite';\nimport { EXTENSIONS, SRC_PAGES, SRC_SERVER_ENTRY } from '../constants.js';\nimport { getGrouplessPath } from '../utils/create-pages.js';\nimport { isIgnoredPath } from '../utils/fs-router.js';\nimport { joinPath } from '../utils/path.js';\n\n// https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-names-and-keywords\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\nexport function toIdentifier(input: string): string {\n  // Strip the file extension\n  let identifier = input.includes('.')\n    ? input.split('.').slice(0, -1).join('.')\n    : input;\n  // Replace any characters besides letters, numbers, underscores, and dollar signs with underscores\n  identifier = identifier.replace(/[^\\p{L}\\p{N}_$]/gu, '_');\n  // Ensure it starts with a letter\n  if (/^\\d/.test(identifier)) {\n    identifier = '_' + identifier;\n  }\n  // Turn it into PascalCase\n  // Since the first letter is uppercased, it will not be a reserved word\n  return (\n    'File_' +\n    identifier\n      .split('_')\n      .map((part) => {\n        if (part[0] === undefined) {\n          return '';\n        }\n        return part[0].toUpperCase() + part.slice(1);\n      })\n      .join('')\n  );\n}\n\nexport function getImportModuleNames(filePaths: string[]): {\n  [k: string]: string;\n} {\n  const moduleNameCount: { [k: string]: number } = {};\n  const moduleNames: { [k: string]: string } = {};\n  for (const filePath of filePaths) {\n    let identifier = toIdentifier(filePath);\n    moduleNameCount[identifier] = (moduleNameCount[identifier] ?? -1) + 1;\n    if (moduleNameCount[identifier]) {\n      identifier = `${identifier}_${moduleNameCount[identifier]}`;\n    }\n    try {\n      moduleNames[filePath.replace(/^\\//, '')] = identifier;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  return moduleNames;\n}\n\nconst parseModule = async (filePath: string) => {\n  const source = readFileSync(filePath, 'utf8');\n  const loader: 'jsx' | 'ts' | 'tsx' = filePath.endsWith('.tsx')\n    ? 'tsx'\n    : filePath.endsWith('.ts')\n      ? 'ts'\n      : 'jsx';\n  const transformed = await transformWithEsbuild(source, filePath, {\n    loader,\n    jsx: 'preserve',\n  });\n  return parseAstAsync(transformed.code, { jsx: true });\n};\n\nconst getImportedName = (specifier: estree.ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: estree.ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nexport const fsRouterTypegenPlugin = (opts: { srcDir: string }): Plugin => {\n  return {\n    name: 'waku:vite-plugins:fs-router-typegen',\n    apply: 'serve',\n    configureServer(server) {\n      const srcDir = joinPath(server.config.root, opts.srcDir);\n      const pagesDir = joinPath(srcDir, SRC_PAGES);\n\n      const outputFile = joinPath(srcDir, 'pages.gen.ts');\n      const updateGeneratedFile = async (file: string | undefined) => {\n        // skip when the changed file is the generated file itself\n        if (file && outputFile.endsWith(file)) {\n          return;\n        }\n        // skip when the entries file exists or pages dir does not exist\n        if (!existsSync(pagesDir) || !(await detectFsRouterUsage(srcDir))) {\n          return;\n        }\n        const generation = await generateFsRouterTypes(pagesDir);\n        if (!generation) {\n          // skip failures\n          return;\n        }\n        await writeFile(outputFile, generation, 'utf-8');\n      };\n\n      server.watcher.on('change', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('add', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('unlink', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      void updateGeneratedFile(undefined);\n    },\n  };\n};\n\nexport async function detectFsRouterUsage(srcDir: string): Promise<boolean> {\n  const existingServerEntry = EXTENSIONS.map((ext) =>\n    joinPath(srcDir, SRC_SERVER_ENTRY + ext),\n  ).find((entriesFile) => existsSync(entriesFile));\n\n  // managed mode if no entry\n  if (!existingServerEntry) {\n    return true;\n  }\n\n  try {\n    const file = await parseModule(existingServerEntry);\n    const usesFsRouter = file.body.some((node) => {\n      if (node.type !== 'ImportDeclaration') {\n        return false;\n      }\n      if (\n        node.source.type !== 'Literal' ||\n        typeof node.source.value !== 'string' ||\n        !node.source.value.startsWith('waku')\n      ) {\n        return false;\n      }\n      return node.specifiers.some((specifier) => {\n        if (\n          specifier.type !== 'ImportSpecifier' ||\n          specifier.local.type !== 'Identifier'\n        ) {\n          return false;\n        }\n        return getImportedName(specifier) === 'fsRouter';\n      });\n    });\n    return usesFsRouter;\n  } catch {\n    return false;\n  }\n}\n\nexport async function generateFsRouterTypes(pagesDir: string) {\n  // Recursively collect `.tsx` files in the given directory\n  const collectFiles = async (\n    dir: string,\n    files: string[] = [],\n  ): Promise<string[]> => {\n    // TODO revisit recursive option for readdir once more stable\n    // https://nodejs.org/docs/latest-v20.x/api/fs.html#direntparentpath\n    const entries = await readdir(dir, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = joinPath(dir, entry.name);\n      if (entry.isDirectory()) {\n        await collectFiles(fullPath, files);\n      } else {\n        if (entry.name.endsWith('.tsx')) {\n          files.push(fullPath.slice(pagesDir.length));\n        }\n      }\n    }\n    return files;\n  };\n\n  const fileExportsGetConfig = async (filePath: string) => {\n    const file = await parseModule(pagesDir + filePath);\n    return file.body.some((node) => {\n      if (node.type !== 'ExportNamedDeclaration') {\n        return false;\n      }\n      if (\n        node.declaration?.type === 'VariableDeclaration' &&\n        node.declaration.declarations.some(\n          (decl) =>\n            decl.id.type === 'Identifier' && decl.id.name === 'getConfig',\n        )\n      ) {\n        return true;\n      }\n      if (\n        node.declaration?.type === 'FunctionDeclaration' &&\n        node.declaration.id?.name === 'getConfig'\n      ) {\n        return true;\n      }\n      return node.specifiers.some(\n        (specifier) =>\n          specifier.type === 'ExportSpecifier' &&\n          getExportedName(specifier) === 'getConfig',\n      );\n    });\n  };\n\n  const generateFile = async (filePaths: string[]): Promise<string | null> => {\n    const fileInfo: { path: string; src: string; hasGetConfig: boolean }[] = [];\n    const moduleNames = getImportModuleNames(filePaths);\n\n    for (const filePath of filePaths) {\n      // where to import the component from\n      const src = filePath.replace(/^\\//, '');\n      let hasGetConfig = false;\n      try {\n        hasGetConfig = await fileExportsGetConfig(filePath);\n      } catch {\n        return null;\n      }\n\n      if (\n        filePath.endsWith('/_layout.tsx') ||\n        isIgnoredPath(filePath.split('/'))\n      ) {\n        continue;\n      } else if (filePath.endsWith('/index.tsx')) {\n        const path = filePath.slice(0, -'/index.tsx'.length);\n        fileInfo.push({\n          path: getGrouplessPath(path) || '/',\n          src,\n          hasGetConfig,\n        });\n      } else {\n        fileInfo.push({\n          path: getGrouplessPath(filePath.replace('.tsx', '')),\n          src,\n          hasGetConfig,\n        });\n      }\n    }\n\n    const hasAnyGetConfig = fileInfo.some((file) => file.hasGetConfig);\n    const lines: string[] = [\n      '// deno-fmt-ignore-file',\n      '// biome-ignore format: generated types do not need formatting',\n      '// prettier-ignore',\n      hasAnyGetConfig\n        ? \"import type { PathsForPages, GetConfigResponse } from 'waku/router';\"\n        : \"import type { PathsForPages } from 'waku/router';\",\n    ];\n\n    if (hasAnyGetConfig) {\n      lines.push('');\n      for (const file of fileInfo) {\n        if (!file.hasGetConfig) {\n          continue;\n        }\n        const moduleName = moduleNames[file.src];\n        lines.push(\n          `// prettier-ignore`,\n          `import type { getConfig as ${moduleName}_getConfig } from './${SRC_PAGES}/${file.src.replace('.tsx', '')}';`,\n        );\n      }\n    }\n\n    lines.push('', '// prettier-ignore', 'type Page =');\n    for (const file of fileInfo) {\n      const moduleName = moduleNames[file.src];\n      if (file.hasGetConfig) {\n        lines.push(\n          `| ({ path: '${file.path}' } & GetConfigResponse<typeof ${moduleName}_getConfig>)`,\n        );\n      } else {\n        lines.push(`| { path: '${file.path}'; render: 'static' }`);\n      }\n    }\n    lines[lines.length - 1] += ';';\n\n    lines.push(\n      '',\n      '// prettier-ignore',\n      \"declare module 'waku/router' {\",\n      '  interface RouteConfig {',\n      '    paths: PathsForPages<Page>;',\n      '  }',\n      '  interface CreatePagesConfig {',\n      '    pages: Page;',\n      '  }',\n      '}',\n      '',\n    );\n\n    const result = lines.join('\\n');\n\n    return result;\n  };\n\n  const files = await collectFiles(pagesDir);\n  if (!files.length) {\n    return;\n  }\n  const generation = await generateFile(files);\n  return generation;\n}\n"],"names":["existsSync","readFileSync","readdir","writeFile","parseAstAsync","transformWithEsbuild","EXTENSIONS","SRC_PAGES","SRC_SERVER_ENTRY","getGrouplessPath","isIgnoredPath","joinPath","toIdentifier","input","identifier","includes","split","slice","join","replace","test","map","part","undefined","toUpperCase","getImportModuleNames","filePaths","moduleNameCount","moduleNames","filePath","e","console","log","parseModule","source","loader","endsWith","transformed","jsx","code","getImportedName","specifier","imported","type","name","String","value","getExportedName","exported","fsRouterTypegenPlugin","opts","apply","configureServer","server","srcDir","config","root","pagesDir","outputFile","updateGeneratedFile","file","detectFsRouterUsage","generation","generateFsRouterTypes","watcher","on","existingServerEntry","ext","find","entriesFile","usesFsRouter","body","some","node","startsWith","specifiers","local","collectFiles","dir","files","entries","withFileTypes","entry","fullPath","isDirectory","push","length","fileExportsGetConfig","declaration","declarations","decl","id","generateFile","fileInfo","src","hasGetConfig","path","hasAnyGetConfig","lines","moduleName","result"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/vite-plugins/fs-router-typegen.ts"],"sourcesContent":["import { existsSync, readFileSync } from 'node:fs';\nimport { readdir, writeFile } from 'node:fs/promises';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync, transformWithEsbuild } from 'vite';\nimport { EXTENSIONS, SRC_PAGES, SRC_SERVER_ENTRY } from '../constants.js';\nimport { getGrouplessPath } from '../utils/create-pages.js';\nimport { isIgnoredPath } from '../utils/fs-router.js';\nimport { joinPath } from '../utils/path.js';\n\ntype ProgramNode = Awaited<ReturnType<typeof parseAstAsync>>;\ntype ImportDeclaration = ProgramNode['body'][number] & {\n  type: 'ImportDeclaration';\n};\ntype ImportSpecifier = ImportDeclaration['specifiers'][number] & {\n  type: 'ImportSpecifier';\n};\ntype ExportNamedDeclaration = ProgramNode['body'][number] & {\n  type: 'ExportNamedDeclaration';\n};\ntype ExportSpecifier = ExportNamedDeclaration['specifiers'][number] & {\n  type: 'ExportSpecifier';\n};\n\n// https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-names-and-keywords\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\nexport function toIdentifier(input: string): string {\n  // Strip the file extension\n  let identifier = input.includes('.')\n    ? input.split('.').slice(0, -1).join('.')\n    : input;\n  // Replace any characters besides letters, numbers, underscores, and dollar signs with underscores\n  identifier = identifier.replace(/[^\\p{L}\\p{N}_$]/gu, '_');\n  // Ensure it starts with a letter\n  if (/^\\d/.test(identifier)) {\n    identifier = '_' + identifier;\n  }\n  // Turn it into PascalCase\n  // Since the first letter is uppercased, it will not be a reserved word\n  return (\n    'File_' +\n    identifier\n      .split('_')\n      .map((part) => {\n        if (part[0] === undefined) {\n          return '';\n        }\n        return part[0].toUpperCase() + part.slice(1);\n      })\n      .join('')\n  );\n}\n\nexport function getImportModuleNames(filePaths: string[]): {\n  [k: string]: string;\n} {\n  const moduleNameCount: { [k: string]: number } = {};\n  const moduleNames: { [k: string]: string } = {};\n  for (const filePath of filePaths) {\n    let identifier = toIdentifier(filePath);\n    moduleNameCount[identifier] = (moduleNameCount[identifier] ?? -1) + 1;\n    if (moduleNameCount[identifier]) {\n      identifier = `${identifier}_${moduleNameCount[identifier]}`;\n    }\n    try {\n      moduleNames[filePath.replace(/^\\//, '')] = identifier;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  return moduleNames;\n}\n\nconst parseModule = async (filePath: string) => {\n  const source = readFileSync(filePath, 'utf8');\n  const loader: 'jsx' | 'ts' | 'tsx' = filePath.endsWith('.tsx')\n    ? 'tsx'\n    : filePath.endsWith('.ts')\n      ? 'ts'\n      : 'jsx';\n  const transformed = await transformWithEsbuild(source, filePath, {\n    loader,\n    jsx: 'preserve',\n  });\n  return parseAstAsync(transformed.code, { jsx: true });\n};\n\nconst getImportedName = (specifier: ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nexport const fsRouterTypegenPlugin = (opts: { srcDir: string }): Plugin => {\n  return {\n    name: 'waku:vite-plugins:fs-router-typegen',\n    apply: 'serve',\n    configureServer(server) {\n      const srcDir = joinPath(server.config.root, opts.srcDir);\n      const pagesDir = joinPath(srcDir, SRC_PAGES);\n\n      const outputFile = joinPath(srcDir, 'pages.gen.ts');\n      const updateGeneratedFile = async (file: string | undefined) => {\n        // skip when the changed file is the generated file itself\n        if (file && outputFile.endsWith(file)) {\n          return;\n        }\n        // skip when the entries file exists or pages dir does not exist\n        if (!existsSync(pagesDir) || !(await detectFsRouterUsage(srcDir))) {\n          return;\n        }\n        const generation = await generateFsRouterTypes(pagesDir);\n        if (!generation) {\n          // skip failures\n          return;\n        }\n        await writeFile(outputFile, generation, 'utf-8');\n      };\n\n      server.watcher.on('change', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('add', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('unlink', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      void updateGeneratedFile(undefined);\n    },\n  };\n};\n\nexport async function detectFsRouterUsage(srcDir: string): Promise<boolean> {\n  const existingServerEntry = EXTENSIONS.map((ext) =>\n    joinPath(srcDir, SRC_SERVER_ENTRY + ext),\n  ).find((entriesFile) => existsSync(entriesFile));\n\n  // managed mode if no entry\n  if (!existingServerEntry) {\n    return true;\n  }\n\n  try {\n    const file = await parseModule(existingServerEntry);\n    const usesFsRouter = file.body.some((node) => {\n      if (node.type !== 'ImportDeclaration') {\n        return false;\n      }\n      if (\n        node.source.type !== 'Literal' ||\n        typeof node.source.value !== 'string' ||\n        !node.source.value.startsWith('waku')\n      ) {\n        return false;\n      }\n      return node.specifiers.some((specifier) => {\n        if (\n          specifier.type !== 'ImportSpecifier' ||\n          specifier.local.type !== 'Identifier'\n        ) {\n          return false;\n        }\n        return getImportedName(specifier) === 'fsRouter';\n      });\n    });\n    return usesFsRouter;\n  } catch {\n    return false;\n  }\n}\n\nexport async function generateFsRouterTypes(pagesDir: string) {\n  // Recursively collect `.tsx` files in the given directory\n  const collectFiles = async (\n    dir: string,\n    files: string[] = [],\n  ): Promise<string[]> => {\n    // TODO revisit recursive option for readdir once more stable\n    // https://nodejs.org/docs/latest-v20.x/api/fs.html#direntparentpath\n    const entries = await readdir(dir, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = joinPath(dir, entry.name);\n      if (entry.isDirectory()) {\n        await collectFiles(fullPath, files);\n      } else {\n        if (entry.name.endsWith('.tsx')) {\n          files.push(fullPath.slice(pagesDir.length));\n        }\n      }\n    }\n    return files;\n  };\n\n  const fileExportsGetConfig = async (filePath: string) => {\n    const file = await parseModule(pagesDir + filePath);\n    return file.body.some((node) => {\n      if (node.type !== 'ExportNamedDeclaration') {\n        return false;\n      }\n      if (\n        node.declaration?.type === 'VariableDeclaration' &&\n        node.declaration.declarations.some(\n          (decl) =>\n            decl.id.type === 'Identifier' && decl.id.name === 'getConfig',\n        )\n      ) {\n        return true;\n      }\n      if (\n        node.declaration?.type === 'FunctionDeclaration' &&\n        node.declaration.id?.name === 'getConfig'\n      ) {\n        return true;\n      }\n      return node.specifiers.some(\n        (specifier) =>\n          specifier.type === 'ExportSpecifier' &&\n          getExportedName(specifier) === 'getConfig',\n      );\n    });\n  };\n\n  const generateFile = async (filePaths: string[]): Promise<string | null> => {\n    const fileInfo: { path: string; src: string; hasGetConfig: boolean }[] = [];\n    const moduleNames = getImportModuleNames(filePaths);\n\n    for (const filePath of filePaths) {\n      // where to import the component from\n      const src = filePath.replace(/^\\//, '');\n      let hasGetConfig = false;\n      try {\n        hasGetConfig = await fileExportsGetConfig(filePath);\n      } catch {\n        return null;\n      }\n\n      if (\n        filePath.endsWith('/_layout.tsx') ||\n        isIgnoredPath(filePath.split('/'))\n      ) {\n        continue;\n      } else if (filePath.endsWith('/index.tsx')) {\n        const path = filePath.slice(0, -'/index.tsx'.length);\n        fileInfo.push({\n          path: getGrouplessPath(path) || '/',\n          src,\n          hasGetConfig,\n        });\n      } else {\n        fileInfo.push({\n          path: getGrouplessPath(filePath.replace('.tsx', '')),\n          src,\n          hasGetConfig,\n        });\n      }\n    }\n\n    const hasAnyGetConfig = fileInfo.some((file) => file.hasGetConfig);\n    const lines: string[] = [\n      '// deno-fmt-ignore-file',\n      '// biome-ignore format: generated types do not need formatting',\n      '// prettier-ignore',\n      hasAnyGetConfig\n        ? \"import type { PathsForPages, GetConfigResponse } from 'waku/router';\"\n        : \"import type { PathsForPages } from 'waku/router';\",\n    ];\n\n    if (hasAnyGetConfig) {\n      lines.push('');\n      for (const file of fileInfo) {\n        if (!file.hasGetConfig) {\n          continue;\n        }\n        const moduleName = moduleNames[file.src];\n        lines.push(\n          `// prettier-ignore`,\n          `import type { getConfig as ${moduleName}_getConfig } from './${SRC_PAGES}/${file.src.replace('.tsx', '')}';`,\n        );\n      }\n    }\n\n    lines.push('', '// prettier-ignore', 'type Page =');\n    for (const file of fileInfo) {\n      const moduleName = moduleNames[file.src];\n      if (file.hasGetConfig) {\n        lines.push(\n          `| ({ path: '${file.path}' } & GetConfigResponse<typeof ${moduleName}_getConfig>)`,\n        );\n      } else {\n        lines.push(`| { path: '${file.path}'; render: 'static' }`);\n      }\n    }\n    lines[lines.length - 1] += ';';\n\n    lines.push(\n      '',\n      '// prettier-ignore',\n      \"declare module 'waku/router' {\",\n      '  interface RouteConfig {',\n      '    paths: PathsForPages<Page>;',\n      '  }',\n      '  interface CreatePagesConfig {',\n      '    pages: Page;',\n      '  }',\n      '}',\n      '',\n    );\n\n    const result = lines.join('\\n');\n\n    return result;\n  };\n\n  const files = await collectFiles(pagesDir);\n  if (!files.length) {\n    return;\n  }\n  const generation = await generateFile(files);\n  return generation;\n}\n"],"names":["existsSync","readFileSync","readdir","writeFile","parseAstAsync","transformWithEsbuild","EXTENSIONS","SRC_PAGES","SRC_SERVER_ENTRY","getGrouplessPath","isIgnoredPath","joinPath","toIdentifier","input","identifier","includes","split","slice","join","replace","test","map","part","undefined","toUpperCase","getImportModuleNames","filePaths","moduleNameCount","moduleNames","filePath","e","console","log","parseModule","source","loader","endsWith","transformed","jsx","code","getImportedName","specifier","imported","type","name","String","value","getExportedName","exported","fsRouterTypegenPlugin","opts","apply","configureServer","server","srcDir","config","root","pagesDir","outputFile","updateGeneratedFile","file","detectFsRouterUsage","generation","generateFsRouterTypes","watcher","on","existingServerEntry","ext","find","entriesFile","usesFsRouter","body","some","node","startsWith","specifiers","local","collectFiles","dir","files","entries","withFileTypes","entry","fullPath","isDirectory","push","length","fileExportsGetConfig","declaration","declarations","decl","id","generateFile","fileInfo","src","hasGetConfig","path","hasAnyGetConfig","lines","moduleName","result"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/vite-rsc/ssr.d.ts b/dist/lib/vite-rsc/ssr.d.ts
index 1feb3c525bfa35336ea973044cdc410557a98c5e..f4c658f134371254fbfbdeb79a6b164ead838ae8 100644
--- a/dist/lib/vite-rsc/ssr.d.ts
+++ b/dist/lib/vite-rsc/ssr.d.ts
@@ -1,8 +1,9 @@
 import type { ReactFormState } from 'react-dom/client';
-type RenderHtmlStream = (rscStream: ReadableStream<Uint8Array>, rscHtmlStream: ReadableStream<Uint8Array>, options?: {
-    rscPath?: string | undefined;
-    formState?: ReactFormState | undefined;
-    nonce?: string | undefined;
+type RenderHtmlStream = (rscStream: ReadableStream<Uint8Array>, rscHtmlStream: ReadableStream<Uint8Array>, options: {
+    rscPath: string | undefined;
+    formState: ReactFormState | undefined;
+    nonce: string | undefined;
+    extraScriptContent: string | undefined;
 }) => Promise<{
     stream: ReadableStream;
     status: number | undefined;
diff --git a/dist/lib/vite-rsc/ssr.js b/dist/lib/vite-rsc/ssr.js
index 5d472c0912ceb98ffd6426c418ee0f6b62ae8f11..27124a16cd00f95b532a66204aab6f999f0ffda6 100644
--- a/dist/lib/vite-rsc/ssr.js
+++ b/dist/lib/vite-rsc/ssr.js
@@ -35,19 +35,19 @@ export const renderHtmlStream = async (rscStream, rscHtmlStream, options)=>{
     try {
         htmlStream = await renderToReadableStream(/*#__PURE__*/ _jsx(SsrRoot, {}), {
             bootstrapScriptContent: getBootstrapPreamble({
-                rscPath: options?.rscPath || '',
+                rscPath: options.rscPath || '',
                 hydrate: true
-            }) + bootstrapScriptContent,
+            }) + bootstrapScriptContent + (options.extraScriptContent || ''),
             onError: (e)=>{
                 if (e && typeof e === 'object' && 'digest' in e && typeof e.digest === 'string') {
                     return e.digest;
                 }
                 console.error('[SSR Error]', captureOwnerStack?.() || '', '\n', e);
             },
-            ...options?.nonce ? {
+            ...options.nonce ? {
                 nonce: options.nonce
             } : {},
-            ...options?.formState ? {
+            ...options.formState ? {
                 formState: options.formState
             } : {}
         });
@@ -64,17 +64,17 @@ export const renderHtmlStream = async (rscStream, rscHtmlStream, options)=>{
         });
         htmlStream = await renderToReadableStream(ssrErrorRoot, {
             bootstrapScriptContent: getBootstrapPreamble({
-                rscPath: options?.rscPath || '',
+                rscPath: options.rscPath || '',
                 hydrate: false
-            }) + bootstrapScriptContent,
-            ...options?.nonce ? {
+            }) + bootstrapScriptContent + (options.extraScriptContent || ''),
+            ...options.nonce ? {
                 nonce: options.nonce
             } : {}
         });
     }
     let responseStream = htmlStream;
-    responseStream = responseStream.pipeThrough(injectRSCPayload(batchReadableStream(stream2), options?.nonce ? {
-        nonce: options?.nonce
+    responseStream = responseStream.pipeThrough(injectRSCPayload(batchReadableStream(stream2), options.nonce ? {
+        nonce: options.nonce
     } : {}));
     return {
         stream: responseStream,
diff --git a/dist/lib/vite-rsc/ssr.js.map b/dist/lib/vite-rsc/ssr.js.map
index e5cef7b6291b830f303db33b65f8596f68a2ac1d..bf552e7ef30788e2fc65cc4d3b12e589f3d77be1 100644
--- a/dist/lib/vite-rsc/ssr.js.map
+++ b/dist/lib/vite-rsc/ssr.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/vite-rsc/ssr.tsx"],"sourcesContent":["import { type ReactNode, captureOwnerStack, use } from 'react';\nimport { createFromReadableStream } from '@vitejs/plugin-rsc/ssr';\nimport type { ReactFormState } from 'react-dom/client';\nimport { renderToReadableStream } from 'react-dom/server.edge';\nimport { injectRSCPayload } from 'rsc-html-stream/server';\nimport fallbackHtml from 'virtual:vite-rsc-waku/fallback-html';\nimport { INTERNAL_ServerRoot } from '../../minimal/client.js';\nimport { getErrorInfo } from '../utils/custom-errors.js';\nimport { getBootstrapPreamble } from '../utils/ssr.js';\nimport { batchReadableStream } from '../utils/stream.js';\n\ntype RenderHtmlStream = (\n  rscStream: ReadableStream<Uint8Array>,\n  rscHtmlStream: ReadableStream<Uint8Array>,\n  options?: {\n    rscPath?: string | undefined;\n    formState?: ReactFormState | undefined;\n    nonce?: string | undefined;\n  },\n) => Promise<{ stream: ReadableStream; status: number | undefined }>;\n\ntype RscElementsPayload = Record<string, unknown>;\ntype RscHtmlPayload = ReactNode;\n\n// This code runs on `ssr` environment,\n// i.e. it runs on server but without `react-server` condition.\n// These utilities are used by `rsc` environment through\n// `import.meta.viteRsc.loadModule` API.\n\nexport const renderHtmlStream: RenderHtmlStream = async (\n  rscStream,\n  rscHtmlStream,\n  options,\n) => {\n  const [stream1, stream2] = rscStream.tee();\n\n  let elementsPromise: Promise<RscElementsPayload>;\n  let htmlPromise: Promise<RscHtmlPayload>;\n\n  // deserialize RSC stream back to React VDOM\n  function SsrRoot() {\n    // RSC stream needs to be deserialized inside SSR component.\n    // This is for ReactDomServer preinit/preload (e.g. client reference modulepreload, css)\n    // https://github.com/facebook/react/pull/31799#discussion_r1886166075\n    elementsPromise ??= createFromReadableStream<RscElementsPayload>(stream1);\n    htmlPromise ??= createFromReadableStream<RscHtmlPayload>(rscHtmlStream);\n    return (\n      <INTERNAL_ServerRoot elementsPromise={elementsPromise}>\n        {use(htmlPromise)}\n      </INTERNAL_ServerRoot>\n    );\n  }\n\n  // render html\n  const bootstrapScriptContent = await loadBootstrapScriptContent();\n  let htmlStream: ReadableStream;\n  let status: number | undefined;\n  try {\n    htmlStream = await renderToReadableStream(<SsrRoot />, {\n      bootstrapScriptContent:\n        getBootstrapPreamble({\n          rscPath: options?.rscPath || '',\n          hydrate: true,\n        }) + bootstrapScriptContent,\n      onError: (e: unknown) => {\n        if (\n          e &&\n          typeof e === 'object' &&\n          'digest' in e &&\n          typeof e.digest === 'string'\n        ) {\n          return e.digest;\n        }\n        console.error('[SSR Error]', captureOwnerStack?.() || '', '\\n', e);\n      },\n      ...(options?.nonce ? { nonce: options.nonce } : {}),\n      ...(options?.formState ? { formState: options.formState } : {}),\n    });\n  } catch (e) {\n    const info = getErrorInfo(e);\n    if (info?.location) {\n      // keep unstable_redirect error as http redirection\n      throw e;\n    }\n    status = info?.status || 500;\n    // SSR empty html and go full CSR on browser, which can revive RSC errors.\n    const ssrErrorRoot = (\n      <html>\n        <body></body>\n      </html>\n    );\n    htmlStream = await renderToReadableStream(ssrErrorRoot, {\n      bootstrapScriptContent:\n        getBootstrapPreamble({\n          rscPath: options?.rscPath || '',\n          hydrate: false,\n        }) + bootstrapScriptContent,\n      ...(options?.nonce ? { nonce: options.nonce } : {}),\n    });\n  }\n  let responseStream: ReadableStream<Uint8Array> = htmlStream;\n  responseStream = responseStream.pipeThrough(\n    injectRSCPayload(\n      batchReadableStream(stream2),\n      options?.nonce ? { nonce: options?.nonce } : {},\n    ),\n  );\n\n  return { stream: responseStream, status };\n};\n\nexport async function renderHtmlFallback() {\n  const bootstrapScriptContent = await loadBootstrapScriptContent();\n  const html = fallbackHtml.replace(\n    '</body>',\n    () => `<script>${bootstrapScriptContent}</script></body>`,\n  );\n  return html;\n}\n\nfunction loadBootstrapScriptContent(): Promise<string> {\n  return import.meta.viteRsc.loadBootstrapScriptContent('index');\n}\n"],"names":["captureOwnerStack","use","createFromReadableStream","renderToReadableStream","injectRSCPayload","fallbackHtml","INTERNAL_ServerRoot","getErrorInfo","getBootstrapPreamble","batchReadableStream","renderHtmlStream","rscStream","rscHtmlStream","options","stream1","stream2","tee","elementsPromise","htmlPromise","SsrRoot","bootstrapScriptContent","loadBootstrapScriptContent","htmlStream","status","rscPath","hydrate","onError","e","digest","console","error","nonce","formState","info","location","ssrErrorRoot","html","body","responseStream","pipeThrough","stream","renderHtmlFallback","replace","viteRsc"],"mappings":";AAAA,SAAyBA,iBAAiB,EAAEC,GAAG,QAAQ,QAAQ;AAC/D,SAASC,wBAAwB,QAAQ,yBAAyB;AAElE,SAASC,sBAAsB,QAAQ,wBAAwB;AAC/D,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,OAAOC,kBAAkB,sCAAsC;AAC/D,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,YAAY,QAAQ,4BAA4B;AACzD,SAASC,oBAAoB,QAAQ,kBAAkB;AACvD,SAASC,mBAAmB,QAAQ,qBAAqB;AAezD,uCAAuC;AACvC,+DAA+D;AAC/D,wDAAwD;AACxD,wCAAwC;AAExC,OAAO,MAAMC,mBAAqC,OAChDC,WACAC,eACAC;IAEA,MAAM,CAACC,SAASC,QAAQ,GAAGJ,UAAUK,GAAG;IAExC,IAAIC;IACJ,IAAIC;IAEJ,4CAA4C;IAC5C,SAASC;QACP,4DAA4D;QAC5D,wFAAwF;QACxF,sEAAsE;QACtEF,oBAAoBf,yBAA6CY;QACjEI,gBAAgBhB,yBAAyCU;QACzD,qBACE,KAACN;YAAoBW,iBAAiBA;sBACnChB,IAAIiB;;IAGX;IAEA,cAAc;IACd,MAAME,yBAAyB,MAAMC;IACrC,IAAIC;IACJ,IAAIC;IACJ,IAAI;QACFD,aAAa,MAAMnB,qCAAuB,KAACgB,cAAY;YACrDC,wBACEZ,qBAAqB;gBACnBgB,SAASX,SAASW,WAAW;gBAC7BC,SAAS;YACX,KAAKL;YACPM,SAAS,CAACC;gBACR,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEC,MAAM,KAAK,UACpB;oBACA,OAAOD,EAAEC,MAAM;gBACjB;gBACAC,QAAQC,KAAK,CAAC,eAAe9B,yBAAyB,IAAI,MAAM2B;YAClE;YACA,GAAId,SAASkB,QAAQ;gBAAEA,OAAOlB,QAAQkB,KAAK;YAAC,IAAI,CAAC,CAAC;YAClD,GAAIlB,SAASmB,YAAY;gBAAEA,WAAWnB,QAAQmB,SAAS;YAAC,IAAI,CAAC,CAAC;QAChE;IACF,EAAE,OAAOL,GAAG;QACV,MAAMM,OAAO1B,aAAaoB;QAC1B,IAAIM,MAAMC,UAAU;YAClB,mDAAmD;YACnD,MAAMP;QACR;QACAJ,SAASU,MAAMV,UAAU;QACzB,0EAA0E;QAC1E,MAAMY,6BACJ,KAACC;sBACC,cAAA,KAACC;;QAGLf,aAAa,MAAMnB,uBAAuBgC,cAAc;YACtDf,wBACEZ,qBAAqB;gBACnBgB,SAASX,SAASW,WAAW;gBAC7BC,SAAS;YACX,KAAKL;YACP,GAAIP,SAASkB,QAAQ;gBAAEA,OAAOlB,QAAQkB,KAAK;YAAC,IAAI,CAAC,CAAC;QACpD;IACF;IACA,IAAIO,iBAA6ChB;IACjDgB,iBAAiBA,eAAeC,WAAW,CACzCnC,iBACEK,oBAAoBM,UACpBF,SAASkB,QAAQ;QAAEA,OAAOlB,SAASkB;IAAM,IAAI,CAAC;IAIlD,OAAO;QAAES,QAAQF;QAAgBf;IAAO;AAC1C,EAAE;AAEF,OAAO,eAAekB;IACpB,MAAMrB,yBAAyB,MAAMC;IACrC,MAAMe,OAAO/B,aAAaqC,OAAO,CAC/B,WACA,IAAM,CAAC,QAAQ,EAAEtB,uBAAuB,gBAAgB,CAAC;IAE3D,OAAOgB;AACT;AAEA,SAASf;IACP,OAAO,YAAYsB,OAAO,CAACtB,0BAA0B,CAAC;AACxD"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/vite-rsc/ssr.tsx"],"sourcesContent":["import { type ReactNode, captureOwnerStack, use } from 'react';\nimport { createFromReadableStream } from '@vitejs/plugin-rsc/ssr';\nimport type { ReactFormState } from 'react-dom/client';\nimport { renderToReadableStream } from 'react-dom/server.edge';\nimport { injectRSCPayload } from 'rsc-html-stream/server';\nimport fallbackHtml from 'virtual:vite-rsc-waku/fallback-html';\nimport { INTERNAL_ServerRoot } from '../../minimal/client.js';\nimport { getErrorInfo } from '../utils/custom-errors.js';\nimport { getBootstrapPreamble } from '../utils/ssr.js';\nimport { batchReadableStream } from '../utils/stream.js';\n\ntype RenderHtmlStream = (\n  rscStream: ReadableStream<Uint8Array>,\n  rscHtmlStream: ReadableStream<Uint8Array>,\n  options: {\n    rscPath: string | undefined;\n    formState: ReactFormState | undefined;\n    nonce: string | undefined;\n    extraScriptContent: string | undefined;\n  },\n) => Promise<{ stream: ReadableStream; status: number | undefined }>;\n\ntype RscElementsPayload = Record<string, unknown>;\ntype RscHtmlPayload = ReactNode;\n\n// This code runs on `ssr` environment,\n// i.e. it runs on server but without `react-server` condition.\n// These utilities are used by `rsc` environment through\n// `import.meta.viteRsc.loadModule` API.\n\nexport const renderHtmlStream: RenderHtmlStream = async (\n  rscStream,\n  rscHtmlStream,\n  options,\n) => {\n  const [stream1, stream2] = rscStream.tee();\n\n  let elementsPromise: Promise<RscElementsPayload>;\n  let htmlPromise: Promise<RscHtmlPayload>;\n\n  // deserialize RSC stream back to React VDOM\n  function SsrRoot() {\n    // RSC stream needs to be deserialized inside SSR component.\n    // This is for ReactDomServer preinit/preload (e.g. client reference modulepreload, css)\n    // https://github.com/facebook/react/pull/31799#discussion_r1886166075\n    elementsPromise ??= createFromReadableStream<RscElementsPayload>(stream1);\n    htmlPromise ??= createFromReadableStream<RscHtmlPayload>(rscHtmlStream);\n    return (\n      <INTERNAL_ServerRoot elementsPromise={elementsPromise}>\n        {use(htmlPromise)}\n      </INTERNAL_ServerRoot>\n    );\n  }\n\n  // render html\n  const bootstrapScriptContent = await loadBootstrapScriptContent();\n  let htmlStream: ReadableStream;\n  let status: number | undefined;\n  try {\n    htmlStream = await renderToReadableStream(<SsrRoot />, {\n      bootstrapScriptContent:\n        getBootstrapPreamble({\n          rscPath: options.rscPath || '',\n          hydrate: true,\n        }) +\n        bootstrapScriptContent +\n        (options.extraScriptContent || ''),\n      onError: (e: unknown) => {\n        if (\n          e &&\n          typeof e === 'object' &&\n          'digest' in e &&\n          typeof e.digest === 'string'\n        ) {\n          return e.digest;\n        }\n        console.error('[SSR Error]', captureOwnerStack?.() || '', '\\n', e);\n      },\n      ...(options.nonce ? { nonce: options.nonce } : {}),\n      ...(options.formState ? { formState: options.formState } : {}),\n    });\n  } catch (e) {\n    const info = getErrorInfo(e);\n    if (info?.location) {\n      // keep unstable_redirect error as http redirection\n      throw e;\n    }\n    status = info?.status || 500;\n    // SSR empty html and go full CSR on browser, which can revive RSC errors.\n    const ssrErrorRoot = (\n      <html>\n        <body></body>\n      </html>\n    );\n    htmlStream = await renderToReadableStream(ssrErrorRoot, {\n      bootstrapScriptContent:\n        getBootstrapPreamble({\n          rscPath: options.rscPath || '',\n          hydrate: false,\n        }) +\n        bootstrapScriptContent +\n        (options.extraScriptContent || ''),\n      ...(options.nonce ? { nonce: options.nonce } : {}),\n    });\n  }\n  let responseStream: ReadableStream<Uint8Array> = htmlStream;\n  responseStream = responseStream.pipeThrough(\n    injectRSCPayload(\n      batchReadableStream(stream2),\n      options.nonce ? { nonce: options.nonce } : {},\n    ),\n  );\n\n  return { stream: responseStream, status };\n};\n\nexport async function renderHtmlFallback() {\n  const bootstrapScriptContent = await loadBootstrapScriptContent();\n  const html = fallbackHtml.replace(\n    '</body>',\n    () => `<script>${bootstrapScriptContent}</script></body>`,\n  );\n  return html;\n}\n\nfunction loadBootstrapScriptContent(): Promise<string> {\n  return import.meta.viteRsc.loadBootstrapScriptContent('index');\n}\n"],"names":["captureOwnerStack","use","createFromReadableStream","renderToReadableStream","injectRSCPayload","fallbackHtml","INTERNAL_ServerRoot","getErrorInfo","getBootstrapPreamble","batchReadableStream","renderHtmlStream","rscStream","rscHtmlStream","options","stream1","stream2","tee","elementsPromise","htmlPromise","SsrRoot","bootstrapScriptContent","loadBootstrapScriptContent","htmlStream","status","rscPath","hydrate","extraScriptContent","onError","e","digest","console","error","nonce","formState","info","location","ssrErrorRoot","html","body","responseStream","pipeThrough","stream","renderHtmlFallback","replace","viteRsc"],"mappings":";AAAA,SAAyBA,iBAAiB,EAAEC,GAAG,QAAQ,QAAQ;AAC/D,SAASC,wBAAwB,QAAQ,yBAAyB;AAElE,SAASC,sBAAsB,QAAQ,wBAAwB;AAC/D,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,OAAOC,kBAAkB,sCAAsC;AAC/D,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,YAAY,QAAQ,4BAA4B;AACzD,SAASC,oBAAoB,QAAQ,kBAAkB;AACvD,SAASC,mBAAmB,QAAQ,qBAAqB;AAgBzD,uCAAuC;AACvC,+DAA+D;AAC/D,wDAAwD;AACxD,wCAAwC;AAExC,OAAO,MAAMC,mBAAqC,OAChDC,WACAC,eACAC;IAEA,MAAM,CAACC,SAASC,QAAQ,GAAGJ,UAAUK,GAAG;IAExC,IAAIC;IACJ,IAAIC;IAEJ,4CAA4C;IAC5C,SAASC;QACP,4DAA4D;QAC5D,wFAAwF;QACxF,sEAAsE;QACtEF,oBAAoBf,yBAA6CY;QACjEI,gBAAgBhB,yBAAyCU;QACzD,qBACE,KAACN;YAAoBW,iBAAiBA;sBACnChB,IAAIiB;;IAGX;IAEA,cAAc;IACd,MAAME,yBAAyB,MAAMC;IACrC,IAAIC;IACJ,IAAIC;IACJ,IAAI;QACFD,aAAa,MAAMnB,qCAAuB,KAACgB,cAAY;YACrDC,wBACEZ,qBAAqB;gBACnBgB,SAASX,QAAQW,OAAO,IAAI;gBAC5BC,SAAS;YACX,KACAL,yBACCP,CAAAA,QAAQa,kBAAkB,IAAI,EAAC;YAClCC,SAAS,CAACC;gBACR,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEC,MAAM,KAAK,UACpB;oBACA,OAAOD,EAAEC,MAAM;gBACjB;gBACAC,QAAQC,KAAK,CAAC,eAAe/B,yBAAyB,IAAI,MAAM4B;YAClE;YACA,GAAIf,QAAQmB,KAAK,GAAG;gBAAEA,OAAOnB,QAAQmB,KAAK;YAAC,IAAI,CAAC,CAAC;YACjD,GAAInB,QAAQoB,SAAS,GAAG;gBAAEA,WAAWpB,QAAQoB,SAAS;YAAC,IAAI,CAAC,CAAC;QAC/D;IACF,EAAE,OAAOL,GAAG;QACV,MAAMM,OAAO3B,aAAaqB;QAC1B,IAAIM,MAAMC,UAAU;YAClB,mDAAmD;YACnD,MAAMP;QACR;QACAL,SAASW,MAAMX,UAAU;QACzB,0EAA0E;QAC1E,MAAMa,6BACJ,KAACC;sBACC,cAAA,KAACC;;QAGLhB,aAAa,MAAMnB,uBAAuBiC,cAAc;YACtDhB,wBACEZ,qBAAqB;gBACnBgB,SAASX,QAAQW,OAAO,IAAI;gBAC5BC,SAAS;YACX,KACAL,yBACCP,CAAAA,QAAQa,kBAAkB,IAAI,EAAC;YAClC,GAAIb,QAAQmB,KAAK,GAAG;gBAAEA,OAAOnB,QAAQmB,KAAK;YAAC,IAAI,CAAC,CAAC;QACnD;IACF;IACA,IAAIO,iBAA6CjB;IACjDiB,iBAAiBA,eAAeC,WAAW,CACzCpC,iBACEK,oBAAoBM,UACpBF,QAAQmB,KAAK,GAAG;QAAEA,OAAOnB,QAAQmB,KAAK;IAAC,IAAI,CAAC;IAIhD,OAAO;QAAES,QAAQF;QAAgBhB;IAAO;AAC1C,EAAE;AAEF,OAAO,eAAemB;IACpB,MAAMtB,yBAAyB,MAAMC;IACrC,MAAMgB,OAAOhC,aAAasC,OAAO,CAC/B,WACA,IAAM,CAAC,QAAQ,EAAEvB,uBAAuB,gBAAgB,CAAC;IAE3D,OAAOiB;AACT;AAEA,SAAShB;IACP,OAAO,YAAYuB,OAAO,CAACvB,0BAA0B,CAAC;AACxD"}
\ No newline at end of file
diff --git a/dist/router/client.d.ts b/dist/router/client.d.ts
index fd9ecebea068fb1677f121d6aa29de3ba7bc4d8e..79ef8efb81a8e4492ed40e26b7ff4c2d014353a7 100644
--- a/dist/router/client.d.ts
+++ b/dist/router/client.d.ts
@@ -11,36 +11,19 @@ type InferredPaths = RouteConfig extends {
 type ChangeRoute = (route: RouteProps, options: {
     shouldScroll: boolean;
     skipRefetch?: boolean;
+    signal?: AbortSignal;
     unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
 }) => Promise<void>;
-type ChangeRouteEvent = 'start' | 'complete';
-type ChangeRouteCallback = (route: RouteProps) => void;
 type PrefetchRoute = (route: RouteProps) => void;
 type SliceId = string;
+export declare function usePending(): boolean;
 export declare function useRouter(): {
-    push: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
-    replace: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
+    push: (to: InferredPaths) => void;
+    replace: (to: InferredPaths) => void;
     reload: () => Promise<void>;
     back: () => void;
     forward: () => void;
     prefetch: (to: string) => void;
-    unstable_events: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
     path: string;
     query: string;
     hash: string;
@@ -48,23 +31,14 @@ export declare function useRouter(): {
 export type LinkProps = {
     to: InferredPaths;
     children: ReactNode;
-    /**
-     * indicates if the link should scroll or not on navigation
-     * - `true`: always scroll
-     * - `false`: never scroll
-     * - `undefined`: scroll on path change (not on searchParams change)
-     */
-    scroll?: boolean;
-    unstable_pending?: ReactNode;
-    unstable_notPending?: ReactNode;
     unstable_prefetchOnEnter?: boolean;
     unstable_prefetchOnView?: boolean;
-    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
     ref?: Ref<HTMLAnchorElement> | undefined;
 } & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
-export declare function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }: LinkProps): ReactElement;
+export declare function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }: LinkProps): ReactElement;
 export declare class ErrorBoundary extends Component<{
     children: ReactNode;
+    error?: unknown;
 }, {
     error?: unknown;
 }> {
@@ -115,12 +89,9 @@ export declare const unstable_RouterContext: import("react").Context<{
     route: RouteProps;
     changeRoute: ChangeRoute;
     prefetchRoute: PrefetchRoute;
-    routeChangeEvents: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
     fetchingSlices: Set<SliceId>;
 } | null>;
 export type Unstable_ChangeRoute = ChangeRoute;
-export type Unstable_ChangeRouteEvent = ChangeRouteEvent;
-export type Unstable_ChangeRouteCallback = ChangeRouteCallback;
 export type Unstable_PrefetchRoute = PrefetchRoute;
 export type Unstable_SliceId = SliceId;
 export type Unstable_InferredPaths = InferredPaths;
diff --git a/dist/router/client.js b/dist/router/client.js
index 6b7fe060dc5f70e2b67b47e04a07566595714931..482b0503cea3381ab05164a9997bd2170c2605ec 100644
--- a/dist/router/client.js
+++ b/dist/router/client.js
@@ -1,6 +1,7 @@
 'use client';
 import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
-import { Component, createContext, startTransition, use, useCallback, useContext, useEffect, useRef, useState, useTransition } from 'react';
+import { Component, createContext, use, useCallback, useEffect, useRef, useState, useTransition } from 'react';
+import { preloadModule } from 'react-dom';
 import { getErrorInfo } from '../lib/utils/custom-errors.js';
 import { addBase, removeBase } from '../lib/utils/path.js';
 import { Root, Slot, prefetchRsc, useElementsPromise_UNSTABLE as useElementsPromise, useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal, useRefetch } from '../minimal/client.js';
@@ -43,7 +44,6 @@ const parseRouteFromLocation = ()=>{
     }
     return parseRoute(new URL(window.location.href));
 };
-const isAltClick = (event)=>event.button !== 0 || !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
 let savedRscParams;
 const createRscParams = (query)=>{
     if (savedRscParams && savedRscParams[0] === query) {
@@ -58,60 +58,49 @@ const createRscParams = (query)=>{
     ];
     return rscParams;
 };
+const PendingContext = /*#__PURE__*/ createContext(false);
+// Not sure whether this is necessary
+// We have navigation.transition
+// but it's not reactive
+export function usePending() {
+    return use(PendingContext);
+}
 // This is an internal thing, not a public API
 const RouterContext = /*#__PURE__*/ createContext(null);
 export function useRouter() {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { route, changeRoute, prefetchRoute } = router;
-    const push = useCallback(async (to, options)=>{
+    const { route, prefetchRoute } = router;
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const push = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
-        });
-        if (window.location.pathname === currentPath) {
-            window.history.pushState({
-                ...window.history.state,
-                waku_new_path: newPath
-            }, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const replace = useCallback(async (to, options)=>{
+        window.navigation.navigate(to);
+    }, []);
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const replace = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
+        window.navigation.navigate(to, {
+            history: 'replace'
         });
-        if (window.location.pathname === currentPath) {
-            window.history.replaceState(window.history.state, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const reload = useCallback(async ()=>{
-        const url = new URL(window.location.href);
-        await changeRoute(parseRoute(url), {
-            shouldScroll: true
-        });
-    }, [
-        changeRoute
-    ]);
-    const back = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.back();
     }, []);
-    const forward = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.forward();
+    /**
+   * @deprecated use window.navigation.reload() instead
+   */ const reload = useCallback(async ()=>{
+        window.navigation.reload();
+    }, []);
+    /**
+   * @deprecated use window.navigation.back() instead
+   */ const back = useCallback(()=>{
+        window.navigation.back();
+    }, []);
+    /**
+   * @deprecated use window.navigation.forward() instead
+   */ const forward = useCallback(()=>{
+        window.navigation.forward();
     }, []);
     const prefetch = useCallback((to)=>{
         const url = new URL(to, window.location.href);
@@ -126,8 +115,7 @@ export function useRouter() {
         reload,
         back,
         forward,
-        prefetch,
-        unstable_events: router.routeChangeEvents
+        prefetch
     };
 }
 function useSharedRef(ref) {
@@ -163,17 +151,12 @@ function useSharedRef(ref) {
         handleRef
     ];
 }
-export function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }) {
+export function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }) {
     to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-    const router = useContext(RouterContext);
-    const changeRoute = router ? router.changeRoute : ()=>{
-        throw new Error('Missing Router');
-    };
+    const router = use(RouterContext);
     const prefetchRoute = router ? router.prefetchRoute : ()=>{
         throw new Error('Missing Router');
     };
-    const [isPending, startTransition] = useTransition();
-    const startTransitionFn = unstable_startTransition || (unstable_pending || unstable_notPending) && startTransition || ((fn)=>fn());
     const [ref, setRef] = useSharedRef(refProp);
     useEffect(()=>{
         if (unstable_prefetchOnView && ref.current) {
@@ -201,40 +184,6 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
         to,
         ref
     ]);
-    const internalOnClick = ()=>{
-        const url = new URL(to, window.location.href);
-        if (url.href !== window.location.href) {
-            const route = parseRoute(url);
-            prefetchRoute(route);
-            startTransitionFn(async ()=>{
-                const currentPath = window.location.pathname;
-                const newPath = url.pathname !== currentPath;
-                try {
-                    await changeRoute(route, {
-                        shouldScroll: scroll ?? newPath,
-                        unstable_startTransition: startTransitionFn
-                    });
-                } finally{
-                    if (window.location.pathname === currentPath) {
-                        // Update history if it wasn't already updated
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: newPath
-                        }, '', url);
-                    }
-                }
-            });
-        }
-    };
-    const onClick = (event)=>{
-        if (props.onClick) {
-            props.onClick(event);
-        }
-        if (!event.defaultPrevented && !isAltClick(event)) {
-            event.preventDefault();
-            internalOnClick();
-        }
-    };
     const onMouseEnter = unstable_prefetchOnEnter ? (event)=>{
         const url = new URL(to, window.location.href);
         if (url.href !== window.location.href) {
@@ -246,27 +195,10 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
     const ele = /*#__PURE__*/ _jsx("a", {
         ...props,
         href: to,
-        onClick: onClick,
         onMouseEnter: onMouseEnter,
         ref: setRef,
         children: children
     });
-    if (isPending && unstable_pending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_pending
-            ]
-        });
-    }
-    if (!isPending && unstable_notPending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_notPending
-            ]
-        });
-    }
     return ele;
 }
 const notAvailableInServer = (name)=>()=>{
@@ -316,17 +248,18 @@ export class ErrorBoundary extends Component {
         };
     }
     render() {
-        if ('error' in this.state) {
-            if (this.state.error instanceof Error) {
-                return renderError(this.state.error.message);
+        if ('error' in this.state || 'error' in this.props) {
+            const error = this.state.error ?? this.props.error;
+            if (error instanceof Error) {
+                return renderError(error.message);
             }
-            return renderError(String(this.state.error));
+            return renderError(String(error));
         }
         return this.props.children;
     }
 }
 const NotFound = ({ has404, reset })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -335,13 +268,9 @@ const NotFound = ({ has404, reset })=>{
         if (has404) {
             const url = new URL('/404', window.location.href);
             changeRoute(parseRoute(url), {
-                shouldScroll: true
+                shouldScroll: false
             }).then(()=>{
-                // HACK: This timeout is required for canary-ci to work
-                // FIXME: As we understand it, we should have a proper solution.
-                setTimeout(()=>{
-                    reset();
-                }, 1);
+                reset();
             }).catch((err)=>{
                 console.log('Error while navigating to 404:', err);
             });
@@ -356,11 +285,10 @@ const NotFound = ({ has404, reset })=>{
     });
 };
 const Redirect = ({ error, to, reset, handledErrorSet })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { changeRoute } = router;
     useEffect(()=>{
         // ensure single re-fetch per server redirection error on StrictMode
         // https://github.com/wakujs/waku/pull/1512
@@ -369,62 +297,45 @@ const Redirect = ({ error, to, reset, handledErrorSet })=>{
         }
         handledErrorSet.add(error);
         const url = new URL(to, window.location.href);
-        // FIXME this condition seems too naive
-        if (url.hostname !== window.location.hostname) {
-            window.location.replace(to);
-            return;
-        }
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        changeRoute(parseRoute(url), {
-            shouldScroll: newPath
-        }).then(()=>{
-            // FIXME: As we understand it, we should have a proper solution.
-            setTimeout(()=>{
-                reset();
-            }, 1);
-        }).catch((err)=>{
-            console.log('Error while navigating to redirect:', err);
-        }).finally(()=>{
-            if (window.location.pathname === currentPath) {
-                window.history.replaceState({
-                    ...window.history.state,
-                    waku_new_path: newPath
-                }, '', url);
-            }
+        window.navigation.navigate(url, {
+            history: 'push'
+        }).committed?.then(()=>{
+            // FIXME
+            // ssr-redirect > access sync page with client navigation
+            return new Promise((resolve)=>setTimeout(resolve, 200));
+        })?.then(()=>{
+            console.trace('Redirected to', to);
+            reset();
         });
     }, [
         error,
-        to,
+        handledErrorSet,
         reset,
-        changeRoute,
-        handledErrorSet
+        to
     ]);
     return null;
 };
 class CustomErrorHandler extends Component {
-    handledErrorSet = new WeakSet();
+    #handledErrorSet = new WeakSet();
     constructor(props){
         super(props);
         this.state = {
             error: null
         };
-        this.reset = this.reset.bind(this);
     }
     static getDerivedStateFromError(error) {
         return {
             error
         };
     }
-    reset() {
+    reset = ()=>{
         this.setState({
             error: null
         });
-    }
+    };
     render() {
-        const { error } = this.state;
-        if (error !== null) {
-            const info = getErrorInfo(error);
+        if (this.state.error !== null) {
+            const info = getErrorInfo(this.state.error);
             if (info?.status === 404) {
                 return /*#__PURE__*/ _jsx(NotFound, {
                     has404: this.props.has404,
@@ -433,24 +344,24 @@ class CustomErrorHandler extends Component {
             }
             if (info?.location) {
                 return /*#__PURE__*/ _jsx(Redirect, {
-                    error: error,
+                    error: this.state.error,
                     to: info.location,
                     reset: this.reset,
-                    handledErrorSet: this.handledErrorSet
+                    handledErrorSet: this.#handledErrorSet
                 });
             }
-            throw error;
+            return /*#__PURE__*/ _jsx(ErrorBoundary, {
+                error: this.state.error,
+                children: null
+            });
         }
         return this.props.children;
     }
 }
-const ThrowError = ({ error })=>{
-    throw error;
-};
 const getRouteSlotId = (path)=>'route:' + decodeURI(path);
 const getSliceSlotId = (id)=>'slice:' + id;
 export function Slice({ id, children, ...props }) {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -530,7 +441,7 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             if (routeData) {
                 const [path, _query] = routeData;
                 if (isStatic) {
-                    staticPathSetRef.current.add(path);
+                    staticPathSetRef.current.add(encodeURI(path));
                 }
             }
             cachedIdSetRef.current = new Set(Object.keys(rest));
@@ -539,11 +450,14 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
         elementsPromise
     ]);
     const enhanceFetchRscInternal = useEnhanceFetchRscInternal();
-    const locationListenersRef = useRef(new Set());
-    const locationListeners = locationListenersRef.current;
+    // It doesn't have to be a ref
+    // But passing it to multiple function calls is too complicated
+    const signalRef = useRef(null);
     useEffect(()=>{
-        const enhanceFetch = (fetchFn)=>(input, init = {})=>{
-                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));
+        const enhanceFetch = (fetchFn)=>(input, init = {
+                signal: signalRef.current
+            })=>{
+                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current).map((i)=>encodeURI(i)));
                 const headers = init.headers ||= {};
                 if (Array.isArray(headers)) {
                     headers.push([
@@ -562,16 +476,18 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
                     const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } = elements;
                     if (routeData) {
                         const [path, query] = routeData;
-                        if (requestedRouteRef.current.path !== path || !isStatic && requestedRouteRef.current.query !== query) {
-                            locationListeners.forEach((listener)=>listener(path, query));
+                        if (requestedRouteRef.current.path !== encodeURI(path) || !isStatic && requestedRouteRef.current.query !== query) {
+                            // redirected
+                            window.navigation.navigate(path, {
+                                history: 'push'
+                            });
                         }
                     }
                 }).catch(()=>{});
                 return elementsPromise;
             });
     }, [
-        enhanceFetchRscInternal,
-        locationListeners
+        enhanceFetchRscInternal
     ]);
     const refetch = useRefetch();
     const [route, setRoute] = useState(()=>({
@@ -582,38 +498,6 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             ...initialRoute,
             hash: ''
         }));
-    const routeChangeListenersRef = useRef(null);
-    if (routeChangeListenersRef.current === null) {
-        const listeners = {
-            start: new Set(),
-            complete: new Set()
-        };
-        const executeListeners = (eventType, eventRoute)=>{
-            const eventListenersSet = listeners[eventType];
-            if (!eventListenersSet.size) {
-                return;
-            }
-            for (const listener of eventListenersSet){
-                listener(eventRoute);
-            }
-        };
-        const events = (()=>{
-            const on = (event, handler)=>{
-                listeners[event].add(handler);
-            };
-            const off = (event, handler)=>{
-                listeners[event].delete(handler);
-            };
-            return {
-                on,
-                off
-            };
-        })();
-        routeChangeListenersRef.current = [
-            events,
-            executeListeners
-        ];
-    }
     // Update the route post-load to include the current hash.
     useEffect(()=>{
         setRoute((prev)=>{
@@ -625,16 +509,11 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
     }, [
         initialRoute
     ]);
-    const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;
-    const [err, setErr] = useState(null);
-    // FIXME this "refetching" hack doesn't seem ideal.
-    const refetching = useRef(null);
+    const customErrorHandlerRef = useRef(null);
     const changeRoute = useCallback(async (route, options)=>{
         requestedRouteRef.current = route;
-        executeListeners('start', route);
         const startTransitionFn = options.unstable_startTransition || ((fn)=>fn());
-        refetching.current = [];
-        setErr(null);
+        customErrorHandlerRef.current?.reset();
         const { skipRefetch } = options || {};
         if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {
             const rscPath = encodeRoutePath(route.path);
@@ -642,22 +521,28 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             try {
                 await refetch(rscPath, rscParams);
             } catch (e) {
-                refetching.current = null;
-                setErr(e);
-                throw e;
+                if (e instanceof Error && e.name === 'AbortError') {
+                // Noop
+                } else {
+                    // Workaround: after setErr, CustomErrorHandler is not rerendered!
+                    // Why is that?
+                    // Luckily this is not on happy path.
+                    // Update: this causes more bugs.
+                    // flushSync(() => {
+                    // });
+                    throw e;
+                }
             }
         }
         startTransitionFn(()=>{
-            if (options.shouldScroll) {
-                handleScroll();
+            if (!options.signal?.aborted) {
+                if (options.shouldScroll) {
+                    handleScroll();
+                }
+                setRoute(route);
             }
-            setRoute(route);
-            refetching.current[0]?.();
-            refetching.current = null;
-            executeListeners('complete', route);
         });
     }, [
-        executeListeners,
         refetch
     ]);
     const prefetchRoute = useCallback((route)=>{
@@ -667,62 +552,132 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
         const rscPath = encodeRoutePath(route.path);
         const rscParams = createRscParams(route.query);
         prefetchRsc(rscPath, rscParams);
-        globalThis.__WAKU_ROUTER_PREFETCH__?.(route.path);
+        globalThis.__WAKU_ROUTER_PREFETCH__?.(route.path, (id)=>{
+            preloadModule(id, {
+                as: 'script'
+            });
+        });
     }, []);
+    const [isPending, startTransition] = useTransition();
+    // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js
     useEffect(()=>{
-        const callback = ()=>{
-            const route = parseRoute(new URL(window.location.href));
-            changeRoute(route, {
-                shouldScroll: true
-            }).catch((err)=>{
-                console.log('Error while navigating back:', err);
+        const callback = (event)=>{
+            if (!event.canIntercept || // If this is a download,
+            // let the browser perform the download.
+            event.downloadRequest || // If this is a form submission,
+            // let that go to the server.
+            event.formData) {
+                return;
+            } else if (// If this is just a hashChange,
+            // just let the browser handle scrolling to the content.
+            event.hashChange) {
+                setRoute((prev)=>({
+                        ...prev,
+                        hash: new URL(event.destination.url).hash
+                    }));
+                return;
+            }
+            const url = new URL(event.destination.url);
+            const route = parseRoute(url);
+            // console.log(event);
+            const navigationType = event.navigationType;
+            const previousIndex = window.navigation.currentEntry.index;
+            event.intercept({
+                async precommitHandler () {
+                    if (signalRef.current) {
+                        // It happens when click very fast.
+                        console.warn('Potential race condition due to rapid navigation.');
+                    }
+                    signalRef.current = event.signal;
+                    startTransition(async ()=>{
+                        // addTransitionType('navigation-' + navigationType);
+                        if (navigationType === 'traverse') {
+                            // For traverse types it's useful to distinguish going back or forward.
+                            const nextIndex = event.destination.index;
+                            if (nextIndex > previousIndex) {
+                            // addTransitionType('navigation-forward');
+                            } else if (nextIndex < previousIndex) {
+                            // addTransitionType('navigation-back');
+                            }
+                            const err = customErrorHandlerRef.current?.state.error;
+                            if (err) {
+                                const info = getErrorInfo(err);
+                                if (info?.status === 404) {
+                                    // if 404 sans 404.tsx, manually go back
+                                    // should make CustomErrorHandler state
+                                    // Haha, upstream is broken too
+                                    customErrorHandlerRef.current?.reset();
+                                }
+                            }
+                            await changeRoute(route, {
+                                shouldScroll: false,
+                                unstable_startTransition: startTransition,
+                                signal: event.signal
+                            }).catch((err)=>{
+                                console.log('Error while navigating back:', err);
+                            });
+                        } else {
+                            prefetchRoute(route);
+                            try {
+                                await changeRoute(route, {
+                                    shouldScroll: false,
+                                    unstable_startTransition: startTransition,
+                                    signal: event.signal
+                                });
+                            } catch (err) {
+                                // Handle 404, etc here
+                                customErrorHandlerRef.current?.setState({
+                                    error: err
+                                });
+                                if (has404 && err) {
+                                    const info = getErrorInfo(err);
+                                    if (info?.status === 404) {
+                                        await changeRoute({
+                                            path: '/404',
+                                            query: '',
+                                            hash: ''
+                                        }, {
+                                            signal: event.signal,
+                                            shouldScroll: false
+                                        });
+                                    }
+                                }
+                            }
+                        }
+                        if (signalRef.current === event.signal) {
+                            signalRef.current = null;
+                        }
+                    });
+                    await flushAsync();
+                    return;
+                },
+                scroll: 'after-transition'
             });
         };
-        window.addEventListener('popstate', callback);
+        window.navigation.addEventListener('navigate', callback);
         return ()=>{
-            window.removeEventListener('popstate', callback);
+            window.navigation.removeEventListener('navigate', callback);
         };
     }, [
-        changeRoute
+        changeRoute,
+        prefetchRoute,
+        has404
     ]);
+    // run after new route DOM mounted
     useEffect(()=>{
-        const callback = (path, query)=>{
-            const fn = ()=>{
-                const url = new URL(window.location.href);
-                url.pathname = path;
-                url.search = query;
-                url.hash = '';
-                changeRoute(parseRoute(url), {
-                    skipRefetch: true,
-                    shouldScroll: false
-                }).catch((err)=>{
-                    console.log('Error while handling location listeners:', err);
-                }).finally(()=>{
-                    if (path !== '/404') {
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: url.pathname !== window.location.pathname
-                        }, '', url);
-                    }
-                });
-            };
-            if (refetching.current) {
-                refetching.current.push(fn);
-            } else {
-                startTransition(fn);
-            }
-        };
-        locationListeners.add(callback);
-        return ()=>{
-            locationListeners.delete(callback);
-        };
+        resolver.current?.(undefined);
+        resolver.current = null;
     }, [
-        changeRoute,
-        locationListeners
+        route
     ]);
-    const routeElement = err !== null ? /*#__PURE__*/ _jsx(ThrowError, {
-        error: err
-    }) : /*#__PURE__*/ _jsx(Slot, {
+    const resolver = useRef(null);
+    async function flushAsync() {
+        const deferred = Promise.withResolvers();
+        resolver.current = deferred.resolve;
+        await deferred.promise;
+        return;
+    }
+    const routeElement = /*#__PURE__*/ _jsx(Slot, {
         id: getRouteSlotId(route.path)
     });
     const rootElement = /*#__PURE__*/ _jsxs(Slot, {
@@ -733,6 +688,7 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
                 content: httpStatus
             }),
             /*#__PURE__*/ _jsx(CustomErrorHandler, {
+                ref: customErrorHandlerRef,
                 has404: has404,
                 children: routeElement
             })
@@ -743,10 +699,12 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             route,
             changeRoute,
             prefetchRoute,
-            routeChangeEvents,
             fetchingSlices: useRef(new Set()).current
         },
-        children: rootElement
+        children: /*#__PURE__*/ _jsx(PendingContext, {
+            value: isPending,
+            children: rootElement
+        })
     });
 };
 export function Router({ initialRoute = parseRouteFromLocation() }) {
@@ -762,10 +720,6 @@ export function Router({ initialRoute = parseRouteFromLocation() }) {
         })
     });
 }
-const MOCK_ROUTE_CHANGE_LISTENER = {
-    on: ()=>notAvailableInServer('routeChange:on'),
-    off: ()=>notAvailableInServer('routeChange:off')
-};
 /**
  * ServerRouter for SSR
  * This is not a public API.
@@ -789,7 +743,6 @@ const MOCK_ROUTE_CHANGE_LISTENER = {
                 route,
                 changeRoute: notAvailableInServer('changeRoute'),
                 prefetchRoute: notAvailableInServer('prefetchRoute'),
-                routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,
                 fetchingSlices: new Set()
             },
             children: rootElement
diff --git a/dist/router/client.js.map b/dist/router/client.js.map
index e4724ee72a25d16fd67223847056ed3fa7191a62..e4a6e02979370e121d7ff629cbb991bd8eb6b3f9 100644
--- a/dist/router/client.js.map
+++ b/dist/router/client.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  startTransition,\n  use,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nconst isAltClick = (event: MouseEvent<HTMLAnchorElement>) =>\n  event.button !== 0 ||\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype ChangeRouteEvent = 'start' | 'complete';\n\ntype ChangeRouteCallback = (route: RouteProps) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  routeChangeEvents: Record<\n    'on' | 'off',\n    (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n  >;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n      }\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.replaceState(window.history.state, '', url);\n      }\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(async () => {\n    const url = new URL(window.location.href);\n    await changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n    unstable_events: router.routeChangeEvents,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: TransitionFunction) => fn());\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const internalOnClick = () => {\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(async () => {\n        const currentPath = window.location.pathname;\n        const newPath = url.pathname !== currentPath;\n        try {\n          await changeRoute(route, {\n            shouldScroll: scroll ?? newPath,\n            unstable_startTransition: startTransitionFn,\n          });\n        } finally {\n          if (window.location.pathname === currentPath) {\n            // Update history if it wasn't already updated\n            window.history.pushState(\n              {\n                ...window.history.state,\n                waku_new_path: newPath,\n              },\n              '',\n              url,\n            );\n          }\n        }\n      });\n    }\n  };\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    if (props.onClick) {\n      props.onClick(event);\n    }\n    if (!event.defaultPrevented && !isAltClick(event)) {\n      event.preventDefault();\n      internalOnClick();\n    }\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a\n      {...props}\n      href={to}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={setRef}\n    >\n      {children}\n    </a>\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_pending}\n      </>\n    );\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_notPending}\n      </>\n    );\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true })\n        .then(() => {\n          // HACK: This timeout is required for canary-ci to work\n          // FIXME: As we understand it, we should have a proper solution.\n          setTimeout(() => {\n            reset();\n          }, 1);\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const currentPath = window.location.pathname;\n    const newPath = url.pathname !== currentPath;\n    changeRoute(parseRoute(url), { shouldScroll: newPath })\n      .then(() => {\n        // FIXME: As we understand it, we should have a proper solution.\n        setTimeout(() => {\n          reset();\n        }, 1);\n      })\n      .catch((err) => {\n        console.log('Error while navigating to redirect:', err);\n      })\n      .finally(() => {\n        if (window.location.pathname === currentPath) {\n          window.history.replaceState(\n            {\n              ...window.history.state,\n              waku_new_path: newPath,\n            },\n            '',\n            url,\n          );\n        }\n      });\n  }, [error, to, reset, changeRoute, handledErrorSet]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  private handledErrorSet = new WeakSet();\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.handledErrorSet}\n          />\n        );\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst ThrowError = ({ error }: { error: unknown }) => {\n  throw error;\n};\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(path);\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  const locationListenersRef = useRef(\n    new Set<(path: string, query: string) => void>(),\n  );\n  const locationListeners = locationListenersRef.current;\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (input: RequestInfo | URL, init: RequestInit = {}) => {\n        const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== path ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  locationListeners.forEach((listener) =>\n                    listener(path, query),\n                  );\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal, locationListeners]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  const routeChangeListenersRef =\n    useRef<\n      [\n        Record<\n          'on' | 'off',\n          (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n        >,\n        (\n          eventType: ChangeRouteEvent,\n          eventRoute: Parameters<ChangeRouteCallback>[0],\n        ) => void,\n      ]\n    >(null);\n  if (routeChangeListenersRef.current === null) {\n    const listeners: Record<ChangeRouteEvent, Set<ChangeRouteCallback>> = {\n      start: new Set(),\n      complete: new Set(),\n    };\n    const executeListeners = (\n      eventType: ChangeRouteEvent,\n      eventRoute: Parameters<ChangeRouteCallback>[0],\n    ) => {\n      const eventListenersSet = listeners[eventType];\n      if (!eventListenersSet.size) {\n        return;\n      }\n      for (const listener of eventListenersSet) {\n        listener(eventRoute);\n      }\n    };\n    const events = (() => {\n      const on = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].add(handler);\n      };\n      const off = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].delete(handler);\n      };\n      return { on, off };\n    })();\n\n    routeChangeListenersRef.current = [events, executeListeners];\n  }\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;\n  const [err, setErr] = useState<unknown>(null);\n  // FIXME this \"refetching\" hack doesn't seem ideal.\n  const refetching = useRef<[onFinish?: () => void] | null>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      executeListeners('start', route);\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      refetching.current = [];\n      setErr(null);\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          refetching.current = null;\n          setErr(e);\n          throw e;\n        }\n      }\n      startTransitionFn(() => {\n        if (options.shouldScroll) {\n          handleScroll();\n        }\n        setRoute(route);\n        refetching.current![0]?.();\n        refetching.current = null;\n        executeListeners('complete', route);\n      });\n    },\n    [executeListeners, refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n  }, []);\n\n  useEffect(() => {\n    const callback = () => {\n      const route = parseRoute(new URL(window.location.href));\n      changeRoute(route, { shouldScroll: true }).catch((err) => {\n        console.log('Error while navigating back:', err);\n      });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const fn = () => {\n        const url = new URL(window.location.href);\n        url.pathname = path;\n        url.search = query;\n        url.hash = '';\n        changeRoute(parseRoute(url), {\n          skipRefetch: true,\n          shouldScroll: false,\n        })\n          .catch((err) => {\n            console.log('Error while handling location listeners:', err);\n          })\n          .finally(() => {\n            if (path !== '/404') {\n              window.history.pushState(\n                {\n                  ...window.history.state,\n                  waku_new_path: url.pathname !== window.location.pathname,\n                },\n                '',\n                url,\n              );\n            }\n          });\n      };\n      if (refetching.current) {\n        refetching.current.push(fn);\n      } else {\n        startTransition(fn);\n      }\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement =\n    err !== null ? (\n      <ThrowError error={err} />\n    ) : (\n      <Slot id={getRouteSlotId(route.path)} />\n    );\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler has404={has404}>{routeElement}</CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        routeChangeEvents,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      {rootElement}\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n}: {\n  initialRoute?: RouteProps;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter initialRoute={initialRoute} httpStatus={httpStatus} />\n    </Root>\n  );\n}\n\nconst MOCK_ROUTE_CHANGE_LISTENER: Record<\n  'on' | 'off',\n  (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n> = {\n  on: () => notAvailableInServer('routeChange:on'),\n  off: () => notAvailableInServer('routeChange:off'),\n};\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n\n// Highly experimental to expose internal APIs\n// Subject to change without notice\nexport type Unstable_RouteProps = RouteProps;\nexport const unstable_HAS404_ID = HAS404_ID;\nexport const unstable_IS_STATIC_ID = IS_STATIC_ID;\nexport const unstable_ROUTE_ID = ROUTE_ID;\nexport const unstable_SKIP_HEADER = SKIP_HEADER;\nexport const unstable_encodeRoutePath = encodeRoutePath;\nexport const unstable_encodeSliceId = encodeSliceId;\nexport const unstable_getRouteSlotId = getRouteSlotId;\nexport const unstable_getSliceSlotId = getSliceSlotId;\nexport const unstable_getErrorInfo = getErrorInfo;\nexport const unstable_addBase = addBase;\nexport const unstable_removeBase = removeBase;\nexport const unstable_RouterContext = RouterContext;\nexport type Unstable_ChangeRoute = ChangeRoute;\nexport type Unstable_ChangeRouteEvent = ChangeRouteEvent;\nexport type Unstable_ChangeRouteCallback = ChangeRouteCallback;\nexport type Unstable_PrefetchRoute = PrefetchRoute;\nexport type Unstable_SliceId = SliceId;\nexport type Unstable_InferredPaths = InferredPaths;\nexport const unstable_parseRoute = parseRoute;\nexport const unstable_getHttpStatusFromMeta = getHttpStatusFromMeta;\n"],"names":["Component","createContext","startTransition","use","useCallback","useContext","useEffect","useRef","useState","useTransition","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","isAltClick","event","button","metaKey","altKey","ctrlKey","shiftKey","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter","router","Error","route","changeRoute","prefetchRoute","push","to","options","currentPath","newPath","shouldScroll","scroll","history","pushState","state","waku_new_path","replace","replaceState","reload","back","forward","prefetch","unstable_events","routeChangeEvents","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","refProp","props","isPending","startTransitionFn","fn","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","internalOnClick","onClick","defaultPrevented","preventDefault","onMouseEnter","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","getDerivedStateFromError","error","render","String","NotFound","has404","reset","then","setTimeout","catch","err","console","log","Redirect","handledErrorSet","has","add","hostname","finally","CustomErrorHandler","WeakSet","bind","setState","info","status","ThrowError","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","InnerRouter","initialRoute","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","Object","keys","enhanceFetchRscInternal","locationListenersRef","locationListeners","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","Promise","resolve","listener","setRoute","routeChangeListenersRef","listeners","start","complete","executeListeners","eventType","eventRoute","eventListenersSet","size","events","on","handler","off","prev","setErr","refetching","skipRefetch","__WAKU_ROUTER_PREFETCH__","callback","addEventListener","removeEventListener","search","routeElement","rootElement","meta","value","Router","initialRscPath","initialRscParams","MOCK_ROUTE_CHANGE_LISTENER","INTERNAL_ServerRouter","httpstatus","unstable_HAS404_ID","unstable_IS_STATIC_ID","unstable_ROUTE_ID","unstable_SKIP_HEADER","unstable_encodeRoutePath","unstable_encodeSliceId","unstable_getRouteSlotId","unstable_getSliceSlotId","unstable_getErrorInfo","unstable_addBase","unstable_removeBase","unstable_RouterContext","unstable_parseRoute","unstable_getHttpStatusFromMeta"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  use,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { preloadModule } from 'react-dom';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    signal?: AbortSignal;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\nconst PendingContext = createContext<boolean>(false);\n\n// Not sure whether this is necessary\n// We have navigation.transition\n// but it's not reactive\nexport function usePending() {\n  return use(PendingContext);\n}\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, prefetchRoute } = router;\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const push = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to);\n  }, []);\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const replace = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to, { history: 'replace' });\n  }, []);\n  /**\n   * @deprecated use window.navigation.reload() instead\n   */\n  const reload = useCallback(async () => {\n    window.navigation.reload();\n  }, []);\n  /**\n   * @deprecated use window.navigation.back() instead\n   */\n  const back = useCallback(() => {\n    window.navigation.back();\n  }, []);\n  /**\n   * @deprecated use window.navigation.forward() instead\n   */\n  const forward = useCallback(() => {\n    window.navigation.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = use(RouterContext);\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a {...props} href={to} onMouseEnter={onMouseEnter} ref={setRef}>\n      {children}\n    </a>\n  );\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode; error?: unknown },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state || 'error' in this.props) {\n      const error = this.state.error ?? this.props.error;\n      if (error instanceof Error) {\n        return renderError(error.message);\n      }\n      return renderError(String(error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: false })\n        .then(() => {\n          reset();\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    window.navigation\n      .navigate(url, { history: 'push' })\n      .committed?.then(() => {\n        // FIXME\n        // ssr-redirect > access sync page with client navigation\n        return new Promise((resolve) => setTimeout(resolve, 200));\n      })\n      ?.then(() => {\n        console.trace('Redirected to', to);\n        reset();\n      });\n  }, [error, handledErrorSet, reset, to]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  #handledErrorSet = new WeakSet();\n  constructor(props: {\n    has404: boolean;\n    error: unknown;\n    children?: ReactNode;\n  }) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset = () => {\n    this.setState({ error: null });\n  };\n  render() {\n    if (this.state.error !== null) {\n      const info = getErrorInfo(this.state.error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={this.state.error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.#handledErrorSet}\n          />\n        );\n      }\n      return <ErrorBoundary error={this.state.error}>{null}</ErrorBoundary>;\n    }\n    return this.props.children;\n  }\n}\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(encodeURI(path));\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  // It doesn't have to be a ref\n  // But passing it to multiple function calls is too complicated\n  const signalRef = useRef<AbortSignal | null>(null);\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (\n        input: RequestInfo | URL,\n        init: RequestInit = { signal: signalRef.current },\n      ) => {\n        const skipStr = JSON.stringify(\n          Array.from(cachedIdSetRef.current).map((i) => encodeURI(i)),\n        );\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== encodeURI(path) ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  // redirected\n                  window.navigation.navigate(path, { history: 'push' });\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const customErrorHandlerRef = useRef<CustomErrorHandler>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      customErrorHandlerRef.current?.reset();\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          if (e instanceof Error && e.name === 'AbortError') {\n            // Noop\n          } else {\n            // Workaround: after setErr, CustomErrorHandler is not rerendered!\n            // Why is that?\n            // Luckily this is not on happy path.\n            // Update: this causes more bugs.\n            // flushSync(() => {\n            // });\n            throw e;\n          }\n        }\n      }\n      startTransitionFn(() => {\n        if (!options.signal?.aborted) {\n          if (options.shouldScroll) {\n            handleScroll();\n          }\n          setRoute(route);\n        }\n      });\n    },\n    [refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path, (id: string) => {\n      preloadModule(id, { as: 'script' });\n    });\n  }, []);\n\n  const [isPending, startTransition] = useTransition();\n\n  // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js\n  useEffect(() => {\n    const callback = ((event: NavigateEvent) => {\n      if (\n        !event.canIntercept ||\n        // If this is a download,\n        // let the browser perform the download.\n        event.downloadRequest ||\n        // If this is a form submission,\n        // let that go to the server.\n        event.formData\n      ) {\n        return;\n      } else if (\n        // If this is just a hashChange,\n        // just let the browser handle scrolling to the content.\n        event.hashChange\n      ) {\n        setRoute((prev) => ({\n          ...prev,\n          hash: new URL(event.destination.url).hash,\n        }));\n        return;\n      }\n      const url = new URL(event.destination.url);\n      const route = parseRoute(url);\n      // console.log(event);\n      const navigationType = event.navigationType;\n      const previousIndex = window.navigation.currentEntry!.index;\n      event.intercept({\n        async precommitHandler() {\n          if (signalRef.current) {\n            // It happens when click very fast.\n            console.warn('Potential race condition due to rapid navigation.');\n          }\n          signalRef.current = event.signal;\n          startTransition(async () => {\n            // addTransitionType('navigation-' + navigationType);\n            if (navigationType === 'traverse') {\n              // For traverse types it's useful to distinguish going back or forward.\n              const nextIndex = event.destination.index;\n              if (nextIndex > previousIndex) {\n                // addTransitionType('navigation-forward');\n              } else if (nextIndex < previousIndex) {\n                // addTransitionType('navigation-back');\n              }\n              const err = customErrorHandlerRef.current?.state.error;\n              if (err) {\n                const info = getErrorInfo(err);\n                if (info?.status === 404) {\n                  // if 404 sans 404.tsx, manually go back\n                  // should make CustomErrorHandler state\n                  // Haha, upstream is broken too\n\n                  customErrorHandlerRef.current?.reset();\n                }\n              }\n              await changeRoute(route, {\n                shouldScroll: false,\n                unstable_startTransition: startTransition,\n                signal: event.signal,\n              }).catch((err) => {\n                console.log('Error while navigating back:', err);\n              });\n            } else {\n              prefetchRoute(route);\n              try {\n                await changeRoute(route, {\n                  shouldScroll: false,\n                  unstable_startTransition: startTransition,\n                  signal: event.signal,\n                });\n              } catch (err) {\n                // Handle 404, etc here\n                customErrorHandlerRef.current?.setState({ error: err });\n                if (has404 && err) {\n                  const info = getErrorInfo(err);\n                  if (info?.status === 404) {\n                    await changeRoute(\n                      { path: '/404', query: '', hash: '' },\n                      {\n                        signal: event.signal,\n                        shouldScroll: false,\n                      },\n                    );\n                  }\n                }\n              }\n            }\n            if (signalRef.current === event.signal) {\n              signalRef.current = null;\n            }\n          });\n          await flushAsync();\n          return;\n        },\n        scroll: 'after-transition',\n      });\n    }) as EventListener;\n    window.navigation.addEventListener('navigate', callback);\n    return () => {\n      window.navigation.removeEventListener('navigate', callback);\n    };\n  }, [changeRoute, prefetchRoute, has404]);\n\n  // run after new route DOM mounted\n  useEffect(() => {\n    resolver.current?.(undefined);\n    resolver.current = null;\n  }, [route]);\n\n  const resolver = useRef<((value: undefined) => void) | null>(null);\n\n  async function flushAsync() {\n    const deferred = Promise.withResolvers();\n    resolver.current = deferred.resolve;\n    await deferred.promise;\n    return;\n  }\n\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler ref={customErrorHandlerRef} has404={has404}>\n        {routeElement}\n      </CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      <PendingContext value={isPending}>{rootElement}</PendingContext>\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n}: {\n  initialRoute?: RouteProps;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter\n        initialRoute={initialRoute}\n        httpStatus={httpStatus}\n      />\n    </Root>\n  );\n}\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n\n// Highly experimental to expose internal APIs\n// Subject to change without notice\nexport type Unstable_RouteProps = RouteProps;\nexport const unstable_HAS404_ID = HAS404_ID;\nexport const unstable_IS_STATIC_ID = IS_STATIC_ID;\nexport const unstable_ROUTE_ID = ROUTE_ID;\nexport const unstable_SKIP_HEADER = SKIP_HEADER;\nexport const unstable_encodeRoutePath = encodeRoutePath;\nexport const unstable_encodeSliceId = encodeSliceId;\nexport const unstable_getRouteSlotId = getRouteSlotId;\nexport const unstable_getSliceSlotId = getSliceSlotId;\nexport const unstable_getErrorInfo = getErrorInfo;\nexport const unstable_addBase = addBase;\nexport const unstable_removeBase = removeBase;\nexport const unstable_RouterContext = RouterContext;\nexport type Unstable_ChangeRoute = ChangeRoute;\nexport type Unstable_PrefetchRoute = PrefetchRoute;\nexport type Unstable_SliceId = SliceId;\nexport type Unstable_InferredPaths = InferredPaths;\nexport const unstable_parseRoute = parseRoute;\nexport const unstable_getHttpStatusFromMeta = getHttpStatusFromMeta;\n"],"names":["Component","createContext","use","useCallback","useEffect","useRef","useState","useTransition","preloadModule","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","savedRscParams","createRscParams","rscParams","URLSearchParams","PendingContext","usePending","RouterContext","useRouter","router","Error","route","prefetchRoute","push","to","navigation","navigate","replace","history","reload","back","forward","prefetch","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_prefetchOnEnter","unstable_prefetchOnView","refProp","props","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","onMouseEnter","event","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","state","getDerivedStateFromError","error","render","String","NotFound","has404","reset","changeRoute","shouldScroll","then","catch","err","console","log","Redirect","handledErrorSet","has","add","committed","Promise","resolve","setTimeout","trace","CustomErrorHandler","WeakSet","setState","info","status","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","finally","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","waku_new_path","InnerRouter","initialRoute","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","encodeURI","Object","keys","enhanceFetchRscInternal","signalRef","enhanceFetch","fetchFn","input","init","signal","skipStr","JSON","stringify","Array","from","map","i","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","setRoute","prev","customErrorHandlerRef","options","startTransitionFn","unstable_startTransition","fn","skipRefetch","aborted","__WAKU_ROUTER_PREFETCH__","as","isPending","startTransition","callback","canIntercept","downloadRequest","formData","hashChange","destination","navigationType","previousIndex","currentEntry","intercept","precommitHandler","warn","nextIndex","flushAsync","scroll","addEventListener","removeEventListener","resolver","deferred","withResolvers","promise","routeElement","rootElement","meta","value","Router","initialRscPath","initialRscParams","INTERNAL_ServerRouter","httpstatus","unstable_HAS404_ID","unstable_IS_STATIC_ID","unstable_ROUTE_ID","unstable_SKIP_HEADER","unstable_encodeRoutePath","unstable_encodeSliceId","unstable_getRouteSlotId","unstable_getSliceSlotId","unstable_getErrorInfo","unstable_addBase","unstable_removeBase","unstable_RouterContext","unstable_parseRoute","unstable_getHttpStatusFromMeta"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/router/define-router.js b/dist/router/define-router.js
index 77a1cb4c262b60c3b6444de6686ff12671380351..0efb45bce7ca92fe6c2e36f2e1dbab608ba70a4a 100644
--- a/dist/router/define-router.js
+++ b/dist/router/define-router.js
@@ -1,6 +1,6 @@
 import { jsx as _jsx } from "react/jsx-runtime";
 import { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';
-import { getPathMapping } from '../lib/utils/path.js';
+import { getPathMapping, path2regexp } from '../lib/utils/path.js';
 import { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';
 import { createTaskRunner } from '../lib/utils/task-runner.js';
 import { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';
@@ -57,6 +57,14 @@ export function unstable_getRscParams() {
         return undefined;
     }
 }
+const getNonce = ()=>{
+    try {
+        const context = getContext();
+        return context.nonce;
+    } catch  {
+        return undefined;
+    }
+};
 const RERENDER_SYMBOL = Symbol('RERENDER');
 const setRerender = (rerender)=>{
     try {
@@ -103,6 +111,25 @@ const assertNonReservedSlotId = (slotId)=>{
         throw new Error('Element ID cannot be "root", "route:*" or "slice:*"');
     }
 };
+const getRouterPrefetchCode = (path2moduleIds)=>{
+    const moduleIdSet = new Set();
+    Object.values(path2moduleIds).forEach((ids)=>ids.forEach((id)=>moduleIdSet.add(id)));
+    const ids = Array.from(moduleIdSet);
+    const path2idxs = {};
+    Object.entries(path2moduleIds).forEach(([path, ids])=>{
+        path2idxs[path] = ids.map((id)=>ids.indexOf(id));
+    });
+    return `
+globalThis.__WAKU_ROUTER_PREFETCH__ = (path, callback) => {
+  const ids = ${JSON.stringify(ids)};
+  const path2idxs = ${JSON.stringify(path2idxs)};
+  const key = Object.keys(path2idxs).find((key) => new RegExp(key).test(path));
+  for (const idx of path2idxs[key] || []) {
+    callback(ids[idx]);
+  }
+};
+`;
+};
 export function unstable_defineRouter(fns) {
     let cachedMyConfig;
     const getMyConfig = async ()=>{
@@ -230,6 +257,7 @@ export function unstable_defineRouter(fns) {
     };
     const cachedElementsForRequest = new Map();
     let cachedElementsForRequestInitialized = false;
+    let cachedPath2moduleIds;
     const handleRequest = async (input, { renderRsc, parseRsc, renderHtml, loadBuildMetadata })=>{
         const getCachedElement = (id)=>cachedElementsForRequest.get(id);
         const setCachedElement = (id, element)=>{
@@ -252,6 +280,12 @@ export function unstable_defineRouter(fns) {
                 });
             }
         }
+        const getPath2moduleIds = async ()=>{
+            if (!cachedPath2moduleIds) {
+                cachedPath2moduleIds = JSON.parse(await loadBuildMetadata('defineRouter:path2moduleIds') || '{}');
+            }
+            return cachedPath2moduleIds;
+        };
         const pathConfigItem = await getPathConfigItem(input.pathname);
         if (pathConfigItem?.type === 'api') {
             const url = new URL(input.req.url);
@@ -337,6 +371,7 @@ export function unstable_defineRouter(fns) {
                 if (!entries) {
                     return null;
                 }
+                const path2moduleIds = await getPath2moduleIds();
                 const html = /*#__PURE__*/ _jsx(INTERNAL_ServerRouter, {
                     route: {
                         path: pathname,
@@ -345,11 +380,16 @@ export function unstable_defineRouter(fns) {
                     },
                     httpstatus: httpstatus
                 });
-                const actionResult = input.type === 'action' ? await input.fn() : undefined;
+                const formState = input.type === 'action' ? await input.fn() : undefined;
+                const nonce = getNonce();
                 return renderHtml(await renderRsc(entries), html, {
                     rscPath,
-                    actionResult,
-                    status: httpstatus
+                    formState,
+                    status: httpstatus,
+                    ...nonce ? {
+                        nonce
+                    } : {},
+                    unstable_extraScriptContent: getRouterPrefetchCode(path2moduleIds)
                 });
             };
             const query = url.searchParams.toString();
@@ -415,6 +455,8 @@ export function unstable_defineRouter(fns) {
                 });
             });
         }
+        const path2moduleIds = {};
+        const htmlRenderTasks = new Set();
         // static route
         for (const item of myConfig.configs){
             if (item.type !== 'route') {
@@ -439,24 +481,34 @@ export function unstable_defineRouter(fns) {
                         const cached = getCachedElement(id);
                         entries[id] = cached ? await cached : entries[id];
                     }
-                    const stream = await renderRsc(entries);
+                    const moduleIds = new Set();
+                    const stream = await renderRsc(entries, {
+                        unstable_clientModuleCallback: (ids)=>ids.forEach((id)=>moduleIds.add(id))
+                    });
                     const [stream1, stream2] = stream.tee();
                     await generateFile(rscPath2pathname(rscPath), stream1);
-                    const html = /*#__PURE__*/ _jsx(INTERNAL_ServerRouter, {
-                        route: {
-                            path: pathname,
-                            query: '',
-                            hash: ''
-                        },
-                        httpstatus: is404(item.path) ? 404 : 200
-                    });
-                    const res = await renderHtml(stream2, html, {
-                        rscPath
+                    path2moduleIds[path2regexp(item.pathPattern || item.path)] = Array.from(moduleIds);
+                    htmlRenderTasks.add(async ()=>{
+                        const html = /*#__PURE__*/ _jsx(INTERNAL_ServerRouter, {
+                            route: {
+                                path: pathname,
+                                query: '',
+                                hash: ''
+                            },
+                            httpstatus: is404(item.path) ? 404 : 200
+                        });
+                        const res = await renderHtml(stream2, html, {
+                            rscPath,
+                            unstable_extraScriptContent: getRouterPrefetchCode(path2moduleIds)
+                        });
+                        await generateFile(htmlPath2pathname(pathname), res.body || '');
                     });
-                    await generateFile(htmlPath2pathname(pathname), res.body || '');
                 });
             });
         }
+        // HACK hopefully there is a better way than this
+        await waitForTasks();
+        htmlRenderTasks.forEach(runTask);
         // default html
         for (const item of myConfig.configs){
             if (item.type !== 'route') {
@@ -498,6 +550,7 @@ export function unstable_defineRouter(fns) {
         await waitForTasks();
         // TODO should we save serialized cached elements separately?
         await saveBuildMetadata('defineRouter:cachedElements', JSON.stringify(Object.fromEntries(serializedCachedElements)));
+        await saveBuildMetadata('defineRouter:path2moduleIds', JSON.stringify(path2moduleIds));
     };
     return Object.assign(defineHandlers({
         handleRequest,
diff --git a/dist/router/define-router.js.map b/dist/router/define-router.js.map
index 9f5830c2af75dd328b3a0d849f3be8307626f693..19ac7db9702a67ac12200c90b432cc57cca30c35 100644
--- a/dist/router/define-router.js.map
+++ b/dist/router/define-router.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/router/define-router.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { getPathMapping } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';\nimport { createTaskRunner } from '../lib/utils/task-runner.js';\nimport { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';\nimport { unstable_getContext as getContext } from '../server.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  decodeRoutePath,\n  decodeSliceId,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (rscParams instanceof URLSearchParams) {\n    return { query: rscParams.get('query') || '' };\n  }\n  if (\n    typeof (rscParams as { query?: undefined } | undefined)?.query === 'string'\n  ) {\n    return { query: (rscParams as { query: string }).query };\n  }\n  return { query: '' };\n};\n\nconst RSC_PATH_SYMBOL = Symbol('RSC_PATH');\nconst RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');\n\nconst setRscPath = (rscPath: string) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PATH_SYMBOL, unknown>)[\n      RSC_PATH_SYMBOL\n    ] = rscPath;\n  } catch {\n    // ignore\n  }\n};\n\nconst setRscParams = (rscParams: unknown) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ] = rscParams;\n  } catch {\n    // ignore\n  }\n};\n\nexport function unstable_getRscPath(): string | undefined {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PATH_SYMBOL, string>)[\n      RSC_PATH_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nexport function unstable_getRscParams(): unknown {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst is404 = (pathSpec: PathSpec) =>\n  pathSpec.length === 1 &&\n  pathSpec[0]!.type === 'literal' &&\n  pathSpec[0]!.name === '404';\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nconst htmlPath2pathname = (htmlPath: string): string =>\n  htmlPath === '/404' ? '404.html' : htmlPath + '/index.html';\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 303 | 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROOT_SLOT_ID = 'root';\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\nconst SLICE_SLOT_ID_PREFIX = 'slice:';\n\nconst assertNonReservedSlotId = (slotId: SlotId) => {\n  if (\n    slotId === ROOT_SLOT_ID ||\n    slotId.startsWith(ROUTE_SLOT_ID_PREFIX) ||\n    slotId.startsWith(SLICE_SLOT_ID_PREFIX)\n  ) {\n    throw new Error('Element ID cannot be \"root\", \"route:*\" or \"slice:*\"');\n  }\n};\n\ntype RendererOption = { pathname: string; query: string | undefined };\n\ntype RouteConfig = {\n  type: 'route';\n  path: PathSpec;\n  isStatic: boolean;\n  pathPattern?: PathSpec;\n  rootElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  routeElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  elements: Record<\n    SlotId,\n    {\n      isStatic: boolean;\n      renderer: (option: RendererOption) => ReactNode;\n    }\n  >;\n  noSsr?: boolean;\n  slices?: string[];\n};\n\ntype ApiConfig = {\n  type: 'api';\n  path: PathSpec;\n  isStatic: boolean;\n  handler: (req: Request) => Promise<Response>;\n};\n\ntype SliceConfig = {\n  type: 'slice';\n  id: string;\n  isStatic: boolean;\n  renderer: () => Promise<ReactNode>;\n};\n\nexport function unstable_defineRouter(fns: {\n  getConfigs: () => Promise<Iterable<RouteConfig | ApiConfig | SliceConfig>>;\n}) {\n  // This is an internal type for caching\n  type MyConfig = {\n    configs: (RouteConfig | ApiConfig | SliceConfig)[];\n    has404: boolean;\n  };\n\n  let cachedMyConfig: MyConfig | undefined;\n  const getMyConfig = async (): Promise<MyConfig> => {\n    if (!cachedMyConfig) {\n      const configs = Array.from(await fns.getConfigs());\n      let has404 = false;\n      configs.forEach((item) => {\n        if (item.type === 'route') {\n          Object.keys(item.elements).forEach(assertNonReservedSlotId);\n          if (!has404 && is404(item.path)) {\n            has404 = true;\n          }\n        }\n      });\n      cachedMyConfig = { configs, has404 };\n    }\n    return cachedMyConfig;\n  };\n\n  const getPathConfigItem = async (pathname: string) => {\n    const myConfig = await getMyConfig();\n    const found = myConfig.configs.find(\n      (item): item is typeof item & { type: 'route' | 'api' } =>\n        (item.type === 'route' || item.type === 'api') &&\n        !!getPathMapping(item.path, pathname),\n    );\n    return found;\n  };\n\n  const getSliceElement = async (\n    sliceConfig: {\n      id: string;\n      isStatic: boolean;\n      renderer: () => Promise<ReactNode>;\n    },\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ): Promise<ReactNode> => {\n    const id = SLICE_SLOT_ID_PREFIX + sliceConfig.id;\n    const cached = getCachedElement(id);\n    if (cached) {\n      return cached;\n    }\n    let element = await sliceConfig.renderer();\n    if (sliceConfig.isStatic) {\n      element = await setCachedElement(id, element);\n    }\n    return element;\n  };\n\n  const getEntriesForRoute = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ) => {\n    setRscPath(rscPath);\n    setRscParams(rscParams);\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (pathConfigItem?.type !== 'route') {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const decodedPathname = decodeURI(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    const option: RendererOption = {\n      pathname: decodedPathname,\n      query: pathConfigItem.isStatic ? undefined : query,\n    };\n    const myConfig = await getMyConfig();\n    const slices = pathConfigItem.slices || [];\n    const sliceConfigMap = new Map<\n      string,\n      { id: string; isStatic: boolean; renderer: () => Promise<ReactNode> }\n    >();\n    slices.forEach((sliceId) => {\n      const sliceConfig = myConfig.configs.find(\n        (item): item is typeof item & { type: 'slice' } =>\n          item.type === 'slice' && item.id === sliceId,\n      );\n      if (sliceConfig) {\n        sliceConfigMap.set(sliceId, sliceConfig);\n      }\n    });\n    const entries: Record<SlotId, unknown> = {};\n    await Promise.all([\n      (async () => {\n        if (!pathConfigItem.rootElement.isStatic) {\n          entries[ROOT_SLOT_ID] = pathConfigItem.rootElement.renderer(option);\n        } else if (!skipIdSet.has(ROOT_SLOT_ID)) {\n          const cached = getCachedElement(ROOT_SLOT_ID);\n          entries[ROOT_SLOT_ID] = cached\n            ? await cached\n            : await setCachedElement(\n                ROOT_SLOT_ID,\n                pathConfigItem.rootElement.renderer(option),\n              );\n        }\n      })(),\n      (async () => {\n        if (!pathConfigItem.routeElement.isStatic) {\n          entries[routeId] = pathConfigItem.routeElement.renderer(option);\n        } else if (!skipIdSet.has(routeId)) {\n          const cached = getCachedElement(routeId);\n          entries[routeId] = cached\n            ? await cached\n            : await setCachedElement(\n                routeId,\n                pathConfigItem.routeElement.renderer(option),\n              );\n        }\n      })(),\n      ...Object.entries(pathConfigItem.elements).map(\n        async ([id, { isStatic }]) => {\n          const renderer = pathConfigItem.elements[id]?.renderer;\n          if (!isStatic) {\n            entries[id] = renderer?.(option);\n          } else if (!skipIdSet.has(id)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached\n              ? await cached\n              : await setCachedElement(id, renderer?.(option));\n          }\n        },\n      ),\n      ...slices.map(async (sliceId) => {\n        const id = SLICE_SLOT_ID_PREFIX + sliceId;\n        const sliceConfig = sliceConfigMap.get(sliceId);\n        if (!sliceConfig) {\n          throw new Error(`Slice not found: ${sliceId}`);\n        }\n        if (sliceConfig.isStatic && skipIdSet.has(id)) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        entries[id] = sliceElement;\n      }),\n    ]);\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = pathConfigItem.isStatic;\n    sliceConfigMap.forEach((sliceConfig, sliceId) => {\n      if (sliceConfig.isStatic) {\n        // FIXME: hard-coded for now\n        entries[IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId] = true;\n      }\n    });\n    if (myConfig.has404) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineHandlers>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineHandlers>[0]['handleBuild'];\n\n  const cachedElementsForRequest = new Map<SlotId, Promise<ReactNode>>();\n  let cachedElementsForRequestInitialized = false;\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, parseRsc, renderHtml, loadBuildMetadata },\n  ): Promise<ReadableStream | Response | 'fallback' | null | undefined> => {\n    const getCachedElement = (id: SlotId) => cachedElementsForRequest.get(id);\n    const setCachedElement = (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForRequest.get(id);\n      if (cached) {\n        return cached;\n      }\n      const copied = renderRsc({ [id]: element }).then((rscStream) =>\n        parseRsc(rscStream).then((parsed) => parsed[id]),\n      ) as Promise<ReactNode>;\n      cachedElementsForRequest.set(id, copied);\n      return copied;\n    };\n    if (!cachedElementsForRequestInitialized) {\n      cachedElementsForRequestInitialized = true;\n      const cachedElementsMetadata = await loadBuildMetadata(\n        'defineRouter:cachedElements',\n      );\n      if (cachedElementsMetadata) {\n        Object.entries(JSON.parse(cachedElementsMetadata)).forEach(\n          ([id, str]) => {\n            cachedElementsForRequest.set(\n              id,\n              parseRsc(base64ToStream(str as string)).then(\n                (parsed) => parsed[id],\n              ) as Promise<ReactNode>,\n            );\n          },\n        );\n      }\n    }\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.type === 'api') {\n      const url = new URL(input.req.url);\n      url.pathname = input.pathname;\n      const req = new Request(url, input.req);\n      return pathConfigItem.handler(req);\n    }\n    const url = new URL(input.req.url);\n    const headers = Object.fromEntries(input.req.headers.entries());\n    if (input.type === 'component') {\n      const sliceId = decodeSliceId(input.rscPath);\n      if (sliceId !== null) {\n        // LIMITATION: This is a signle slice request.\n        // Ideally, we should be able to respond with multiple slices in one request.\n        const sliceConfig = await getMyConfig().then((myConfig) =>\n          myConfig.configs.find(\n            (item): item is typeof item & { type: 'slice' } =>\n              item.type === 'slice' && item.id === sliceId,\n          ),\n        );\n        if (!sliceConfig) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        return renderRsc({\n          [SLICE_SLOT_ID_PREFIX + sliceId]: sliceElement,\n          ...(sliceConfig.isStatic\n            ? {\n                // FIXME: hard-coded for now\n                [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId]: true,\n              }\n            : {}),\n        });\n      }\n      const entries = await getEntriesForRoute(\n        input.rscPath,\n        input.rscParams,\n        headers,\n        getCachedElement,\n        setCachedElement,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntriesForRoute(\n            rscPath,\n            rscParams,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          ),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      try {\n        const value = await input.fn(...input.args);\n        return renderRsc({ ...(await elementsPromise), _value: value });\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.location) {\n          const rscPath = encodeRoutePath(info.location);\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            unstable_notFound();\n          }\n          return renderRsc(entries);\n        }\n        throw e;\n      } finally {\n        rendered = true;\n      }\n    }\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (\n        pathname: string,\n        query: string,\n        httpstatus = 200,\n      ) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntriesForRoute(\n          rscPath,\n          rscParams,\n          headers,\n          getCachedElement,\n          setCachedElement,\n        );\n        if (!entries) {\n          return null;\n        }\n        const html = (\n          <INTERNAL_ServerRouter\n            route={{ path: pathname, query, hash: '' }}\n            httpstatus={httpstatus}\n          />\n        );\n        const actionResult =\n          input.type === 'action' ? await input.fn() : undefined;\n        return renderHtml(await renderRsc(entries), html, {\n          rscPath,\n          actionResult,\n          status: httpstatus,\n        });\n      };\n      const query = url.searchParams.toString();\n      if (pathConfigItem?.type === 'route' && pathConfigItem.noSsr) {\n        return 'fallback';\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if ((await getMyConfig()).has404) {\n        return renderIt('/404', '', 404);\n      } else {\n        return null;\n      }\n    }\n  };\n\n  const handleBuild: HandleBuild = async ({\n    renderRsc,\n    parseRsc,\n    renderHtml,\n    rscPath2pathname,\n    saveBuildMetadata,\n    withRequest,\n    generateFile,\n    generateDefaultHtml,\n  }) => {\n    const myConfig = await getMyConfig();\n    const cachedElementsForBuild = new Map<SlotId, Promise<ReactNode>>();\n    const serializedCachedElements = new Map<SlotId, string>();\n    const getCachedElement = (id: SlotId) => cachedElementsForBuild.get(id);\n    const setCachedElement = async (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForBuild.get(id);\n      if (cached) {\n        return cached;\n      }\n      const teedStream = renderRsc({ [id]: element }).then((rscStream) =>\n        rscStream.tee(),\n      );\n      const stream1 = teedStream.then(([s1]) => s1);\n      const stream2 = teedStream.then(([, s2]) => s2);\n      const copied = stream1.then(\n        (rscStream) =>\n          parseRsc(rscStream).then(\n            (parsed) => parsed[id],\n          ) as Promise<ReactNode>,\n      );\n      cachedElementsForBuild.set(id, copied);\n      serializedCachedElements.set(id, await streamToBase64(await stream2));\n      return copied;\n    };\n\n    // hard-coded concurrency limit\n    const { runTask, waitForTasks } = createTaskRunner(500);\n\n    // static api\n    for (const item of myConfig.configs) {\n      if (item.type !== 'api') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const res = await item.handler(req);\n          await generateFile(pathname, res.body || '');\n        });\n      });\n    }\n\n    // static route\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const rscPath = encodeRoutePath(pathname);\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            {},\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            return;\n          }\n          for (const id of Object.keys(entries)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached ? await cached : entries[id];\n          }\n          const stream = await renderRsc(entries);\n          const [stream1, stream2] = stream.tee();\n          await generateFile(rscPath2pathname(rscPath), stream1);\n          const html = (\n            <INTERNAL_ServerRouter\n              route={{ path: pathname, query: '', hash: '' }}\n              httpstatus={is404(item.path) ? 404 : 200}\n            />\n          );\n          const res = await renderHtml(stream2, html, { rscPath });\n          await generateFile(htmlPath2pathname(pathname), res.body || '');\n        });\n      });\n    }\n\n    // default html\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (item.noSsr) {\n        const pathname = pathSpec2pathname(item.path);\n        if (!pathname) {\n          throw new Error('Pathname is required for noSsr routes on build');\n        }\n        runTask(async () => {\n          await generateDefaultHtml(htmlPath2pathname(pathname));\n        });\n      }\n    }\n\n    // static slice\n    for (const item of myConfig.configs) {\n      if (item.type !== 'slice') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const rscPath = encodeSliceId(item.id);\n      // dummy req for slice which is not determined at build time\n      const req = new Request(new URL('http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const sliceElement = await getSliceElement(\n            item,\n            getCachedElement,\n            setCachedElement,\n          );\n          const body = await renderRsc({\n            [SLICE_SLOT_ID_PREFIX + item.id]: sliceElement,\n            // FIXME: hard-coded for now\n            [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + item.id]: true,\n          });\n          await generateFile(rscPath2pathname(rscPath), body);\n        });\n      });\n    }\n\n    await waitForTasks();\n\n    // TODO should we save serialized cached elements separately?\n    await saveBuildMetadata(\n      'defineRouter:cachedElements',\n      JSON.stringify(Object.fromEntries(serializedCachedElements)),\n    );\n  };\n\n  return Object.assign(defineHandlers({ handleRequest, handleBuild }), {\n    unstable_getRouterConfigs: () => getMyConfig().then((c) => c.configs),\n  });\n}\n"],"names":["createCustomError","getErrorInfo","getPathMapping","base64ToStream","streamToBase64","createTaskRunner","unstable_defineHandlers","defineHandlers","unstable_getContext","getContext","INTERNAL_ServerRouter","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","decodeRoutePath","decodeSliceId","encodeRoutePath","encodeSliceId","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RSC_PATH_SYMBOL","Symbol","RSC_PARAMS_SYMBOL","setRscPath","rscPath","context","setRscParams","unstable_getRscPath","undefined","unstable_getRscParams","RERENDER_SYMBOL","setRerender","rerender","getRerender","is404","pathSpec","length","type","name","pathSpec2pathname","some","map","join","htmlPath2pathname","htmlPath","unstable_rerenderRoute","pathname","unstable_notFound","status","unstable_redirect","location","ROOT_SLOT_ID","ROUTE_SLOT_ID_PREFIX","SLICE_SLOT_ID_PREFIX","assertNonReservedSlotId","slotId","startsWith","Error","unstable_defineRouter","fns","cachedMyConfig","getMyConfig","configs","from","getConfigs","has404","forEach","item","Object","keys","elements","path","getPathConfigItem","myConfig","found","find","getSliceElement","sliceConfig","getCachedElement","setCachedElement","id","cached","element","renderer","isStatic","getEntriesForRoute","headers","pathConfigItem","skipParam","JSON","parse","toLowerCase","skipIdSet","Set","decodedPathname","decodeURI","routeId","option","slices","sliceConfigMap","Map","sliceId","set","entries","Promise","all","rootElement","has","routeElement","sliceElement","cachedElementsForRequest","cachedElementsForRequestInitialized","handleRequest","input","renderRsc","parseRsc","renderHtml","loadBuildMetadata","copied","then","rscStream","parsed","cachedElementsMetadata","str","url","URL","req","Request","handler","fromEntries","elementsPromise","resolve","rendered","oldElements","newElements","console","warn","value","fn","args","_value","e","info","renderIt","httpstatus","html","route","hash","actionResult","searchParams","toString","noSsr","handleBuild","rscPath2pathname","saveBuildMetadata","withRequest","generateFile","generateDefaultHtml","cachedElementsForBuild","serializedCachedElements","teedStream","tee","stream1","s1","stream2","s2","runTask","waitForTasks","res","body","stream","stringify","assign","unstable_getRouterConfigs","c"],"mappings":";AACA,SAASA,iBAAiB,EAAEC,YAAY,QAAQ,gCAAgC;AAChF,SAASC,cAAc,QAAQ,uBAAuB;AAEtD,SAASC,cAAc,EAAEC,cAAc,QAAQ,yBAAyB;AACxE,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,2BAA2BC,cAAc,QAAQ,uBAAuB;AACjF,SAASC,uBAAuBC,UAAU,QAAQ,eAAe;AACjE,SAASC,qBAAqB,QAAQ,cAAc;AACpD,SACEC,SAAS,EACTC,YAAY,EACZC,QAAQ,EACRC,WAAW,EACXC,eAAe,EACfC,aAAa,EACbC,eAAe,EACfC,aAAa,QACR,cAAc;AAErB,MAAMC,gBAAgB,CAACC,IACrBC,MAAMC,OAAO,CAACF,MAAMA,EAAEG,KAAK,CAAC,CAACC,IAAM,OAAOA,MAAM;AAElD,MAAMC,iBAAiB,CACrBC;IAIA,IAAIA,qBAAqBC,iBAAiB;QACxC,OAAO;YAAEC,OAAOF,UAAUG,GAAG,CAAC,YAAY;QAAG;IAC/C;IACA,IACE,OAAQH,WAAiDE,UAAU,UACnE;QACA,OAAO;YAAEA,OAAO,AAACF,UAAgCE,KAAK;QAAC;IACzD;IACA,OAAO;QAAEA,OAAO;IAAG;AACrB;AAEA,MAAME,kBAAkBC,OAAO;AAC/B,MAAMC,oBAAoBD,OAAO;AAEjC,MAAME,aAAa,CAACC;IAClB,IAAI;QACF,MAAMC,UAAU1B;QACf0B,OAA8D,CAC7DL,gBACD,GAAGI;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,MAAME,eAAe,CAACV;IACpB,IAAI;QACF,MAAMS,UAAU1B;QACf0B,OAAgE,CAC/DH,kBACD,GAAGN;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,OAAO,SAASW;IACd,IAAI;QACF,MAAMF,UAAU1B;QAChB,OAAO,AAAC0B,OAA6D,CACnEL,gBACD;IACH,EAAE,OAAM;QACN,OAAOQ;IACT;AACF;AAEA,OAAO,SAASC;IACd,IAAI;QACF,MAAMJ,UAAU1B;QAChB,OAAO,AAAC0B,OAAgE,CACtEH,kBACD;IACH,EAAE,OAAM;QACN,OAAOM;IACT;AACF;AAEA,MAAME,kBAAkBT,OAAO;AAG/B,MAAMU,cAAc,CAACC;IACnB,IAAI;QACF,MAAMP,UAAU1B;QACf0B,OAA+D,CAC9DK,gBACD,GAAGE;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,MAAMC,cAAc;IAClB,MAAMR,UAAU1B;IAChB,OAAO,AAAC0B,OAA+D,CACrEK,gBACD;AACH;AAEA,MAAMI,QAAQ,CAACC,WACbA,SAASC,MAAM,KAAK,KACpBD,QAAQ,CAAC,EAAE,CAAEE,IAAI,KAAK,aACtBF,QAAQ,CAAC,EAAE,CAAEG,IAAI,KAAK;AAExB,MAAMC,oBAAoB,CAACJ;IACzB,IAAIA,SAASK,IAAI,CAAC,CAAC,EAAEH,IAAI,EAAE,GAAKA,SAAS,YAAY;QACnD,OAAOT;IACT;IACA,OAAO,MAAMO,SAASM,GAAG,CAAC,CAAC,EAAEH,IAAI,EAAE,GAAKA,MAAOI,IAAI,CAAC;AACtD;AAEA,MAAMC,oBAAoB,CAACC,WACzBA,aAAa,SAAS,aAAaA,WAAW;AAEhD,OAAO,SAASC,uBAAuBC,QAAgB,EAAE5B,KAAc;IACrE,MAAMM,UAAUjB,gBAAgBuC;IAChCb,cAAcT,SAASN,SAAS,IAAID,gBAAgB;QAAEC;IAAM;AAC9D;AAEA,OAAO,SAAS6B;IACd,MAAMzD,kBAAkB,aAAa;QAAE0D,QAAQ;IAAI;AACrD;AAEA,OAAO,SAASC,kBACdC,QAAgB,EAChBF,SAA0B,GAAG;IAE7B,MAAM1D,kBAAkB,YAAY;QAAE0D;QAAQE;IAAS;AACzD;AAIA,MAAMC,eAAe;AACrB,MAAMC,uBAAuB;AAC7B,MAAMC,uBAAuB;AAE7B,MAAMC,0BAA0B,CAACC;IAC/B,IACEA,WAAWJ,gBACXI,OAAOC,UAAU,CAACJ,yBAClBG,OAAOC,UAAU,CAACH,uBAClB;QACA,MAAM,IAAII,MAAM;IAClB;AACF;AA0CA,OAAO,SAASC,sBAAsBC,GAErC;IAOC,IAAIC;IACJ,MAAMC,cAAc;QAClB,IAAI,CAACD,gBAAgB;YACnB,MAAME,UAAUnD,MAAMoD,IAAI,CAAC,MAAMJ,IAAIK,UAAU;YAC/C,IAAIC,SAAS;YACbH,QAAQI,OAAO,CAAC,CAACC;gBACf,IAAIA,KAAK9B,IAAI,KAAK,SAAS;oBACzB+B,OAAOC,IAAI,CAACF,KAAKG,QAAQ,EAAEJ,OAAO,CAACZ;oBACnC,IAAI,CAACW,UAAU/B,MAAMiC,KAAKI,IAAI,GAAG;wBAC/BN,SAAS;oBACX;gBACF;YACF;YACAL,iBAAiB;gBAAEE;gBAASG;YAAO;QACrC;QACA,OAAOL;IACT;IAEA,MAAMY,oBAAoB,OAAO1B;QAC/B,MAAM2B,WAAW,MAAMZ;QACvB,MAAMa,QAAQD,SAASX,OAAO,CAACa,IAAI,CACjC,CAACR,OACC,AAACA,CAAAA,KAAK9B,IAAI,KAAK,WAAW8B,KAAK9B,IAAI,KAAK,KAAI,KAC5C,CAAC,CAAC7C,eAAe2E,KAAKI,IAAI,EAAEzB;QAEhC,OAAO4B;IACT;IAEA,MAAME,kBAAkB,OACtBC,aAKAC,kBACAC;QAEA,MAAMC,KAAK3B,uBAAuBwB,YAAYG,EAAE;QAChD,MAAMC,SAASH,iBAAiBE;QAChC,IAAIC,QAAQ;YACV,OAAOA;QACT;QACA,IAAIC,UAAU,MAAML,YAAYM,QAAQ;QACxC,IAAIN,YAAYO,QAAQ,EAAE;YACxBF,UAAU,MAAMH,iBAAiBC,IAAIE;QACvC;QACA,OAAOA;IACT;IAEA,MAAMG,qBAAqB,OACzB7D,SACAR,WACAsE,SACAR,kBACAC;QAEAxD,WAAWC;QACXE,aAAaV;QACb,MAAM8B,WAAWzC,gBAAgBmB;QACjC,MAAM+D,iBAAiB,MAAMf,kBAAkB1B;QAC/C,IAAIyC,gBAAgBlD,SAAS,SAAS;YACpC,OAAO;QACT;QACA,IAAImD;QACJ,IAAI;YACFA,YAAYC,KAAKC,KAAK,CAACJ,OAAO,CAAClF,YAAYuF,WAAW,GAAG,IAAI;QAC/D,EAAE,OAAM;QACN,SAAS;QACX;QACA,MAAMC,YAAY,IAAIC,IAAIpF,cAAc+E,aAAaA,YAAY,EAAE;QACnE,MAAM,EAAEtE,KAAK,EAAE,GAAGH,eAAeC;QACjC,MAAM8E,kBAAkBC,UAAUjD;QAClC,MAAMkD,UAAU5C,uBAAuB0C;QACvC,MAAMG,SAAyB;YAC7BnD,UAAUgD;YACV5E,OAAOqE,eAAeH,QAAQ,GAAGxD,YAAYV;QAC/C;QACA,MAAMuD,WAAW,MAAMZ;QACvB,MAAMqC,SAASX,eAAeW,MAAM,IAAI,EAAE;QAC1C,MAAMC,iBAAiB,IAAIC;QAI3BF,OAAOhC,OAAO,CAAC,CAACmC;YACd,MAAMxB,cAAcJ,SAASX,OAAO,CAACa,IAAI,CACvC,CAACR,OACCA,KAAK9B,IAAI,KAAK,WAAW8B,KAAKa,EAAE,KAAKqB;YAEzC,IAAIxB,aAAa;gBACfsB,eAAeG,GAAG,CAACD,SAASxB;YAC9B;QACF;QACA,MAAM0B,UAAmC,CAAC;QAC1C,MAAMC,QAAQC,GAAG,CAAC;YACf,CAAA;gBACC,IAAI,CAAClB,eAAemB,WAAW,CAACtB,QAAQ,EAAE;oBACxCmB,OAAO,CAACpD,aAAa,GAAGoC,eAAemB,WAAW,CAACvB,QAAQ,CAACc;gBAC9D,OAAO,IAAI,CAACL,UAAUe,GAAG,CAACxD,eAAe;oBACvC,MAAM8B,SAASH,iBAAiB3B;oBAChCoD,OAAO,CAACpD,aAAa,GAAG8B,SACpB,MAAMA,SACN,MAAMF,iBACJ5B,cACAoC,eAAemB,WAAW,CAACvB,QAAQ,CAACc;gBAE5C;YACF,CAAA;YACC,CAAA;gBACC,IAAI,CAACV,eAAeqB,YAAY,CAACxB,QAAQ,EAAE;oBACzCmB,OAAO,CAACP,QAAQ,GAAGT,eAAeqB,YAAY,CAACzB,QAAQ,CAACc;gBAC1D,OAAO,IAAI,CAACL,UAAUe,GAAG,CAACX,UAAU;oBAClC,MAAMf,SAASH,iBAAiBkB;oBAChCO,OAAO,CAACP,QAAQ,GAAGf,SACf,MAAMA,SACN,MAAMF,iBACJiB,SACAT,eAAeqB,YAAY,CAACzB,QAAQ,CAACc;gBAE7C;YACF,CAAA;eACG7B,OAAOmC,OAAO,CAAChB,eAAejB,QAAQ,EAAE7B,GAAG,CAC5C,OAAO,CAACuC,IAAI,EAAEI,QAAQ,EAAE,CAAC;gBACvB,MAAMD,WAAWI,eAAejB,QAAQ,CAACU,GAAG,EAAEG;gBAC9C,IAAI,CAACC,UAAU;oBACbmB,OAAO,CAACvB,GAAG,GAAGG,WAAWc;gBAC3B,OAAO,IAAI,CAACL,UAAUe,GAAG,CAAC3B,KAAK;oBAC7B,MAAMC,SAASH,iBAAiBE;oBAChCuB,OAAO,CAACvB,GAAG,GAAGC,SACV,MAAMA,SACN,MAAMF,iBAAiBC,IAAIG,WAAWc;gBAC5C;YACF;eAECC,OAAOzD,GAAG,CAAC,OAAO4D;gBACnB,MAAMrB,KAAK3B,uBAAuBgD;gBAClC,MAAMxB,cAAcsB,eAAehF,GAAG,CAACkF;gBACvC,IAAI,CAACxB,aAAa;oBAChB,MAAM,IAAIpB,MAAM,CAAC,iBAAiB,EAAE4C,SAAS;gBAC/C;gBACA,IAAIxB,YAAYO,QAAQ,IAAIQ,UAAUe,GAAG,CAAC3B,KAAK;oBAC7C,OAAO;gBACT;gBACA,MAAM6B,eAAe,MAAMjC,gBACzBC,aACAC,kBACAC;gBAEFwB,OAAO,CAACvB,GAAG,GAAG6B;YAChB;SACD;QACDN,OAAO,CAACpG,SAAS,GAAG;YAAC2F;YAAiB5E;SAAM;QAC5CqF,OAAO,CAACrG,aAAa,GAAGqF,eAAeH,QAAQ;QAC/Ce,eAAejC,OAAO,CAAC,CAACW,aAAawB;YACnC,IAAIxB,YAAYO,QAAQ,EAAE;gBACxB,4BAA4B;gBAC5BmB,OAAO,CAACrG,eAAe,MAAMmD,uBAAuBgD,QAAQ,GAAG;YACjE;QACF;QACA,IAAI5B,SAASR,MAAM,EAAE;YACnBsC,OAAO,CAACtG,UAAU,GAAG;QACvB;QACA,OAAOsG;IACT;IAKA,MAAMO,2BAA2B,IAAIV;IACrC,IAAIW,sCAAsC;IAC1C,MAAMC,gBAA+B,OACnCC,OACA,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,iBAAiB,EAAE;QAEtD,MAAMvC,mBAAmB,CAACE,KAAe8B,yBAAyB3F,GAAG,CAAC6D;QACtE,MAAMD,mBAAmB,CAACC,IAAYE;YACpC,MAAMD,SAAS6B,yBAAyB3F,GAAG,CAAC6D;YAC5C,IAAIC,QAAQ;gBACV,OAAOA;YACT;YACA,MAAMqC,SAASJ,UAAU;gBAAE,CAAClC,GAAG,EAAEE;YAAQ,GAAGqC,IAAI,CAAC,CAACC,YAChDL,SAASK,WAAWD,IAAI,CAAC,CAACE,SAAWA,MAAM,CAACzC,GAAG;YAEjD8B,yBAAyBR,GAAG,CAACtB,IAAIsC;YACjC,OAAOA;QACT;QACA,IAAI,CAACP,qCAAqC;YACxCA,sCAAsC;YACtC,MAAMW,yBAAyB,MAAML,kBACnC;YAEF,IAAIK,wBAAwB;gBAC1BtD,OAAOmC,OAAO,CAACd,KAAKC,KAAK,CAACgC,yBAAyBxD,OAAO,CACxD,CAAC,CAACc,IAAI2C,IAAI;oBACRb,yBAAyBR,GAAG,CAC1BtB,IACAmC,SAAS1H,eAAekI,MAAgBJ,IAAI,CAC1C,CAACE,SAAWA,MAAM,CAACzC,GAAG;gBAG5B;YAEJ;QACF;QACA,MAAMO,iBAAiB,MAAMf,kBAAkByC,MAAMnE,QAAQ;QAC7D,IAAIyC,gBAAgBlD,SAAS,OAAO;YAClC,MAAMuF,MAAM,IAAIC,IAAIZ,MAAMa,GAAG,CAACF,GAAG;YACjCA,IAAI9E,QAAQ,GAAGmE,MAAMnE,QAAQ;YAC7B,MAAMgF,MAAM,IAAIC,QAAQH,KAAKX,MAAMa,GAAG;YACtC,OAAOvC,eAAeyC,OAAO,CAACF;QAChC;QACA,MAAMF,MAAM,IAAIC,IAAIZ,MAAMa,GAAG,CAACF,GAAG;QACjC,MAAMtC,UAAUlB,OAAO6D,WAAW,CAAChB,MAAMa,GAAG,CAACxC,OAAO,CAACiB,OAAO;QAC5D,IAAIU,MAAM5E,IAAI,KAAK,aAAa;YAC9B,MAAMgE,UAAU/F,cAAc2G,MAAMzF,OAAO;YAC3C,IAAI6E,YAAY,MAAM;gBACpB,8CAA8C;gBAC9C,6EAA6E;gBAC7E,MAAMxB,cAAc,MAAMhB,cAAc0D,IAAI,CAAC,CAAC9C,WAC5CA,SAASX,OAAO,CAACa,IAAI,CACnB,CAACR,OACCA,KAAK9B,IAAI,KAAK,WAAW8B,KAAKa,EAAE,KAAKqB;gBAG3C,IAAI,CAACxB,aAAa;oBAChB,OAAO;gBACT;gBACA,MAAMgC,eAAe,MAAMjC,gBACzBC,aACAC,kBACAC;gBAEF,OAAOmC,UAAU;oBACf,CAAC7D,uBAAuBgD,QAAQ,EAAEQ;oBAClC,GAAIhC,YAAYO,QAAQ,GACpB;wBACE,4BAA4B;wBAC5B,CAAClF,eAAe,MAAMmD,uBAAuBgD,QAAQ,EAAE;oBACzD,IACA,CAAC,CAAC;gBACR;YACF;YACA,MAAME,UAAU,MAAMlB,mBACpB4B,MAAMzF,OAAO,EACbyF,MAAMjG,SAAS,EACfsE,SACAR,kBACAC;YAEF,IAAI,CAACwB,SAAS;gBACZ,OAAO;YACT;YACA,OAAOW,UAAUX;QACnB;QACA,IAAIU,MAAM5E,IAAI,KAAK,YAAY;YAC7B,IAAI6F,kBAAoD1B,QAAQ2B,OAAO,CACrE,CAAC;YAEH,IAAIC,WAAW;YACf,MAAMpG,WAAW,CAACR,SAAiBR;gBACjC,IAAIoH,UAAU;oBACZ,MAAM,IAAI3E,MAAM;gBAClB;gBACAyE,kBAAkB1B,QAAQC,GAAG,CAAC;oBAC5ByB;oBACA7C,mBACE7D,SACAR,WACAsE,SACAR,kBACAC;iBAEH,EAAEwC,IAAI,CAAC,CAAC,CAACc,aAAaC,YAAY;oBACjC,IAAIA,gBAAgB,MAAM;wBACxBC,QAAQC,IAAI,CAAC;oBACf;oBACA,OAAO;wBACL,GAAGH,WAAW;wBACd,GAAGC,WAAW;oBAChB;gBACF;YACF;YACAvG,YAAYC;YACZ,IAAI;gBACF,MAAMyG,QAAQ,MAAMxB,MAAMyB,EAAE,IAAIzB,MAAM0B,IAAI;gBAC1C,OAAOzB,UAAU;oBAAE,GAAI,MAAMgB,eAAe;oBAAGU,QAAQH;gBAAM;YAC/D,EAAE,OAAOI,GAAG;gBACV,MAAMC,OAAOvJ,aAAasJ;gBAC1B,IAAIC,MAAM5F,UAAU;oBAClB,MAAM1B,UAAUjB,gBAAgBuI,KAAK5F,QAAQ;oBAC7C,MAAMqD,UAAU,MAAMlB,mBACpB7D,SACAI,WACA0D,SACAR,kBACAC;oBAEF,IAAI,CAACwB,SAAS;wBACZxD;oBACF;oBACA,OAAOmE,UAAUX;gBACnB;gBACA,MAAMsC;YACR,SAAU;gBACRT,WAAW;YACb;QACF;QACA,IAAInB,MAAM5E,IAAI,KAAK,YAAY4E,MAAM5E,IAAI,KAAK,UAAU;YACtD,MAAM0G,WAAW,OACfjG,UACA5B,OACA8H,aAAa,GAAG;gBAEhB,MAAMxH,UAAUjB,gBAAgBuC;gBAChC,MAAM9B,YAAY,IAAIC,gBAAgB;oBAAEC;gBAAM;gBAC9C,MAAMqF,UAAU,MAAMlB,mBACpB7D,SACAR,WACAsE,SACAR,kBACAC;gBAEF,IAAI,CAACwB,SAAS;oBACZ,OAAO;gBACT;gBACA,MAAM0C,qBACJ,KAACjJ;oBACCkJ,OAAO;wBAAE3E,MAAMzB;wBAAU5B;wBAAOiI,MAAM;oBAAG;oBACzCH,YAAYA;;gBAGhB,MAAMI,eACJnC,MAAM5E,IAAI,KAAK,WAAW,MAAM4E,MAAMyB,EAAE,KAAK9G;gBAC/C,OAAOwF,WAAW,MAAMF,UAAUX,UAAU0C,MAAM;oBAChDzH;oBACA4H;oBACApG,QAAQgG;gBACV;YACF;YACA,MAAM9H,QAAQ0G,IAAIyB,YAAY,CAACC,QAAQ;YACvC,IAAI/D,gBAAgBlD,SAAS,WAAWkD,eAAegE,KAAK,EAAE;gBAC5D,OAAO;YACT;YACA,IAAI;gBACF,IAAIhE,gBAAgB;oBAClB,OAAO,MAAMwD,SAAS9B,MAAMnE,QAAQ,EAAE5B;gBACxC;YACF,EAAE,OAAO2H,GAAG;gBACV,MAAMC,OAAOvJ,aAAasJ;gBAC1B,IAAIC,MAAM9F,WAAW,KAAK;oBACxB,MAAM6F;gBACR;YACF;YACA,IAAI,AAAC,CAAA,MAAMhF,aAAY,EAAGI,MAAM,EAAE;gBAChC,OAAO8E,SAAS,QAAQ,IAAI;YAC9B,OAAO;gBACL,OAAO;YACT;QACF;IACF;IAEA,MAAMS,cAA2B,OAAO,EACtCtC,SAAS,EACTC,QAAQ,EACRC,UAAU,EACVqC,gBAAgB,EAChBC,iBAAiB,EACjBC,WAAW,EACXC,YAAY,EACZC,mBAAmB,EACpB;QACC,MAAMpF,WAAW,MAAMZ;QACvB,MAAMiG,yBAAyB,IAAI1D;QACnC,MAAM2D,2BAA2B,IAAI3D;QACrC,MAAMtB,mBAAmB,CAACE,KAAe8E,uBAAuB3I,GAAG,CAAC6D;QACpE,MAAMD,mBAAmB,OAAOC,IAAYE;YAC1C,MAAMD,SAAS6E,uBAAuB3I,GAAG,CAAC6D;YAC1C,IAAIC,QAAQ;gBACV,OAAOA;YACT;YACA,MAAM+E,aAAa9C,UAAU;gBAAE,CAAClC,GAAG,EAAEE;YAAQ,GAAGqC,IAAI,CAAC,CAACC,YACpDA,UAAUyC,GAAG;YAEf,MAAMC,UAAUF,WAAWzC,IAAI,CAAC,CAAC,CAAC4C,GAAG,GAAKA;YAC1C,MAAMC,UAAUJ,WAAWzC,IAAI,CAAC,CAAC,GAAG8C,GAAG,GAAKA;YAC5C,MAAM/C,SAAS4C,QAAQ3C,IAAI,CACzB,CAACC,YACCL,SAASK,WAAWD,IAAI,CACtB,CAACE,SAAWA,MAAM,CAACzC,GAAG;YAG5B8E,uBAAuBxD,GAAG,CAACtB,IAAIsC;YAC/ByC,yBAAyBzD,GAAG,CAACtB,IAAI,MAAMtF,eAAe,MAAM0K;YAC5D,OAAO9C;QACT;QAEA,+BAA+B;QAC/B,MAAM,EAAEgD,OAAO,EAAEC,YAAY,EAAE,GAAG5K,iBAAiB;QAEnD,aAAa;QACb,KAAK,MAAMwE,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,OAAO;gBACvB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAMtC,WAAWP,kBAAkB4B,KAAKI,IAAI;YAC5C,IAAI,CAACzB,UAAU;gBACb;YACF;YACA,MAAMgF,MAAM,IAAIC,QAAQ,IAAIF,IAAI/E,UAAU;YAC1CwH,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAM0C,MAAM,MAAMrG,KAAK6D,OAAO,CAACF;oBAC/B,MAAM8B,aAAa9G,UAAU0H,IAAIC,IAAI,IAAI;gBAC3C;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMtG,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAMtC,WAAWP,kBAAkB4B,KAAKI,IAAI;YAC5C,IAAI,CAACzB,UAAU;gBACb;YACF;YACA,MAAMtB,UAAUjB,gBAAgBuC;YAChC,MAAMgF,MAAM,IAAIC,QAAQ,IAAIF,IAAI/E,UAAU;YAC1CwH,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAMvB,UAAU,MAAMlB,mBACpB7D,SACAI,WACA,CAAC,GACDkD,kBACAC;oBAEF,IAAI,CAACwB,SAAS;wBACZ;oBACF;oBACA,KAAK,MAAMvB,MAAMZ,OAAOC,IAAI,CAACkC,SAAU;wBACrC,MAAMtB,SAASH,iBAAiBE;wBAChCuB,OAAO,CAACvB,GAAG,GAAGC,SAAS,MAAMA,SAASsB,OAAO,CAACvB,GAAG;oBACnD;oBACA,MAAM0F,SAAS,MAAMxD,UAAUX;oBAC/B,MAAM,CAAC2D,SAASE,QAAQ,GAAGM,OAAOT,GAAG;oBACrC,MAAML,aAAaH,iBAAiBjI,UAAU0I;oBAC9C,MAAMjB,qBACJ,KAACjJ;wBACCkJ,OAAO;4BAAE3E,MAAMzB;4BAAU5B,OAAO;4BAAIiI,MAAM;wBAAG;wBAC7CH,YAAY9G,MAAMiC,KAAKI,IAAI,IAAI,MAAM;;oBAGzC,MAAMiG,MAAM,MAAMpD,WAAWgD,SAASnB,MAAM;wBAAEzH;oBAAQ;oBACtD,MAAMoI,aAAajH,kBAAkBG,WAAW0H,IAAIC,IAAI,IAAI;gBAC9D;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMtG,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI8B,KAAKoF,KAAK,EAAE;gBACd,MAAMzG,WAAWP,kBAAkB4B,KAAKI,IAAI;gBAC5C,IAAI,CAACzB,UAAU;oBACb,MAAM,IAAIW,MAAM;gBAClB;gBACA6G,QAAQ;oBACN,MAAMT,oBAAoBlH,kBAAkBG;gBAC9C;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMqB,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAM5D,UAAUhB,cAAc2D,KAAKa,EAAE;YACrC,4DAA4D;YAC5D,MAAM8C,MAAM,IAAIC,QAAQ,IAAIF,IAAI;YAChCyC,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAMjB,eAAe,MAAMjC,gBACzBT,MACAW,kBACAC;oBAEF,MAAM0F,OAAO,MAAMvD,UAAU;wBAC3B,CAAC7D,uBAAuBc,KAAKa,EAAE,CAAC,EAAE6B;wBAClC,4BAA4B;wBAC5B,CAAC3G,eAAe,MAAMmD,uBAAuBc,KAAKa,EAAE,CAAC,EAAE;oBACzD;oBACA,MAAM4E,aAAaH,iBAAiBjI,UAAUiJ;gBAChD;YACF;QACF;QAEA,MAAMF;QAEN,6DAA6D;QAC7D,MAAMb,kBACJ,+BACAjE,KAAKkF,SAAS,CAACvG,OAAO6D,WAAW,CAAC8B;IAEtC;IAEA,OAAO3F,OAAOwG,MAAM,CAAC/K,eAAe;QAAEmH;QAAewC;IAAY,IAAI;QACnEqB,2BAA2B,IAAMhH,cAAc0D,IAAI,CAAC,CAACuD,IAAMA,EAAEhH,OAAO;IACtE;AACF"}
\ No newline at end of file
+{"version":3,"sources":["../../src/router/define-router.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { getPathMapping, path2regexp } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';\nimport { createTaskRunner } from '../lib/utils/task-runner.js';\nimport { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';\nimport { unstable_getContext as getContext } from '../server.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  decodeRoutePath,\n  decodeSliceId,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (rscParams instanceof URLSearchParams) {\n    return { query: rscParams.get('query') || '' };\n  }\n  if (\n    typeof (rscParams as { query?: undefined } | undefined)?.query === 'string'\n  ) {\n    return { query: (rscParams as { query: string }).query };\n  }\n  return { query: '' };\n};\n\nconst RSC_PATH_SYMBOL = Symbol('RSC_PATH');\nconst RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');\n\nconst setRscPath = (rscPath: string) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PATH_SYMBOL, unknown>)[\n      RSC_PATH_SYMBOL\n    ] = rscPath;\n  } catch {\n    // ignore\n  }\n};\n\nconst setRscParams = (rscParams: unknown) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ] = rscParams;\n  } catch {\n    // ignore\n  }\n};\n\nexport function unstable_getRscPath(): string | undefined {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PATH_SYMBOL, string>)[\n      RSC_PATH_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nexport function unstable_getRscParams(): unknown {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nconst getNonce = () => {\n  try {\n    const context = getContext();\n    return context.nonce;\n  } catch {\n    return undefined;\n  }\n};\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst is404 = (pathSpec: PathSpec) =>\n  pathSpec.length === 1 &&\n  pathSpec[0]!.type === 'literal' &&\n  pathSpec[0]!.name === '404';\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nconst htmlPath2pathname = (htmlPath: string): string =>\n  htmlPath === '/404' ? '404.html' : htmlPath + '/index.html';\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 303 | 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROOT_SLOT_ID = 'root';\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\nconst SLICE_SLOT_ID_PREFIX = 'slice:';\n\nconst assertNonReservedSlotId = (slotId: SlotId) => {\n  if (\n    slotId === ROOT_SLOT_ID ||\n    slotId.startsWith(ROUTE_SLOT_ID_PREFIX) ||\n    slotId.startsWith(SLICE_SLOT_ID_PREFIX)\n  ) {\n    throw new Error('Element ID cannot be \"root\", \"route:*\" or \"slice:*\"');\n  }\n};\n\ntype RendererOption = { pathname: string; query: string | undefined };\n\ntype RouteConfig = {\n  type: 'route';\n  path: PathSpec;\n  isStatic: boolean;\n  pathPattern?: PathSpec;\n  rootElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  routeElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  elements: Record<\n    SlotId,\n    {\n      isStatic: boolean;\n      renderer: (option: RendererOption) => ReactNode;\n    }\n  >;\n  noSsr?: boolean;\n  slices?: string[];\n};\n\ntype ApiConfig = {\n  type: 'api';\n  path: PathSpec;\n  isStatic: boolean;\n  handler: (req: Request) => Promise<Response>;\n};\n\ntype SliceConfig = {\n  type: 'slice';\n  id: string;\n  isStatic: boolean;\n  renderer: () => Promise<ReactNode>;\n};\n\nconst getRouterPrefetchCode = (path2moduleIds: Record<string, string[]>) => {\n  const moduleIdSet = new Set<string>();\n  Object.values(path2moduleIds).forEach((ids) =>\n    ids.forEach((id) => moduleIdSet.add(id)),\n  );\n  const ids = Array.from(moduleIdSet);\n  const path2idxs: Record<string, number[]> = {};\n  Object.entries(path2moduleIds).forEach(([path, ids]) => {\n    path2idxs[path] = ids.map((id) => ids.indexOf(id));\n  });\n  return `\nglobalThis.__WAKU_ROUTER_PREFETCH__ = (path, callback) => {\n  const ids = ${JSON.stringify(ids)};\n  const path2idxs = ${JSON.stringify(path2idxs)};\n  const key = Object.keys(path2idxs).find((key) => new RegExp(key).test(path));\n  for (const idx of path2idxs[key] || []) {\n    callback(ids[idx]);\n  }\n};\n`;\n};\n\nexport function unstable_defineRouter(fns: {\n  getConfigs: () => Promise<Iterable<RouteConfig | ApiConfig | SliceConfig>>;\n}) {\n  // This is an internal type for caching\n  type MyConfig = {\n    configs: (RouteConfig | ApiConfig | SliceConfig)[];\n    has404: boolean;\n  };\n\n  let cachedMyConfig: MyConfig | undefined;\n  const getMyConfig = async (): Promise<MyConfig> => {\n    if (!cachedMyConfig) {\n      const configs = Array.from(await fns.getConfigs());\n      let has404 = false;\n      configs.forEach((item) => {\n        if (item.type === 'route') {\n          Object.keys(item.elements).forEach(assertNonReservedSlotId);\n          if (!has404 && is404(item.path)) {\n            has404 = true;\n          }\n        }\n      });\n      cachedMyConfig = { configs, has404 };\n    }\n    return cachedMyConfig;\n  };\n\n  const getPathConfigItem = async (pathname: string) => {\n    const myConfig = await getMyConfig();\n    const found = myConfig.configs.find(\n      (item): item is typeof item & { type: 'route' | 'api' } =>\n        (item.type === 'route' || item.type === 'api') &&\n        !!getPathMapping(item.path, pathname),\n    );\n    return found;\n  };\n\n  const getSliceElement = async (\n    sliceConfig: {\n      id: string;\n      isStatic: boolean;\n      renderer: () => Promise<ReactNode>;\n    },\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ): Promise<ReactNode> => {\n    const id = SLICE_SLOT_ID_PREFIX + sliceConfig.id;\n    const cached = getCachedElement(id);\n    if (cached) {\n      return cached;\n    }\n    let element = await sliceConfig.renderer();\n    if (sliceConfig.isStatic) {\n      element = await setCachedElement(id, element);\n    }\n    return element;\n  };\n\n  const getEntriesForRoute = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ) => {\n    setRscPath(rscPath);\n    setRscParams(rscParams);\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (pathConfigItem?.type !== 'route') {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const decodedPathname = decodeURI(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    const option: RendererOption = {\n      pathname: decodedPathname,\n      query: pathConfigItem.isStatic ? undefined : query,\n    };\n    const myConfig = await getMyConfig();\n    const slices = pathConfigItem.slices || [];\n    const sliceConfigMap = new Map<\n      string,\n      { id: string; isStatic: boolean; renderer: () => Promise<ReactNode> }\n    >();\n    slices.forEach((sliceId) => {\n      const sliceConfig = myConfig.configs.find(\n        (item): item is typeof item & { type: 'slice' } =>\n          item.type === 'slice' && item.id === sliceId,\n      );\n      if (sliceConfig) {\n        sliceConfigMap.set(sliceId, sliceConfig);\n      }\n    });\n    const entries: Record<SlotId, unknown> = {};\n    await Promise.all([\n      (async () => {\n        if (!pathConfigItem.rootElement.isStatic) {\n          entries[ROOT_SLOT_ID] = pathConfigItem.rootElement.renderer(option);\n        } else if (!skipIdSet.has(ROOT_SLOT_ID)) {\n          const cached = getCachedElement(ROOT_SLOT_ID);\n          entries[ROOT_SLOT_ID] = cached\n            ? await cached\n            : await setCachedElement(\n                ROOT_SLOT_ID,\n                pathConfigItem.rootElement.renderer(option),\n              );\n        }\n      })(),\n      (async () => {\n        if (!pathConfigItem.routeElement.isStatic) {\n          entries[routeId] = pathConfigItem.routeElement.renderer(option);\n        } else if (!skipIdSet.has(routeId)) {\n          const cached = getCachedElement(routeId);\n          entries[routeId] = cached\n            ? await cached\n            : await setCachedElement(\n                routeId,\n                pathConfigItem.routeElement.renderer(option),\n              );\n        }\n      })(),\n      ...Object.entries(pathConfigItem.elements).map(\n        async ([id, { isStatic }]) => {\n          const renderer = pathConfigItem.elements[id]?.renderer;\n          if (!isStatic) {\n            entries[id] = renderer?.(option);\n          } else if (!skipIdSet.has(id)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached\n              ? await cached\n              : await setCachedElement(id, renderer?.(option));\n          }\n        },\n      ),\n      ...slices.map(async (sliceId) => {\n        const id = SLICE_SLOT_ID_PREFIX + sliceId;\n        const sliceConfig = sliceConfigMap.get(sliceId);\n        if (!sliceConfig) {\n          throw new Error(`Slice not found: ${sliceId}`);\n        }\n        if (sliceConfig.isStatic && skipIdSet.has(id)) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        entries[id] = sliceElement;\n      }),\n    ]);\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = pathConfigItem.isStatic;\n    sliceConfigMap.forEach((sliceConfig, sliceId) => {\n      if (sliceConfig.isStatic) {\n        // FIXME: hard-coded for now\n        entries[IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId] = true;\n      }\n    });\n    if (myConfig.has404) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineHandlers>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineHandlers>[0]['handleBuild'];\n\n  const cachedElementsForRequest = new Map<SlotId, Promise<ReactNode>>();\n  let cachedElementsForRequestInitialized = false;\n  let cachedPath2moduleIds: Record<string, string[]> | undefined;\n\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, parseRsc, renderHtml, loadBuildMetadata },\n  ): Promise<ReadableStream | Response | 'fallback' | null | undefined> => {\n    const getCachedElement = (id: SlotId) => cachedElementsForRequest.get(id);\n    const setCachedElement = (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForRequest.get(id);\n      if (cached) {\n        return cached;\n      }\n      const copied = renderRsc({ [id]: element }).then((rscStream) =>\n        parseRsc(rscStream).then((parsed) => parsed[id]),\n      ) as Promise<ReactNode>;\n      cachedElementsForRequest.set(id, copied);\n      return copied;\n    };\n    if (!cachedElementsForRequestInitialized) {\n      cachedElementsForRequestInitialized = true;\n      const cachedElementsMetadata = await loadBuildMetadata(\n        'defineRouter:cachedElements',\n      );\n      if (cachedElementsMetadata) {\n        Object.entries(JSON.parse(cachedElementsMetadata)).forEach(\n          ([id, str]) => {\n            cachedElementsForRequest.set(\n              id,\n              parseRsc(base64ToStream(str as string)).then(\n                (parsed) => parsed[id],\n              ) as Promise<ReactNode>,\n            );\n          },\n        );\n      }\n    }\n    const getPath2moduleIds = async () => {\n      if (!cachedPath2moduleIds) {\n        cachedPath2moduleIds = JSON.parse(\n          (await loadBuildMetadata('defineRouter:path2moduleIds')) || '{}',\n        );\n      }\n      return cachedPath2moduleIds!;\n    };\n\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.type === 'api') {\n      const url = new URL(input.req.url);\n      url.pathname = input.pathname;\n      const req = new Request(url, input.req);\n      return pathConfigItem.handler(req);\n    }\n\n    const url = new URL(input.req.url);\n    const headers = Object.fromEntries(input.req.headers.entries());\n    if (input.type === 'component') {\n      const sliceId = decodeSliceId(input.rscPath);\n      if (sliceId !== null) {\n        // LIMITATION: This is a signle slice request.\n        // Ideally, we should be able to respond with multiple slices in one request.\n        const sliceConfig = await getMyConfig().then((myConfig) =>\n          myConfig.configs.find(\n            (item): item is typeof item & { type: 'slice' } =>\n              item.type === 'slice' && item.id === sliceId,\n          ),\n        );\n        if (!sliceConfig) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        return renderRsc({\n          [SLICE_SLOT_ID_PREFIX + sliceId]: sliceElement,\n          ...(sliceConfig.isStatic\n            ? {\n                // FIXME: hard-coded for now\n                [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId]: true,\n              }\n            : {}),\n        });\n      }\n      const entries = await getEntriesForRoute(\n        input.rscPath,\n        input.rscParams,\n        headers,\n        getCachedElement,\n        setCachedElement,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntriesForRoute(\n            rscPath,\n            rscParams,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          ),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      try {\n        const value = await input.fn(...input.args);\n        return renderRsc({ ...(await elementsPromise), _value: value });\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.location) {\n          const rscPath = encodeRoutePath(info.location);\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            unstable_notFound();\n          }\n          return renderRsc(entries);\n        }\n        throw e;\n      } finally {\n        rendered = true;\n      }\n    }\n\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (\n        pathname: string,\n        query: string,\n        httpstatus = 200,\n      ) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntriesForRoute(\n          rscPath,\n          rscParams,\n          headers,\n          getCachedElement,\n          setCachedElement,\n        );\n        if (!entries) {\n          return null;\n        }\n        const path2moduleIds = await getPath2moduleIds();\n        const html = (\n          <INTERNAL_ServerRouter\n            route={{ path: pathname, query, hash: '' }}\n            httpstatus={httpstatus}\n          />\n        );\n        const formState =\n          input.type === 'action' ? await input.fn() : undefined;\n        const nonce = getNonce();\n        return renderHtml(await renderRsc(entries), html, {\n          rscPath,\n          formState,\n          status: httpstatus,\n          ...(nonce ? { nonce } : {}),\n          unstable_extraScriptContent: getRouterPrefetchCode(path2moduleIds),\n        });\n      };\n      const query = url.searchParams.toString();\n      if (pathConfigItem?.type === 'route' && pathConfigItem.noSsr) {\n        return 'fallback';\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if ((await getMyConfig()).has404) {\n        return renderIt('/404', '', 404);\n      } else {\n        return null;\n      }\n    }\n  };\n\n  const handleBuild: HandleBuild = async ({\n    renderRsc,\n    parseRsc,\n    renderHtml,\n    rscPath2pathname,\n    saveBuildMetadata,\n    withRequest,\n    generateFile,\n    generateDefaultHtml,\n  }) => {\n    const myConfig = await getMyConfig();\n    const cachedElementsForBuild = new Map<SlotId, Promise<ReactNode>>();\n    const serializedCachedElements = new Map<SlotId, string>();\n    const getCachedElement = (id: SlotId) => cachedElementsForBuild.get(id);\n    const setCachedElement = async (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForBuild.get(id);\n      if (cached) {\n        return cached;\n      }\n      const teedStream = renderRsc({ [id]: element }).then((rscStream) =>\n        rscStream.tee(),\n      );\n      const stream1 = teedStream.then(([s1]) => s1);\n      const stream2 = teedStream.then(([, s2]) => s2);\n      const copied = stream1.then(\n        (rscStream) =>\n          parseRsc(rscStream).then(\n            (parsed) => parsed[id],\n          ) as Promise<ReactNode>,\n      );\n      cachedElementsForBuild.set(id, copied);\n      serializedCachedElements.set(id, await streamToBase64(await stream2));\n      return copied;\n    };\n\n    // hard-coded concurrency limit\n    const { runTask, waitForTasks } = createTaskRunner(500);\n\n    // static api\n    for (const item of myConfig.configs) {\n      if (item.type !== 'api') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const res = await item.handler(req);\n          await generateFile(pathname, res.body || '');\n        });\n      });\n    }\n\n    const path2moduleIds: Record<string, string[]> = {};\n    const htmlRenderTasks = new Set<() => Promise<void>>();\n\n    // static route\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const rscPath = encodeRoutePath(pathname);\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            {},\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            return;\n          }\n          for (const id of Object.keys(entries)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached ? await cached : entries[id];\n          }\n          const moduleIds = new Set<string>();\n          const stream = await renderRsc(entries, {\n            unstable_clientModuleCallback: (ids) =>\n              ids.forEach((id) => moduleIds.add(id)),\n          });\n          const [stream1, stream2] = stream.tee();\n          await generateFile(rscPath2pathname(rscPath), stream1);\n          path2moduleIds[path2regexp(item.pathPattern || item.path)] =\n            Array.from(moduleIds);\n          htmlRenderTasks.add(async () => {\n            const html = (\n              <INTERNAL_ServerRouter\n                route={{ path: pathname, query: '', hash: '' }}\n                httpstatus={is404(item.path) ? 404 : 200}\n              />\n            );\n            const res = await renderHtml(stream2, html, {\n              rscPath,\n              unstable_extraScriptContent:\n                getRouterPrefetchCode(path2moduleIds),\n            });\n            await generateFile(htmlPath2pathname(pathname), res.body || '');\n          });\n        });\n      });\n    }\n    // HACK hopefully there is a better way than this\n    await waitForTasks();\n    htmlRenderTasks.forEach(runTask);\n\n    // default html\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (item.noSsr) {\n        const pathname = pathSpec2pathname(item.path);\n        if (!pathname) {\n          throw new Error('Pathname is required for noSsr routes on build');\n        }\n        runTask(async () => {\n          await generateDefaultHtml(htmlPath2pathname(pathname));\n        });\n      }\n    }\n\n    // static slice\n    for (const item of myConfig.configs) {\n      if (item.type !== 'slice') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const rscPath = encodeSliceId(item.id);\n      // dummy req for slice which is not determined at build time\n      const req = new Request(new URL('http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const sliceElement = await getSliceElement(\n            item,\n            getCachedElement,\n            setCachedElement,\n          );\n          const body = await renderRsc({\n            [SLICE_SLOT_ID_PREFIX + item.id]: sliceElement,\n            // FIXME: hard-coded for now\n            [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + item.id]: true,\n          });\n          await generateFile(rscPath2pathname(rscPath), body);\n        });\n      });\n    }\n\n    await waitForTasks();\n\n    // TODO should we save serialized cached elements separately?\n    await saveBuildMetadata(\n      'defineRouter:cachedElements',\n      JSON.stringify(Object.fromEntries(serializedCachedElements)),\n    );\n    await saveBuildMetadata(\n      'defineRouter:path2moduleIds',\n      JSON.stringify(path2moduleIds),\n    );\n  };\n\n  return Object.assign(defineHandlers({ handleRequest, handleBuild }), {\n    unstable_getRouterConfigs: () => getMyConfig().then((c) => c.configs),\n  });\n}\n"],"names":["createCustomError","getErrorInfo","getPathMapping","path2regexp","base64ToStream","streamToBase64","createTaskRunner","unstable_defineHandlers","defineHandlers","unstable_getContext","getContext","INTERNAL_ServerRouter","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","decodeRoutePath","decodeSliceId","encodeRoutePath","encodeSliceId","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RSC_PATH_SYMBOL","Symbol","RSC_PARAMS_SYMBOL","setRscPath","rscPath","context","setRscParams","unstable_getRscPath","undefined","unstable_getRscParams","getNonce","nonce","RERENDER_SYMBOL","setRerender","rerender","getRerender","is404","pathSpec","length","type","name","pathSpec2pathname","some","map","join","htmlPath2pathname","htmlPath","unstable_rerenderRoute","pathname","unstable_notFound","status","unstable_redirect","location","ROOT_SLOT_ID","ROUTE_SLOT_ID_PREFIX","SLICE_SLOT_ID_PREFIX","assertNonReservedSlotId","slotId","startsWith","Error","getRouterPrefetchCode","path2moduleIds","moduleIdSet","Set","Object","values","forEach","ids","id","add","from","path2idxs","entries","path","indexOf","JSON","stringify","unstable_defineRouter","fns","cachedMyConfig","getMyConfig","configs","getConfigs","has404","item","keys","elements","getPathConfigItem","myConfig","found","find","getSliceElement","sliceConfig","getCachedElement","setCachedElement","cached","element","renderer","isStatic","getEntriesForRoute","headers","pathConfigItem","skipParam","parse","toLowerCase","skipIdSet","decodedPathname","decodeURI","routeId","option","slices","sliceConfigMap","Map","sliceId","set","Promise","all","rootElement","has","routeElement","sliceElement","cachedElementsForRequest","cachedElementsForRequestInitialized","cachedPath2moduleIds","handleRequest","input","renderRsc","parseRsc","renderHtml","loadBuildMetadata","copied","then","rscStream","parsed","cachedElementsMetadata","str","getPath2moduleIds","url","URL","req","Request","handler","fromEntries","elementsPromise","resolve","rendered","oldElements","newElements","console","warn","value","fn","args","_value","e","info","renderIt","httpstatus","html","route","hash","formState","unstable_extraScriptContent","searchParams","toString","noSsr","handleBuild","rscPath2pathname","saveBuildMetadata","withRequest","generateFile","generateDefaultHtml","cachedElementsForBuild","serializedCachedElements","teedStream","tee","stream1","s1","stream2","s2","runTask","waitForTasks","res","body","htmlRenderTasks","moduleIds","stream","unstable_clientModuleCallback","pathPattern","assign","unstable_getRouterConfigs","c"],"mappings":"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"}

diff --git a/dist/adapters/aws-lambda.js b/dist/adapters/aws-lambda.js
index f2212fd15f7cb941fb5aa0f7d45edae8033375e6..c48bb85e2bbddb5ecedb9f31db877f05c72324d5 100644
--- a/dist/adapters/aws-lambda.js
+++ b/dist/adapters/aws-lambda.js
@@ -1,7 +1,7 @@
 import path from 'node:path';
 import { serveStatic } from '@hono/node-server/serve-static';
-import { Hono } from 'hono';
 import * as honoAwsLambda from 'hono/aws-lambda';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/aws-lambda.js.map b/dist/adapters/aws-lambda.js.map
index 9e3a9ace286af0a442115a5afd6e119053ce4db8..b3fb2b20c692297f3ef1dc594100981ce64e6328 100644
--- a/dist/adapters/aws-lambda.js.map
+++ b/dist/adapters/aws-lambda.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/aws-lambda.ts"],"sourcesContent":["import path from 'node:path';\nimport { serveStatic } from '@hono/node-server/serve-static';\nimport { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport * as honoAwsLambda from 'hono/aws-lambda';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './aws-lambda-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      streaming?: boolean;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(serveStatic({ root: path.join(config.distDir, DIST_PUBLIC) }));\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    (globalThis as any).__WAKU_AWS_LAMBDA_HANDLE__ = options?.streaming\n      ? honoAwsLambda.streamHandle\n      : honoAwsLambda.handle;\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/aws-lambda-build-enhancer'],\n    };\n  },\n);\n"],"names":["path","serveStatic","Hono","honoAwsLambda","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","root","join","distDir","middlewareFn","buildOptions","globalThis","__WAKU_AWS_LAMBDA_HANDLE__","streaming","streamHandle","handle","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAC7B,SAASC,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,IAAI,QAAQ,OAAO;AAE5B,YAAYC,mBAAmB,kBAAkB;AACjD,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAMA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIpB;IAChBoB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CAAC1B,YAAY;YAAE2B,MAAM5B,KAAK6B,IAAI,CAACb,OAAOc,OAAO,EAAEpB;QAAa;IACrE;IACAY,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMoB,gBAAgBX,cAAe;QACxCE,IAAIK,GAAG,CAACI;IACV;IACAT,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMkB,eAA6B;QACjCF,SAASd,OAAOc,OAAO;IACzB;IACCG,WAAmBC,0BAA0B,GAAGf,SAASgB,YACtDhC,cAAciC,YAAY,GAC1BjC,cAAckC,MAAM;IACxB,OAAO;QACLC,OAAOhB,IAAIgB,KAAK;QAChBC,OAAOxB;QACPiB;QACAQ,gBAAgB;YAAC;SAA0C;IAC7D;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/aws-lambda.ts"],"sourcesContent":["import path from 'node:path';\nimport { serveStatic } from '@hono/node-server/serve-static';\nimport type { MiddlewareHandler } from 'hono';\nimport * as honoAwsLambda from 'hono/aws-lambda';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './aws-lambda-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      streaming?: boolean;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(serveStatic({ root: path.join(config.distDir, DIST_PUBLIC) }));\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    (globalThis as any).__WAKU_AWS_LAMBDA_HANDLE__ = options?.streaming\n      ? honoAwsLambda.streamHandle\n      : honoAwsLambda.handle;\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/aws-lambda-build-enhancer'],\n    };\n  },\n);\n"],"names":["path","serveStatic","honoAwsLambda","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","root","join","distDir","middlewareFn","buildOptions","globalThis","__WAKU_AWS_LAMBDA_HANDLE__","streaming","streamHandle","handle","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAC7B,SAASC,WAAW,QAAQ,iCAAiC;AAE7D,YAAYC,mBAAmB,kBAAkB;AACjD,SAASC,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAMA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAInB;IAChBmB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CAAC1B,YAAY;YAAE2B,MAAM5B,KAAK6B,IAAI,CAACb,OAAOc,OAAO,EAAEpB;QAAa;IACrE;IACAY,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMoB,gBAAgBX,cAAe;QACxCE,IAAIK,GAAG,CAACI;IACV;IACAT,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMkB,eAA6B;QACjCF,SAASd,OAAOc,OAAO;IACzB;IACCG,WAAmBC,0BAA0B,GAAGf,SAASgB,YACtDjC,cAAckC,YAAY,GAC1BlC,cAAcmC,MAAM;IACxB,OAAO;QACLC,OAAOhB,IAAIgB,KAAK;QAChBC,OAAOxB;QACPiB;QACAQ,gBAAgB;YAAC;SAA0C;IAC7D;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/bun.js b/dist/adapters/bun.js
index 9fe2adb5b0f2fafd7e4cb04da9f3a6de895c8d22..2e1be51d1f3e7035773d525d76c055a2bf72eb9e 100644
--- a/dist/adapters/bun.js
+++ b/dist/adapters/bun.js
@@ -1,6 +1,6 @@
 import path from 'node:path';
-import { Hono } from 'hono';
 import { serveStatic } from 'hono/bun';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/bun.js.map b/dist/adapters/bun.js.map
index 63b13c5e1d790a85637168ab5c6d634232b9b99b..ad1754f0ae927426de2655d52373ed7a963c1dc3 100644
--- a/dist/adapters/bun.js.map
+++ b/dist/adapters/bun.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/bun.ts"],"sourcesContent":["import path from 'node:path';\nimport { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport { serveStatic } from 'hono/bun';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './bun-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(\n        `${config.basePath}*`,\n        serveStatic({\n          root: path.join(config.distDir, DIST_PUBLIC),\n          rewriteRequestPath: (path) => path.slice(config.basePath.length - 1),\n        }),\n      );\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/bun-build-enhancer'],\n    };\n  },\n);\n"],"names":["path","Hono","serveStatic","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","basePath","root","join","distDir","rewriteRequestPath","slice","length","middlewareFn","buildOptions","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAC7B,SAASC,IAAI,QAAQ,OAAO;AAE5B,SAASC,WAAW,QAAQ,WAAW;AACvC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIpB;IAChBoB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CACL,GAAGX,OAAOY,QAAQ,CAAC,CAAC,CAAC,EACrBzB,YAAY;YACV0B,MAAM5B,KAAK6B,IAAI,CAACd,OAAOe,OAAO,EAAErB;YAChCsB,oBAAoB,CAAC/B,OAASA,KAAKgC,KAAK,CAACjB,OAAOY,QAAQ,CAACM,MAAM,GAAG;QACpE;IAEJ;IACAZ,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMwB,gBAAgBf,cAAe;QACxCE,IAAIK,GAAG,CAACQ;IACV;IACAb,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMsB,eAA6B;QACjCL,SAASf,OAAOe,OAAO;IACzB;IACA,OAAO;QACLM,OAAOf,IAAIe,KAAK;QAChBC,OAAOvB;QACPqB;QACAG,gBAAgB;YAAC;SAAmC;IACtD;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/bun.ts"],"sourcesContent":["import path from 'node:path';\nimport type { MiddlewareHandler } from 'hono';\nimport { serveStatic } from 'hono/bun';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './bun-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(\n        `${config.basePath}*`,\n        serveStatic({\n          root: path.join(config.distDir, DIST_PUBLIC),\n          rewriteRequestPath: (path) => path.slice(config.basePath.length - 1),\n        }),\n      );\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/bun-build-enhancer'],\n    };\n  },\n);\n"],"names":["path","serveStatic","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","basePath","root","join","distDir","rewriteRequestPath","slice","length","middlewareFn","buildOptions","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAE7B,SAASC,WAAW,QAAQ,WAAW;AACvC,SAASC,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAInB;IAChBmB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CACL,GAAGX,OAAOY,QAAQ,CAAC,CAAC,CAAC,EACrB1B,YAAY;YACV2B,MAAM5B,KAAK6B,IAAI,CAACd,OAAOe,OAAO,EAAErB;YAChCsB,oBAAoB,CAAC/B,OAASA,KAAKgC,KAAK,CAACjB,OAAOY,QAAQ,CAACM,MAAM,GAAG;QACpE;IAEJ;IACAZ,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMwB,gBAAgBf,cAAe;QACxCE,IAAIK,GAAG,CAACQ;IACV;IACAb,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMsB,eAA6B;QACjCL,SAASf,OAAOe,OAAO;IACzB;IACA,OAAO;QACLM,OAAOf,IAAIe,KAAK;QAChBC,OAAOvB;QACPqB;QACAG,gBAAgB;YAAC;SAAmC;IACtD;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/cloudflare.js b/dist/adapters/cloudflare.js
index a78ebfe5618467f497f01c15d6a17cd95730a2fd..771508125b39637c8ef8639b05546c9657a7eb1d 100644
--- a/dist/adapters/cloudflare.js
+++ b/dist/adapters/cloudflare.js
@@ -1,4 +1,4 @@
-import { Hono } from 'hono';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/cloudflare.js.map b/dist/adapters/cloudflare.js.map
index 028d7ba7e97c86d330a4bfadd147f1457ff047b4..82d2cbb58ad4bd09c2552b546d2462fc4c7ac9c2 100644
--- a/dist/adapters/cloudflare.js.map
+++ b/dist/adapters/cloudflare.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/cloudflare.ts"],"sourcesContent":["import { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './cloudflare-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nfunction isWranglerDev(req: Request): boolean {\n  // This header seems to only be set for production cloudflare workers\n  return !req.headers.get('cf-visitor');\n}\n\nfunction removeGzipEncoding(res: Response): Response {\n  const contentType = res.headers.get('content-type');\n  if (\n    !contentType ||\n    contentType.includes('text/html') ||\n    contentType.includes('text/plain')\n  ) {\n    const headers = new Headers(res.headers);\n    headers.set('content-encoding', 'Identity');\n    return new Response(res.body, {\n      status: res.status,\n      statusText: res.statusText,\n      headers,\n    });\n  }\n  return res;\n}\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      handlers?: Record<string, unknown>;\n      assetsDir?: string;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      assetsDir: options?.assetsDir || 'assets',\n      distDir: config.distDir,\n      privateDir: config.privateDir,\n      rscBase: config.rscBase,\n      basePath: config.basePath,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n\n    return {\n      fetch: async (req: Request) => {\n        let cloudflareContext;\n        try {\n          // @ts-expect-error - available when running in a Cloudflare environment\n          // eslint-disable-next-line import/no-unresolved\n          cloudflareContext = await import('cloudflare:workers');\n        } catch {\n          // Not in a Cloudflare environment\n        }\n        let res: Response | Promise<Response>;\n        if (cloudflareContext) {\n          const { env, waitUntil, passThroughOnException } = cloudflareContext;\n          res = app.fetch(req, env, {\n            waitUntil,\n            passThroughOnException,\n            props: undefined,\n          });\n        } else {\n          res = app.fetch(req);\n        }\n        // Workaround https://github.com/cloudflare/workers-sdk/issues/6577\n        if (import.meta.env?.PROD && isWranglerDev(req)) {\n          if ('then' in res) {\n            res = res.then((res) => removeGzipEncoding(res));\n          } else {\n            res = removeGzipEncoding(res);\n          }\n        }\n        return res;\n      },\n      handlers: options?.handlers,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/cloudflare-build-enhancer'],\n    };\n  },\n);\n"],"names":["Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","isWranglerDev","req","headers","get","removeGzipEncoding","res","contentType","includes","Headers","set","Response","body","status","statusText","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","assetsDir","distDir","privateDir","rscBase","basePath","serverless","static","fetch","cloudflareContext","env","waitUntil","passThroughOnException","props","undefined","PROD","then","handlers","build","buildEnhancers"],"mappings":"AAAA,SAASA,IAAI,QAAQ,OAAO;AAE5B,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,SAASK,cAAcC,GAAY;IACjC,qEAAqE;IACrE,OAAO,CAACA,IAAIC,OAAO,CAACC,GAAG,CAAC;AAC1B;AAEA,SAASC,mBAAmBC,GAAa;IACvC,MAAMC,cAAcD,IAAIH,OAAO,CAACC,GAAG,CAAC;IACpC,IACE,CAACG,eACDA,YAAYC,QAAQ,CAAC,gBACrBD,YAAYC,QAAQ,CAAC,eACrB;QACA,MAAML,UAAU,IAAIM,QAAQH,IAAIH,OAAO;QACvCA,QAAQO,GAAG,CAAC,oBAAoB;QAChC,OAAO,IAAIC,SAASL,IAAIM,IAAI,EAAE;YAC5BC,QAAQP,IAAIO,MAAM;YAClBC,YAAYR,IAAIQ,UAAU;YAC1BX;QACF;IACF;IACA,OAAOG;AACT;AAEA,eAAeZ,yBACb,CACE,EAAEqB,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAQA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIhC;IAChBgC,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAAC7B;IACR,KAAK,MAAM8B,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAAC3B,iBAAiBqB;IACzBC,IAAIK,GAAG,CAAC5B,cAAc;QAAEgB;IAAe;IACvC,MAAMc,eAA6B;QACjCC,WAAWX,SAASW,aAAa;QACjCC,SAASd,OAAOc,OAAO;QACvBC,YAAYf,OAAOe,UAAU;QAC7BC,SAAShB,OAAOgB,OAAO;QACvBC,UAAUjB,OAAOiB,QAAQ;QACzBrC;QACAsC,YAAY,CAAChB,SAASiB;IACxB;IAEA,OAAO;QACLC,OAAO,OAAOnC;YACZ,IAAIoC;YACJ,IAAI;gBACF,wEAAwE;gBACxE,gDAAgD;gBAChDA,oBAAoB,MAAM,MAAM,CAAC;YACnC,EAAE,OAAM;YACN,kCAAkC;YACpC;YACA,IAAIhC;YACJ,IAAIgC,mBAAmB;gBACrB,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAEC,sBAAsB,EAAE,GAAGH;gBACnDhC,MAAMgB,IAAIe,KAAK,CAACnC,KAAKqC,KAAK;oBACxBC;oBACAC;oBACAC,OAAOC;gBACT;YACF,OAAO;gBACLrC,MAAMgB,IAAIe,KAAK,CAACnC;YAClB;YACA,mEAAmE;YACnE,IAAI,YAAYqC,GAAG,EAAEK,QAAQ3C,cAAcC,MAAM;gBAC/C,IAAI,UAAUI,KAAK;oBACjBA,MAAMA,IAAIuC,IAAI,CAAC,CAACvC,MAAQD,mBAAmBC;gBAC7C,OAAO;oBACLA,MAAMD,mBAAmBC;gBAC3B;YACF;YACA,OAAOA;QACT;QACAwC,UAAU3B,SAAS2B;QACnBC,OAAO/B;QACPa;QACAmB,gBAAgB;YAAC;SAA0C;IAC7D;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/cloudflare.ts"],"sourcesContent":["import type { MiddlewareHandler } from 'hono';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './cloudflare-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nfunction isWranglerDev(req: Request): boolean {\n  // This header seems to only be set for production cloudflare workers\n  return !req.headers.get('cf-visitor');\n}\n\nfunction removeGzipEncoding(res: Response): Response {\n  const contentType = res.headers.get('content-type');\n  if (\n    !contentType ||\n    contentType.includes('text/html') ||\n    contentType.includes('text/plain')\n  ) {\n    const headers = new Headers(res.headers);\n    headers.set('content-encoding', 'Identity');\n    return new Response(res.body, {\n      status: res.status,\n      statusText: res.statusText,\n      headers,\n    });\n  }\n  return res;\n}\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      handlers?: Record<string, unknown>;\n      assetsDir?: string;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      assetsDir: options?.assetsDir || 'assets',\n      distDir: config.distDir,\n      privateDir: config.privateDir,\n      rscBase: config.rscBase,\n      basePath: config.basePath,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n\n    return {\n      fetch: async (req: Request) => {\n        let cloudflareContext;\n        try {\n          // @ts-expect-error - available when running in a Cloudflare environment\n          // eslint-disable-next-line import/no-unresolved\n          cloudflareContext = await import('cloudflare:workers');\n        } catch {\n          // Not in a Cloudflare environment\n        }\n        let res: Response | Promise<Response>;\n        if (cloudflareContext) {\n          const { env, waitUntil, passThroughOnException } = cloudflareContext;\n          res = app.fetch(req, env, {\n            waitUntil,\n            passThroughOnException,\n            props: undefined,\n          });\n        } else {\n          res = app.fetch(req);\n        }\n        // Workaround https://github.com/cloudflare/workers-sdk/issues/6577\n        if (import.meta.env?.PROD && isWranglerDev(req)) {\n          if ('then' in res) {\n            res = res.then((res) => removeGzipEncoding(res));\n          } else {\n            res = removeGzipEncoding(res);\n          }\n        }\n        return res;\n      },\n      handlers: options?.handlers,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/cloudflare-build-enhancer'],\n    };\n  },\n);\n"],"names":["Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","isWranglerDev","req","headers","get","removeGzipEncoding","res","contentType","includes","Headers","set","Response","body","status","statusText","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","assetsDir","distDir","privateDir","rscBase","basePath","serverless","static","fetch","cloudflareContext","env","waitUntil","passThroughOnException","props","undefined","PROD","then","handlers","build","buildEnhancers"],"mappings":"AACA,SAASA,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,SAASK,cAAcC,GAAY;IACjC,qEAAqE;IACrE,OAAO,CAACA,IAAIC,OAAO,CAACC,GAAG,CAAC;AAC1B;AAEA,SAASC,mBAAmBC,GAAa;IACvC,MAAMC,cAAcD,IAAIH,OAAO,CAACC,GAAG,CAAC;IACpC,IACE,CAACG,eACDA,YAAYC,QAAQ,CAAC,gBACrBD,YAAYC,QAAQ,CAAC,eACrB;QACA,MAAML,UAAU,IAAIM,QAAQH,IAAIH,OAAO;QACvCA,QAAQO,GAAG,CAAC,oBAAoB;QAChC,OAAO,IAAIC,SAASL,IAAIM,IAAI,EAAE;YAC5BC,QAAQP,IAAIO,MAAM;YAClBC,YAAYR,IAAIQ,UAAU;YAC1BX;QACF;IACF;IACA,OAAOG;AACT;AAEA,eAAeZ,yBACb,CACE,EAAEqB,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAQA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIhC;IAChBgC,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAAC7B;IACR,KAAK,MAAM8B,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAAC3B,iBAAiBqB;IACzBC,IAAIK,GAAG,CAAC5B,cAAc;QAAEgB;IAAe;IACvC,MAAMc,eAA6B;QACjCC,WAAWX,SAASW,aAAa;QACjCC,SAASd,OAAOc,OAAO;QACvBC,YAAYf,OAAOe,UAAU;QAC7BC,SAAShB,OAAOgB,OAAO;QACvBC,UAAUjB,OAAOiB,QAAQ;QACzBrC;QACAsC,YAAY,CAAChB,SAASiB;IACxB;IAEA,OAAO;QACLC,OAAO,OAAOnC;YACZ,IAAIoC;YACJ,IAAI;gBACF,wEAAwE;gBACxE,gDAAgD;gBAChDA,oBAAoB,MAAM,MAAM,CAAC;YACnC,EAAE,OAAM;YACN,kCAAkC;YACpC;YACA,IAAIhC;YACJ,IAAIgC,mBAAmB;gBACrB,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAEC,sBAAsB,EAAE,GAAGH;gBACnDhC,MAAMgB,IAAIe,KAAK,CAACnC,KAAKqC,KAAK;oBACxBC;oBACAC;oBACAC,OAAOC;gBACT;YACF,OAAO;gBACLrC,MAAMgB,IAAIe,KAAK,CAACnC;YAClB;YACA,mEAAmE;YACnE,IAAI,YAAYqC,GAAG,EAAEK,QAAQ3C,cAAcC,MAAM;gBAC/C,IAAI,UAAUI,KAAK;oBACjBA,MAAMA,IAAIuC,IAAI,CAAC,CAACvC,MAAQD,mBAAmBC;gBAC7C,OAAO;oBACLA,MAAMD,mBAAmBC;gBAC3B;YACF;YACA,OAAOA;QACT;QACAwC,UAAU3B,SAAS2B;QACnBC,OAAO/B;QACPa;QACAmB,gBAAgB;YAAC;SAA0C;IAC7D;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/edge.js b/dist/adapters/edge.js
index 94462a46a40844bb3d9f4fe399db7e373a674599..6aed6422b92f52f7e1e53c8a1125afdae8c796fa 100644
--- a/dist/adapters/edge.js
+++ b/dist/adapters/edge.js
@@ -1,4 +1,4 @@
-import { Hono } from 'hono';
+import { Hono } from 'hono/tiny';
 import { unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
 export default createServerEntryAdapter(({ processRequest, processBuild, notFoundHtml }, options)=>{
diff --git a/dist/adapters/edge.js.map b/dist/adapters/edge.js.map
index 69e4da721570e05f953a6f8719f379df3de2be79..19da0047babee0283434e85fd3892b00c9fe372a 100644
--- a/dist/adapters/edge.js.map
+++ b/dist/adapters/edge.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/edge.ts"],"sourcesContent":["import { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport type { ImportGlobFunction } from 'vite/types/importGlob.d.ts';\nimport {\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\n\ndeclare global {\n  interface ImportMeta {\n    glob: ImportGlobFunction;\n  }\n}\n\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n    };\n  },\n);\n"],"names":["Hono","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","fetch","build"],"mappings":"AAAA,SAASA,IAAI,QAAQ,OAAO;AAG5B,SACEC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAQxB,MAAM,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGH;AAE/D,eAAeF,yBACb,CACE,EAAEM,cAAc,EAAEC,YAAY,EAAEC,YAAY,EAAE,EAC9CC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAId;IAChBc,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACd;IACR,KAAK,MAAMe,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACZ,iBAAiBM;IACzBC,IAAIK,GAAG,CAACb,cAAc;QAAEE;IAAe;IACvC,OAAO;QACLa,OAAOP,IAAIO,KAAK;QAChBC,OAAOb;IACT;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/edge.ts"],"sourcesContent":["import type { MiddlewareHandler } from 'hono';\nimport { Hono } from 'hono/tiny';\nimport type { ImportGlobFunction } from 'vite/types/importGlob.d.ts';\nimport {\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\n\ndeclare global {\n  interface ImportMeta {\n    glob: ImportGlobFunction;\n  }\n}\n\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n    };\n  },\n);\n"],"names":["Hono","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","fetch","build"],"mappings":"AACA,SAASA,IAAI,QAAQ,YAAY;AAEjC,SACEC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAQxB,MAAM,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGH;AAE/D,eAAeF,yBACb,CACE,EAAEM,cAAc,EAAEC,YAAY,EAAEC,YAAY,EAAE,EAC9CC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAId;IAChBc,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACd;IACR,KAAK,MAAMe,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACZ,iBAAiBM;IACzBC,IAAIK,GAAG,CAACb,cAAc;QAAEE;IAAe;IACvC,OAAO;QACLa,OAAOP,IAAIO,KAAK;QAChBC,OAAOb;IACT;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/netlify.js b/dist/adapters/netlify.js
index 174feb8eca4f19c95fbaa0d66d7aa8e5fc7b7c5d..0130e7e8554eb69713b9d305b1fcab365fb903d9 100644
--- a/dist/adapters/netlify.js
+++ b/dist/adapters/netlify.js
@@ -1,4 +1,4 @@
-import { Hono } from 'hono';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/netlify.js.map b/dist/adapters/netlify.js.map
index 77d90520ff00a92af66ef9431241168140462b12..fd2daecbc9761dfb34f6052d5d13c0b3c2bc1ca9 100644
--- a/dist/adapters/netlify.js.map
+++ b/dist/adapters/netlify.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/netlify.ts"],"sourcesContent":["import { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './netlify-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n      privateDir: config.privateDir,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/netlify-build-enhancer'],\n    };\n  },\n);\n"],"names":["Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","distDir","privateDir","serverless","static","fetch","build","buildEnhancers"],"mappings":"AAAA,SAASA,IAAI,QAAQ,OAAO;AAE5B,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAMA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIlB;IAChBkB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACf;IACR,KAAK,MAAMgB,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACb,iBAAiBO;IACzBC,IAAIK,GAAG,CAACd,cAAc;QAAEE;IAAe;IACvC,MAAMc,eAA6B;QACjCC,SAASb,OAAOa,OAAO;QACvBC,YAAYd,OAAOc,UAAU;QAC7BpB;QACAqB,YAAY,CAACb,SAASc;IACxB;IACA,OAAO;QACLC,OAAOZ,IAAIY,KAAK;QAChBC,OAAOnB;QACPa;QACAO,gBAAgB;YAAC;SAAuC;IAC1D;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/netlify.ts"],"sourcesContent":["import type { MiddlewareHandler } from 'hono';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './netlify-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n      privateDir: config.privateDir,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/netlify-build-enhancer'],\n    };\n  },\n);\n"],"names":["Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","distDir","privateDir","serverless","static","fetch","build","buildEnhancers"],"mappings":"AACA,SAASA,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAMA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIlB;IAChBkB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACf;IACR,KAAK,MAAMgB,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACb,iBAAiBO;IACzBC,IAAIK,GAAG,CAACd,cAAc;QAAEE;IAAe;IACvC,MAAMc,eAA6B;QACjCC,SAASb,OAAOa,OAAO;QACvBC,YAAYd,OAAOc,UAAU;QAC7BpB;QACAqB,YAAY,CAACb,SAASc;IACxB;IACA,OAAO;QACLC,OAAOZ,IAAIY,KAAK;QAChBC,OAAOnB;QACPa;QACAO,gBAAgB;YAAC;SAAuC;IAC1D;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/node.js b/dist/adapters/node.js
index df7b521ccdb63ffbd1b016fe6727782d29fd2b94..bc34b1705667d28fb744f211d6626bce15fc20a2 100644
--- a/dist/adapters/node.js
+++ b/dist/adapters/node.js
@@ -1,7 +1,7 @@
 import path from 'node:path';
 import { serve } from '@hono/node-server';
 import { serveStatic } from '@hono/node-server/serve-static';
-import { Hono } from 'hono';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/node.js.map b/dist/adapters/node.js.map
index b051b26ff6b5ead8b1e93a215c311cfe5e1258ee..9f04c1cc5e69533b3c577acca810b08ee7105365 100644
--- a/dist/adapters/node.js.map
+++ b/dist/adapters/node.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/node.ts"],"sourcesContent":["import path from 'node:path';\nimport { serve } from '@hono/node-server';\nimport { serveStatic } from '@hono/node-server/serve-static';\nimport { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './node-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(\n        `${config.basePath}*`,\n        serveStatic({\n          root: path.join(config.distDir, DIST_PUBLIC),\n          rewriteRequestPath: (path) => path.slice(config.basePath.length - 1),\n        }),\n      );\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/node-build-enhancer'],\n      serve,\n    };\n  },\n);\n"],"names":["path","serve","serveStatic","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","basePath","root","join","distDir","rewriteRequestPath","slice","length","middlewareFn","buildOptions","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAC7B,SAASC,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,IAAI,QAAQ,OAAO;AAE5B,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAInB;IAChBmB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CACL,GAAGX,OAAOY,QAAQ,CAAC,CAAC,CAAC,EACrB1B,YAAY;YACV2B,MAAM7B,KAAK8B,IAAI,CAACd,OAAOe,OAAO,EAAErB;YAChCsB,oBAAoB,CAAChC,OAASA,KAAKiC,KAAK,CAACjB,OAAOY,QAAQ,CAACM,MAAM,GAAG;QACpE;IAEJ;IACAZ,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMwB,gBAAgBf,cAAe;QACxCE,IAAIK,GAAG,CAACQ;IACV;IACAb,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMsB,eAA6B;QACjCL,SAASf,OAAOe,OAAO;IACzB;IACA,OAAO;QACLM,OAAOf,IAAIe,KAAK;QAChBC,OAAOvB;QACPqB;QACAG,gBAAgB;YAAC;SAAoC;QACrDtC;IACF;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/node.ts"],"sourcesContent":["import path from 'node:path';\nimport { serve } from '@hono/node-server';\nimport { serveStatic } from '@hono/node-server/serve-static';\nimport type { MiddlewareHandler } from 'hono';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './node-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, isBuild, notFoundHtml },\n    options?: {\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    if (isBuild) {\n      app.use(\n        `${config.basePath}*`,\n        serveStatic({\n          root: path.join(config.distDir, DIST_PUBLIC),\n          rewriteRequestPath: (path) => path.slice(config.basePath.length - 1),\n        }),\n      );\n    }\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      distDir: config.distDir,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/node-build-enhancer'],\n      serve,\n    };\n  },\n);\n"],"names":["path","serve","serveStatic","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","processRequest","processBuild","config","isBuild","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","basePath","root","join","distDir","rewriteRequestPath","slice","length","middlewareFn","buildOptions","fetch","build","buildEnhancers"],"mappings":"AAAA,OAAOA,UAAU,YAAY;AAC7B,SAASC,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,WAAW,QAAQ,iCAAiC;AAE7D,SAASC,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAE/D,eAAeF,yBACb,CACE,EAAEO,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,EAAEC,YAAY,EAAE,EAC/DC;IAKA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAInB;IAChBmB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACA,IAAIT,SAAS;QACXK,IAAIK,GAAG,CACL,GAAGX,OAAOY,QAAQ,CAAC,CAAC,CAAC,EACrB1B,YAAY;YACV2B,MAAM7B,KAAK8B,IAAI,CAACd,OAAOe,OAAO,EAAErB;YAChCsB,oBAAoB,CAAChC,OAASA,KAAKiC,KAAK,CAACjB,OAAOY,QAAQ,CAACM,MAAM,GAAG;QACpE;IAEJ;IACAZ,IAAIK,GAAG,CAAChB;IACR,KAAK,MAAMwB,gBAAgBf,cAAe;QACxCE,IAAIK,GAAG,CAACQ;IACV;IACAb,IAAIK,GAAG,CAACd,iBAAiBQ;IACzBC,IAAIK,GAAG,CAACf,cAAc;QAAEE;IAAe;IACvC,MAAMsB,eAA6B;QACjCL,SAASf,OAAOe,OAAO;IACzB;IACA,OAAO;QACLM,OAAOf,IAAIe,KAAK;QAChBC,OAAOvB;QACPqB;QACAG,gBAAgB;YAAC;SAAoC;QACrDtC;IACF;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/adapters/vercel.js b/dist/adapters/vercel.js
index 2f0c4a679f8bf78530ef5e999aaf46840225703b..13866603f53f4b11351748a30ec9b36069e2dce3 100644
--- a/dist/adapters/vercel.js
+++ b/dist/adapters/vercel.js
@@ -1,5 +1,5 @@
 import { getRequestListener } from '@hono/node-server';
-import { Hono } from 'hono';
+import { Hono } from 'hono/tiny';
 import { unstable_constants as constants, unstable_createServerEntryAdapter as createServerEntryAdapter, unstable_honoMiddleware as honoMiddleware } from 'waku/internals';
 const { DIST_PUBLIC } = constants;
 const { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;
diff --git a/dist/adapters/vercel.js.map b/dist/adapters/vercel.js.map
index 689ff1738ad25f58670eadf5b88425fca7ef5e41..8122c24c2798c1ec98066391234c890a5292d170 100644
--- a/dist/adapters/vercel.js.map
+++ b/dist/adapters/vercel.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/adapters/vercel.ts"],"sourcesContent":["import { getRequestListener } from '@hono/node-server';\nimport { Hono } from 'hono';\nimport type { MiddlewareHandler } from 'hono';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './vercel-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n(global as any).__WAKU_HONO_NODE_SERVER_GET_REQUEST_LISTENER__ =\n  getRequestListener;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      assetsDir?: string;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      assetsDir: options?.assetsDir || 'assets',\n      distDir: config.distDir,\n      rscBase: config.rscBase,\n      privateDir: config.privateDir,\n      basePath: config.basePath,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/vercel-build-enhancer'],\n    };\n  },\n);\n"],"names":["getRequestListener","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","global","__WAKU_HONO_NODE_SERVER_GET_REQUEST_LISTENER__","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","assetsDir","distDir","rscBase","privateDir","basePath","serverless","static","fetch","build","buildEnhancers"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,oBAAoB;AACvD,SAASC,IAAI,QAAQ,OAAO;AAE5B,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAC9DK,OAAeC,8CAA8C,GAC5Db;AAEF,eAAeK,yBACb,CACE,EAAES,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAOA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIpB;IAChBoB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACjB;IACR,KAAK,MAAMkB,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACf,iBAAiBS;IACzBC,IAAIK,GAAG,CAAChB,cAAc;QAAEI;IAAe;IACvC,MAAMc,eAA6B;QACjCC,WAAWX,SAASW,aAAa;QACjCC,SAASd,OAAOc,OAAO;QACvBC,SAASf,OAAOe,OAAO;QACvBC,YAAYhB,OAAOgB,UAAU;QAC7BC,UAAUjB,OAAOiB,QAAQ;QACzBzB;QACA0B,YAAY,CAAChB,SAASiB;IACxB;IACA,OAAO;QACLC,OAAOf,IAAIe,KAAK;QAChBC,OAAOtB;QACPa;QACAU,gBAAgB;YAAC;SAAsC;IACzD;AACF,GACA"}
\ No newline at end of file
+{"version":3,"sources":["../../src/adapters/vercel.ts"],"sourcesContent":["import { getRequestListener } from '@hono/node-server';\nimport type { MiddlewareHandler } from 'hono';\nimport { Hono } from 'hono/tiny';\nimport {\n  unstable_constants as constants,\n  unstable_createServerEntryAdapter as createServerEntryAdapter,\n  unstable_honoMiddleware as honoMiddleware,\n} from 'waku/internals';\nimport type { BuildOptions } from './vercel-build-enhancer.js';\n\nconst { DIST_PUBLIC } = constants;\nconst { contextMiddleware, rscMiddleware, middlewareRunner } = honoMiddleware;\n(global as any).__WAKU_HONO_NODE_SERVER_GET_REQUEST_LISTENER__ =\n  getRequestListener;\n\nexport default createServerEntryAdapter(\n  (\n    { processRequest, processBuild, config, notFoundHtml },\n    options?: {\n      static?: boolean;\n      assetsDir?: string;\n      middlewareFns?: (() => MiddlewareHandler)[];\n      middlewareModules?: Record<string, () => Promise<unknown>>;\n    },\n  ) => {\n    const { middlewareFns = [], middlewareModules = {} } = options || {};\n    const app = new Hono();\n    app.notFound((c) => {\n      if (notFoundHtml) {\n        return c.html(notFoundHtml, 404);\n      }\n      return c.text('404 Not Found', 404);\n    });\n    app.use(contextMiddleware());\n    for (const middlewareFn of middlewareFns) {\n      app.use(middlewareFn());\n    }\n    app.use(middlewareRunner(middlewareModules as never));\n    app.use(rscMiddleware({ processRequest }));\n    const buildOptions: BuildOptions = {\n      assetsDir: options?.assetsDir || 'assets',\n      distDir: config.distDir,\n      rscBase: config.rscBase,\n      privateDir: config.privateDir,\n      basePath: config.basePath,\n      DIST_PUBLIC,\n      serverless: !options?.static,\n    };\n    return {\n      fetch: app.fetch,\n      build: processBuild,\n      buildOptions,\n      buildEnhancers: ['waku/adapters/vercel-build-enhancer'],\n    };\n  },\n);\n"],"names":["getRequestListener","Hono","unstable_constants","constants","unstable_createServerEntryAdapter","createServerEntryAdapter","unstable_honoMiddleware","honoMiddleware","DIST_PUBLIC","contextMiddleware","rscMiddleware","middlewareRunner","global","__WAKU_HONO_NODE_SERVER_GET_REQUEST_LISTENER__","processRequest","processBuild","config","notFoundHtml","options","middlewareFns","middlewareModules","app","notFound","c","html","text","use","middlewareFn","buildOptions","assetsDir","distDir","rscBase","privateDir","basePath","serverless","static","fetch","build","buildEnhancers"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,oBAAoB;AAEvD,SAASC,IAAI,QAAQ,YAAY;AACjC,SACEC,sBAAsBC,SAAS,EAC/BC,qCAAqCC,wBAAwB,EAC7DC,2BAA2BC,cAAc,QACpC,iBAAiB;AAGxB,MAAM,EAAEC,WAAW,EAAE,GAAGL;AACxB,MAAM,EAAEM,iBAAiB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE,GAAGJ;AAC9DK,OAAeC,8CAA8C,GAC5Db;AAEF,eAAeK,yBACb,CACE,EAAES,cAAc,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE,EACtDC;IAOA,MAAM,EAAEC,gBAAgB,EAAE,EAAEC,oBAAoB,CAAC,CAAC,EAAE,GAAGF,WAAW,CAAC;IACnE,MAAMG,MAAM,IAAIpB;IAChBoB,IAAIC,QAAQ,CAAC,CAACC;QACZ,IAAIN,cAAc;YAChB,OAAOM,EAAEC,IAAI,CAACP,cAAc;QAC9B;QACA,OAAOM,EAAEE,IAAI,CAAC,iBAAiB;IACjC;IACAJ,IAAIK,GAAG,CAACjB;IACR,KAAK,MAAMkB,gBAAgBR,cAAe;QACxCE,IAAIK,GAAG,CAACC;IACV;IACAN,IAAIK,GAAG,CAACf,iBAAiBS;IACzBC,IAAIK,GAAG,CAAChB,cAAc;QAAEI;IAAe;IACvC,MAAMc,eAA6B;QACjCC,WAAWX,SAASW,aAAa;QACjCC,SAASd,OAAOc,OAAO;QACvBC,SAASf,OAAOe,OAAO;QACvBC,YAAYhB,OAAOgB,UAAU;QAC7BC,UAAUjB,OAAOiB,QAAQ;QACzBzB;QACA0B,YAAY,CAAChB,SAASiB;IACxB;IACA,OAAO;QACLC,OAAOf,IAAIe,KAAK;QAChBC,OAAOtB;QACPa;QACAU,gBAAgB;YAAC;SAAsC;IACzD;AACF,GACA"}
\ No newline at end of file
diff --git a/dist/router/client.d.ts b/dist/router/client.d.ts
index 31262cb45579d2c973d52b4cd3921ae604e87d79..b29effc66a73c37fda6e436d3d5d0c56d13ba8bf 100644
--- a/dist/router/client.d.ts
+++ b/dist/router/client.d.ts
@@ -11,36 +11,19 @@ type InferredPaths = RouteConfig extends {
 type ChangeRoute = (route: RouteProps, options: {
     shouldScroll: boolean;
     skipRefetch?: boolean;
+    signal?: AbortSignal;
     unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
 }) => Promise<void>;
-type ChangeRouteEvent = 'start' | 'complete';
-type ChangeRouteCallback = (route: RouteProps) => void;
 type PrefetchRoute = (route: RouteProps) => void;
 type SliceId = string;
+export declare function usePending(): boolean;
 export declare function useRouter(): {
-    push: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
-    replace: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
+    push: (to: InferredPaths) => void;
+    replace: (to: InferredPaths) => void;
     reload: () => Promise<void>;
     back: () => void;
     forward: () => void;
     prefetch: (to: string) => void;
-    unstable_events: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
     path: string;
     query: string;
     hash: string;
@@ -48,23 +31,14 @@ export declare function useRouter(): {
 export type LinkProps = {
     to: InferredPaths;
     children: ReactNode;
-    /**
-     * indicates if the link should scroll or not on navigation
-     * - `true`: always scroll
-     * - `false`: never scroll
-     * - `undefined`: scroll on path change (not on searchParams change)
-     */
-    scroll?: boolean;
-    unstable_pending?: ReactNode;
-    unstable_notPending?: ReactNode;
     unstable_prefetchOnEnter?: boolean;
     unstable_prefetchOnView?: boolean;
-    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
     ref?: Ref<HTMLAnchorElement> | undefined;
 } & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
-export declare function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }: LinkProps): ReactElement;
+export declare function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }: LinkProps): ReactElement;
 export declare class ErrorBoundary extends Component<{
     children: ReactNode;
+    error?: unknown;
 }, {
     error?: unknown;
 }> {
@@ -116,7 +90,6 @@ export declare const unstable_RouterContext: import("react").Context<{
     route: RouteProps;
     changeRoute: ChangeRoute;
     prefetchRoute: PrefetchRoute;
-    routeChangeEvents: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
     fetchingSlices: Set<SliceId>;
 } | null>;
 export type Unstable_ChangeRoute = ChangeRoute;
diff --git a/dist/router/client.js b/dist/router/client.js
index 3d72db798b156673ee0e02ae840b019a985ea94e..243c737ab103549899148877f0855da54bd29c18 100644
--- a/dist/router/client.js
+++ b/dist/router/client.js
@@ -1,6 +1,6 @@
 'use client';
 import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
-import { Component, createContext, startTransition, use, useCallback, useContext, useEffect, useRef, useState, useTransition } from 'react';
+import { Component, createContext, use, useCallback, useEffect, useRef, useState, useTransition } from 'react';
 import { preloadModule } from 'react-dom';
 import { getErrorInfo } from '../lib/utils/custom-errors.js';
 import { addBase, removeBase } from '../lib/utils/path.js';
@@ -44,7 +44,6 @@ const parseRouteFromLocation = ()=>{
     }
     return parseRoute(new URL(window.location.href));
 };
-const isAltClick = (event)=>event.button !== 0 || !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
 let savedRscParams;
 const createRscParams = (query)=>{
     if (savedRscParams && savedRscParams[0] === query) {
@@ -59,60 +58,49 @@ const createRscParams = (query)=>{
     ];
     return rscParams;
 };
+const PendingContext = /*#__PURE__*/ createContext(false);
+// Not sure whether this is necessary
+// We have navigation.transition
+// but it's not reactive
+export function usePending() {
+    return use(PendingContext);
+}
 // This is an internal thing, not a public API
 const RouterContext = /*#__PURE__*/ createContext(null);
 export function useRouter() {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { route, changeRoute, prefetchRoute } = router;
-    const push = useCallback(async (to, options)=>{
+    const { route, prefetchRoute } = router;
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const push = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
-        });
-        if (window.location.pathname === currentPath) {
-            window.history.pushState({
-                ...window.history.state,
-                waku_new_path: newPath
-            }, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const replace = useCallback(async (to, options)=>{
+        window.navigation.navigate(to);
+    }, []);
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const replace = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
-        });
-        if (window.location.pathname === currentPath) {
-            window.history.replaceState(window.history.state, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const reload = useCallback(async ()=>{
-        const url = new URL(window.location.href);
-        await changeRoute(parseRoute(url), {
-            shouldScroll: true
+        window.navigation.navigate(to, {
+            history: 'replace'
         });
-    }, [
-        changeRoute
-    ]);
-    const back = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.back();
     }, []);
-    const forward = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.forward();
+    /**
+   * @deprecated use window.navigation.reload() instead
+   */ const reload = useCallback(async ()=>{
+        window.navigation.reload();
+    }, []);
+    /**
+   * @deprecated use window.navigation.back() instead
+   */ const back = useCallback(()=>{
+        window.navigation.back();
+    }, []);
+    /**
+   * @deprecated use window.navigation.forward() instead
+   */ const forward = useCallback(()=>{
+        window.navigation.forward();
     }, []);
     const prefetch = useCallback((to)=>{
         const url = new URL(to, window.location.href);
@@ -127,8 +115,7 @@ export function useRouter() {
         reload,
         back,
         forward,
-        prefetch,
-        unstable_events: router.routeChangeEvents
+        prefetch
     };
 }
 function useSharedRef(ref) {
@@ -164,17 +151,12 @@ function useSharedRef(ref) {
         handleRef
     ];
 }
-export function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }) {
+export function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }) {
     to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-    const router = useContext(RouterContext);
-    const changeRoute = router ? router.changeRoute : ()=>{
-        throw new Error('Missing Router');
-    };
+    const router = use(RouterContext);
     const prefetchRoute = router ? router.prefetchRoute : ()=>{
         throw new Error('Missing Router');
     };
-    const [isPending, startTransition] = useTransition();
-    const startTransitionFn = unstable_startTransition || (unstable_pending || unstable_notPending) && startTransition || ((fn)=>fn());
     const [ref, setRef] = useSharedRef(refProp);
     useEffect(()=>{
         if (unstable_prefetchOnView && ref.current) {
@@ -202,40 +184,6 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
         to,
         ref
     ]);
-    const internalOnClick = ()=>{
-        const url = new URL(to, window.location.href);
-        if (url.href !== window.location.href) {
-            const route = parseRoute(url);
-            prefetchRoute(route);
-            startTransitionFn(async ()=>{
-                const currentPath = window.location.pathname;
-                const newPath = url.pathname !== currentPath;
-                try {
-                    await changeRoute(route, {
-                        shouldScroll: scroll ?? newPath,
-                        unstable_startTransition: startTransitionFn
-                    });
-                } finally{
-                    if (window.location.pathname === currentPath) {
-                        // Update history if it wasn't already updated
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: newPath
-                        }, '', url);
-                    }
-                }
-            });
-        }
-    };
-    const onClick = (event)=>{
-        if (props.onClick) {
-            props.onClick(event);
-        }
-        if (!event.defaultPrevented && !isAltClick(event)) {
-            event.preventDefault();
-            internalOnClick();
-        }
-    };
     const onMouseEnter = unstable_prefetchOnEnter ? (event)=>{
         const url = new URL(to, window.location.href);
         if (url.href !== window.location.href) {
@@ -247,27 +195,10 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
     const ele = /*#__PURE__*/ _jsx("a", {
         ...props,
         href: to,
-        onClick: onClick,
         onMouseEnter: onMouseEnter,
         ref: setRef,
         children: children
     });
-    if (isPending && unstable_pending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_pending
-            ]
-        });
-    }
-    if (!isPending && unstable_notPending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_notPending
-            ]
-        });
-    }
     return ele;
 }
 const notAvailableInServer = (name)=>()=>{
@@ -317,17 +248,18 @@ export class ErrorBoundary extends Component {
         };
     }
     render() {
-        if ('error' in this.state) {
-            if (this.state.error instanceof Error) {
-                return renderError(this.state.error.message);
+        if ('error' in this.state || 'error' in this.props) {
+            const error = this.state.error ?? this.props.error;
+            if (error instanceof Error) {
+                return renderError(error.message);
             }
-            return renderError(String(this.state.error));
+            return renderError(String(error));
         }
         return this.props.children;
     }
 }
 const NotFound = ({ has404, reset })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -336,13 +268,9 @@ const NotFound = ({ has404, reset })=>{
         if (has404) {
             const url = new URL('/404', window.location.href);
             changeRoute(parseRoute(url), {
-                shouldScroll: true
+                shouldScroll: false
             }).then(()=>{
-                // HACK: This timeout is required for canary-ci to work
-                // FIXME: As we understand it, we should have a proper solution.
-                setTimeout(()=>{
-                    reset();
-                }, 1);
+                reset();
             }).catch((err)=>{
                 console.log('Error while navigating to 404:', err);
             });
@@ -357,11 +285,10 @@ const NotFound = ({ has404, reset })=>{
     });
 };
 const Redirect = ({ error, to, reset, handledErrorSet })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { changeRoute } = router;
     useEffect(()=>{
         // ensure single re-fetch per server redirection error on StrictMode
         // https://github.com/wakujs/waku/pull/1512
@@ -370,62 +297,45 @@ const Redirect = ({ error, to, reset, handledErrorSet })=>{
         }
         handledErrorSet.add(error);
         const url = new URL(to, window.location.href);
-        // FIXME this condition seems too naive
-        if (url.hostname !== window.location.hostname) {
-            window.location.replace(to);
-            return;
-        }
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        changeRoute(parseRoute(url), {
-            shouldScroll: newPath
-        }).then(()=>{
-            // FIXME: As we understand it, we should have a proper solution.
-            setTimeout(()=>{
-                reset();
-            }, 1);
-        }).catch((err)=>{
-            console.log('Error while navigating to redirect:', err);
-        }).finally(()=>{
-            if (window.location.pathname === currentPath) {
-                window.history.replaceState({
-                    ...window.history.state,
-                    waku_new_path: newPath
-                }, '', url);
-            }
+        window.navigation.navigate(url, {
+            history: 'push'
+        }).committed?.then(()=>{
+            // FIXME
+            // ssr-redirect > access sync page with client navigation
+            return new Promise((resolve)=>setTimeout(resolve, 200));
+        })?.then(()=>{
+            console.trace('Redirected to', to);
+            reset();
         });
     }, [
         error,
-        to,
+        handledErrorSet,
         reset,
-        changeRoute,
-        handledErrorSet
+        to
     ]);
     return null;
 };
 class CustomErrorHandler extends Component {
-    handledErrorSet = new WeakSet();
+    #handledErrorSet = new WeakSet();
     constructor(props){
         super(props);
         this.state = {
             error: null
         };
-        this.reset = this.reset.bind(this);
     }
     static getDerivedStateFromError(error) {
         return {
             error
         };
     }
-    reset() {
+    reset = ()=>{
         this.setState({
             error: null
         });
-    }
+    };
     render() {
-        const { error } = this.state;
-        if (error !== null) {
-            const info = getErrorInfo(error);
+        if (this.state.error !== null) {
+            const info = getErrorInfo(this.state.error);
             if (info?.status === 404) {
                 return /*#__PURE__*/ _jsx(NotFound, {
                     has404: this.props.has404,
@@ -434,24 +344,24 @@ class CustomErrorHandler extends Component {
             }
             if (info?.location) {
                 return /*#__PURE__*/ _jsx(Redirect, {
-                    error: error,
+                    error: this.state.error,
                     to: info.location,
                     reset: this.reset,
-                    handledErrorSet: this.handledErrorSet
+                    handledErrorSet: this.#handledErrorSet
                 });
             }
-            throw error;
+            return /*#__PURE__*/ _jsx(ErrorBoundary, {
+                error: this.state.error,
+                children: null
+            });
         }
         return this.props.children;
     }
 }
-const ThrowError = ({ error })=>{
-    throw error;
-};
 const getRouteSlotId = (path)=>'route:' + decodeURI(path);
 const getSliceSlotId = (id)=>'slice:' + id;
 export function Slice({ id, children, ...props }) {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -532,7 +442,7 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
             if (routeData) {
                 const [path, _query] = routeData;
                 if (isStatic) {
-                    staticPathSetRef.current.add(path);
+                    staticPathSetRef.current.add(encodeURI(path));
                 }
             }
             cachedIdSetRef.current = new Set(Object.keys(rest));
@@ -541,11 +451,14 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
         elementsPromise
     ]);
     const enhanceFetchRscInternal = useEnhanceFetchRscInternal();
-    const locationListenersRef = useRef(new Set());
-    const locationListeners = locationListenersRef.current;
+    // It doesn't have to be a ref
+    // But passing it to multiple function calls is too complicated
+    const signalRef = useRef(null);
     useEffect(()=>{
-        const enhanceFetch = (fetchFn)=>(input, init = {})=>{
-                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));
+        const enhanceFetch = (fetchFn)=>(input, init = {
+                signal: signalRef.current
+            })=>{
+                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current).map((i)=>encodeURI(i)));
                 const headers = init.headers ||= {};
                 if (Array.isArray(headers)) {
                     headers.push([
@@ -564,16 +477,18 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
                     const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } = elements;
                     if (routeData) {
                         const [path, query] = routeData;
-                        if (requestedRouteRef.current.path !== path || !isStatic && requestedRouteRef.current.query !== query) {
-                            locationListeners.forEach((listener)=>listener(path, query));
+                        if (requestedRouteRef.current.path !== encodeURI(path) || !isStatic && requestedRouteRef.current.query !== query) {
+                            // redirected
+                            window.navigation.navigate(path, {
+                                history: 'push'
+                            });
                         }
                     }
                 }).catch(()=>{});
                 return elementsPromise;
             });
     }, [
-        enhanceFetchRscInternal,
-        locationListeners
+        enhanceFetchRscInternal
     ]);
     const refetch = useRefetch();
     const [route, setRoute] = useState(()=>({
@@ -584,38 +499,6 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
             ...initialRoute,
             hash: ''
         }));
-    const routeChangeListenersRef = useRef(null);
-    if (routeChangeListenersRef.current === null) {
-        const listeners = {
-            start: new Set(),
-            complete: new Set()
-        };
-        const executeListeners = (eventType, eventRoute)=>{
-            const eventListenersSet = listeners[eventType];
-            if (!eventListenersSet.size) {
-                return;
-            }
-            for (const listener of eventListenersSet){
-                listener(eventRoute);
-            }
-        };
-        const events = (()=>{
-            const on = (event, handler)=>{
-                listeners[event].add(handler);
-            };
-            const off = (event, handler)=>{
-                listeners[event].delete(handler);
-            };
-            return {
-                on,
-                off
-            };
-        })();
-        routeChangeListenersRef.current = [
-            events,
-            executeListeners
-        ];
-    }
     // Update the route post-load to include the current hash.
     useEffect(()=>{
         setRoute((prev)=>{
@@ -627,16 +510,11 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
     }, [
         initialRoute
     ]);
-    const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;
-    const [err, setErr] = useState(null);
-    // FIXME this "refetching" hack doesn't seem ideal.
-    const refetching = useRef(null);
+    const customErrorHandlerRef = useRef(null);
     const changeRoute = useCallback(async (route, options)=>{
         requestedRouteRef.current = route;
-        executeListeners('start', route);
         const startTransitionFn = options.unstable_startTransition || ((fn)=>fn());
-        refetching.current = [];
-        setErr(null);
+        customErrorHandlerRef.current?.reset();
         const { skipRefetch } = options || {};
         if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {
             const rscPath = encodeRoutePath(route.path);
@@ -644,22 +522,28 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
             try {
                 await refetch(rscPath, rscParams);
             } catch (e) {
-                refetching.current = null;
-                setErr(e);
-                throw e;
+                if (e instanceof Error && e.name === 'AbortError') {
+                // Noop
+                } else {
+                    // Workaround: after setErr, CustomErrorHandler is not rerendered!
+                    // Why is that?
+                    // Luckily this is not on happy path.
+                    // Update: this causes more bugs.
+                    // flushSync(() => {
+                    // });
+                    throw e;
+                }
             }
         }
         startTransitionFn(()=>{
-            if (options.shouldScroll) {
-                handleScroll();
+            if (!options.signal?.aborted) {
+                if (options.shouldScroll) {
+                    handleScroll();
+                }
+                setRoute(route);
             }
-            setRoute(route);
-            refetching.current[0]?.();
-            refetching.current = null;
-            executeListeners('complete', route);
         });
     }, [
-        executeListeners,
         refetch
     ]);
     const prefetchRoute = useCallback((route)=>{
@@ -675,64 +559,126 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
             });
         });
     }, []);
+    const [isPending, startTransition] = useTransition();
+    // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js
     useEffect(()=>{
-        const callback = ()=>{
-            const route = routeInterceptor(parseRoute(new URL(window.location.href)));
-            if (!route) {
+        const callback = (event)=>{
+            if (!event.canIntercept || // If this is a download,
+            // let the browser perform the download.
+            event.downloadRequest || // If this is a form submission,
+            // let that go to the server.
+            event.formData) {
+                return;
+            } else if (// If this is just a hashChange,
+            // just let the browser handle scrolling to the content.
+            event.hashChange) {
+                setRoute((prev)=>({
+                        ...prev,
+                        hash: new URL(event.destination.url).hash
+                    }));
                 return;
             }
-            changeRoute(route, {
-                shouldScroll: true
-            }).catch((err)=>{
-                console.log('Error while navigating back:', err);
+            const url = new URL(event.destination.url);
+            const route = parseRoute(url);
+            // console.log(event);
+            const navigationType = event.navigationType;
+            const previousIndex = window.navigation.currentEntry.index;
+            event.intercept({
+                async precommitHandler () {
+                    if (signalRef.current) {
+                        // It happens when click very fast.
+                        console.warn('Potential race condition due to rapid navigation.');
+                    }
+                    signalRef.current = event.signal;
+                    startTransition(async ()=>{
+                        // addTransitionType('navigation-' + navigationType);
+                        if (navigationType === 'traverse') {
+                            // For traverse types it's useful to distinguish going back or forward.
+                            const nextIndex = event.destination.index;
+                            if (nextIndex > previousIndex) {
+                            // addTransitionType('navigation-forward');
+                            } else if (nextIndex < previousIndex) {
+                            // addTransitionType('navigation-back');
+                            }
+                            const err = customErrorHandlerRef.current?.state.error;
+                            if (err) {
+                                const info = getErrorInfo(err);
+                                if (info?.status === 404) {
+                                    // if 404 sans 404.tsx, manually go back
+                                    // should make CustomErrorHandler state
+                                    // Haha, upstream is broken too
+                                    customErrorHandlerRef.current?.reset();
+                                }
+                            }
+                            await changeRoute(route, {
+                                shouldScroll: false,
+                                unstable_startTransition: startTransition,
+                                signal: event.signal
+                            }).catch((err)=>{
+                                console.log('Error while navigating back:', err);
+                            });
+                        } else {
+                            prefetchRoute(route);
+                            try {
+                                await changeRoute(route, {
+                                    shouldScroll: false,
+                                    unstable_startTransition: startTransition,
+                                    signal: event.signal
+                                });
+                            } catch (err) {
+                                // Handle 404, etc here
+                                customErrorHandlerRef.current?.setState({
+                                    error: err
+                                });
+                                if (has404 && err) {
+                                    const info = getErrorInfo(err);
+                                    if (info?.status === 404) {
+                                        await changeRoute({
+                                            path: '/404',
+                                            query: '',
+                                            hash: ''
+                                        }, {
+                                            signal: event.signal,
+                                            shouldScroll: false
+                                        });
+                                    }
+                                }
+                            }
+                        }
+                        if (signalRef.current === event.signal) {
+                            signalRef.current = null;
+                        }
+                    });
+                    await flushAsync();
+                    return;
+                },
+                scroll: 'after-transition'
             });
         };
-        window.addEventListener('popstate', callback);
+        window.navigation.addEventListener('navigate', callback);
         return ()=>{
-            window.removeEventListener('popstate', callback);
+            window.navigation.removeEventListener('navigate', callback);
         };
     }, [
         changeRoute,
-        routeInterceptor
+        prefetchRoute,
+        has404
     ]);
+    // run after new route DOM mounted
     useEffect(()=>{
-        const callback = (path, query)=>{
-            const fn = ()=>{
-                const url = new URL(window.location.href);
-                url.pathname = path;
-                url.search = query;
-                url.hash = '';
-                changeRoute(parseRoute(url), {
-                    skipRefetch: true,
-                    shouldScroll: false
-                }).catch((err)=>{
-                    console.log('Error while handling location listeners:', err);
-                }).finally(()=>{
-                    if (path !== '/404') {
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: url.pathname !== window.location.pathname
-                        }, '', url);
-                    }
-                });
-            };
-            if (refetching.current) {
-                refetching.current.push(fn);
-            } else {
-                startTransition(fn);
-            }
-        };
-        locationListeners.add(callback);
-        return ()=>{
-            locationListeners.delete(callback);
-        };
+        resolver.current?.(undefined);
+        resolver.current = null;
     }, [
-        changeRoute,
-        locationListeners
+        route
     ]);
-    const routeElement = err !== null ? /*#__PURE__*/ _jsx(ThrowError, {
-        error: err
-    }) : /*#__PURE__*/ _jsx(Slot, {
+    const resolver = useRef(null);
+    async function flushAsync() {
+        const deferred = Promise.withResolvers();
+        resolver.current = deferred.resolve;
+        await deferred.promise;
+        return;
+    }
+    const routeElement = /*#__PURE__*/ _jsx(Slot, {
         id: getRouteSlotId(route.path)
     });
     const rootElement = /*#__PURE__*/ _jsxs(Slot, {
@@ -743,6 +689,7 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
                 content: httpStatus
             }),
             /*#__PURE__*/ _jsx(CustomErrorHandler, {
+                ref: customErrorHandlerRef,
                 has404: has404,
                 children: routeElement
             })
@@ -753,10 +700,12 @@ const InnerRouter = ({ initialRoute, httpStatus, routeInterceptor = defaultRoute
             route,
             changeRoute,
             prefetchRoute,
-            routeChangeEvents,
             fetchingSlices: useRef(new Set()).current
         },
-        children: rootElement
+        children: /*#__PURE__*/ _jsx(PendingContext, {
+            value: isPending,
+            children: rootElement
+        })
     });
 };
 export function Router({ initialRoute = parseRouteFromLocation(), unstable_routeInterceptor }) {
@@ -773,10 +722,6 @@ export function Router({ initialRoute = parseRouteFromLocation(), unstable_route
         })
     });
 }
-const MOCK_ROUTE_CHANGE_LISTENER = {
-    on: ()=>notAvailableInServer('routeChange:on'),
-    off: ()=>notAvailableInServer('routeChange:off')
-};
 /**
  * ServerRouter for SSR
  * This is not a public API.
@@ -800,7 +745,6 @@ const MOCK_ROUTE_CHANGE_LISTENER = {
                 route,
                 changeRoute: notAvailableInServer('changeRoute'),
                 prefetchRoute: notAvailableInServer('prefetchRoute'),
-                routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,
                 fetchingSlices: new Set()
             },
             children: rootElement
diff --git a/dist/router/client.js.map b/dist/router/client.js.map
index 8fb06caea72ca072d92c4aae027c8da3aafb9514..a37c74856b80612d07c11361b3eba5deea6a4c65 100644
--- a/dist/router/client.js.map
+++ b/dist/router/client.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  startTransition,\n  use,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { preloadModule } from 'react-dom';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nconst isAltClick = (event: MouseEvent<HTMLAnchorElement>) =>\n  event.button !== 0 ||\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype ChangeRouteEvent = 'start' | 'complete';\n\ntype ChangeRouteCallback = (route: RouteProps) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  routeChangeEvents: Record<\n    'on' | 'off',\n    (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n  >;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n      }\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.replaceState(window.history.state, '', url);\n      }\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(async () => {\n    const url = new URL(window.location.href);\n    await changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n    unstable_events: router.routeChangeEvents,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: TransitionFunction) => fn());\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const internalOnClick = () => {\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(async () => {\n        const currentPath = window.location.pathname;\n        const newPath = url.pathname !== currentPath;\n        try {\n          await changeRoute(route, {\n            shouldScroll: scroll ?? newPath,\n            unstable_startTransition: startTransitionFn,\n          });\n        } finally {\n          if (window.location.pathname === currentPath) {\n            // Update history if it wasn't already updated\n            window.history.pushState(\n              {\n                ...window.history.state,\n                waku_new_path: newPath,\n              },\n              '',\n              url,\n            );\n          }\n        }\n      });\n    }\n  };\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    if (props.onClick) {\n      props.onClick(event);\n    }\n    if (!event.defaultPrevented && !isAltClick(event)) {\n      event.preventDefault();\n      internalOnClick();\n    }\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a\n      {...props}\n      href={to}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={setRef}\n    >\n      {children}\n    </a>\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_pending}\n      </>\n    );\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_notPending}\n      </>\n    );\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true })\n        .then(() => {\n          // HACK: This timeout is required for canary-ci to work\n          // FIXME: As we understand it, we should have a proper solution.\n          setTimeout(() => {\n            reset();\n          }, 1);\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const currentPath = window.location.pathname;\n    const newPath = url.pathname !== currentPath;\n    changeRoute(parseRoute(url), { shouldScroll: newPath })\n      .then(() => {\n        // FIXME: As we understand it, we should have a proper solution.\n        setTimeout(() => {\n          reset();\n        }, 1);\n      })\n      .catch((err) => {\n        console.log('Error while navigating to redirect:', err);\n      })\n      .finally(() => {\n        if (window.location.pathname === currentPath) {\n          window.history.replaceState(\n            {\n              ...window.history.state,\n              waku_new_path: newPath,\n            },\n            '',\n            url,\n          );\n        }\n      });\n  }, [error, to, reset, changeRoute, handledErrorSet]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  private handledErrorSet = new WeakSet();\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.handledErrorSet}\n          />\n        );\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst ThrowError = ({ error }: { error: unknown }) => {\n  throw error;\n};\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst defaultRouteInterceptor = (route: RouteProps) => route;\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n  routeInterceptor = defaultRouteInterceptor,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n  routeInterceptor: ((route: RouteProps) => RouteProps | false) | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(path);\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  const locationListenersRef = useRef(\n    new Set<(path: string, query: string) => void>(),\n  );\n  const locationListeners = locationListenersRef.current;\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (input: RequestInfo | URL, init: RequestInit = {}) => {\n        const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== path ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  locationListeners.forEach((listener) =>\n                    listener(path, query),\n                  );\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal, locationListeners]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  const routeChangeListenersRef =\n    useRef<\n      [\n        Record<\n          'on' | 'off',\n          (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n        >,\n        (\n          eventType: ChangeRouteEvent,\n          eventRoute: Parameters<ChangeRouteCallback>[0],\n        ) => void,\n      ]\n    >(null);\n  if (routeChangeListenersRef.current === null) {\n    const listeners: Record<ChangeRouteEvent, Set<ChangeRouteCallback>> = {\n      start: new Set(),\n      complete: new Set(),\n    };\n    const executeListeners = (\n      eventType: ChangeRouteEvent,\n      eventRoute: Parameters<ChangeRouteCallback>[0],\n    ) => {\n      const eventListenersSet = listeners[eventType];\n      if (!eventListenersSet.size) {\n        return;\n      }\n      for (const listener of eventListenersSet) {\n        listener(eventRoute);\n      }\n    };\n    const events = (() => {\n      const on = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].add(handler);\n      };\n      const off = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].delete(handler);\n      };\n      return { on, off };\n    })();\n\n    routeChangeListenersRef.current = [events, executeListeners];\n  }\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;\n  const [err, setErr] = useState<unknown>(null);\n  // FIXME this \"refetching\" hack doesn't seem ideal.\n  const refetching = useRef<[onFinish?: () => void] | null>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      executeListeners('start', route);\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      refetching.current = [];\n      setErr(null);\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          refetching.current = null;\n          setErr(e);\n          throw e;\n        }\n      }\n      startTransitionFn(() => {\n        if (options.shouldScroll) {\n          handleScroll();\n        }\n        setRoute(route);\n        refetching.current![0]?.();\n        refetching.current = null;\n        executeListeners('complete', route);\n      });\n    },\n    [executeListeners, refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path, (id: string) => {\n      preloadModule(id, { as: 'script' });\n    });\n  }, []);\n\n  useEffect(() => {\n    const callback = () => {\n      const route = routeInterceptor(parseRoute(new URL(window.location.href)));\n      if (!route) {\n        return;\n      }\n      changeRoute(route, { shouldScroll: true }).catch((err) => {\n        console.log('Error while navigating back:', err);\n      });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute, routeInterceptor]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const fn = () => {\n        const url = new URL(window.location.href);\n        url.pathname = path;\n        url.search = query;\n        url.hash = '';\n        changeRoute(parseRoute(url), {\n          skipRefetch: true,\n          shouldScroll: false,\n        })\n          .catch((err) => {\n            console.log('Error while handling location listeners:', err);\n          })\n          .finally(() => {\n            if (path !== '/404') {\n              window.history.pushState(\n                {\n                  ...window.history.state,\n                  waku_new_path: url.pathname !== window.location.pathname,\n                },\n                '',\n                url,\n              );\n            }\n          });\n      };\n      if (refetching.current) {\n        refetching.current.push(fn);\n      } else {\n        startTransition(fn);\n      }\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement =\n    err !== null ? (\n      <ThrowError error={err} />\n    ) : (\n      <Slot id={getRouteSlotId(route.path)} />\n    );\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler has404={has404}>{routeElement}</CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        routeChangeEvents,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      {rootElement}\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n  unstable_routeInterceptor,\n}: {\n  initialRoute?: RouteProps;\n  unstable_routeInterceptor?: (route: RouteProps) => RouteProps | false;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter\n        initialRoute={initialRoute}\n        httpStatus={httpStatus}\n        routeInterceptor={unstable_routeInterceptor}\n      />\n    </Root>\n  );\n}\n\nconst MOCK_ROUTE_CHANGE_LISTENER: Record<\n  'on' | 'off',\n  (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n> = {\n  on: () => notAvailableInServer('routeChange:on'),\n  off: () => notAvailableInServer('routeChange:off'),\n};\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n\n// Highly experimental to expose internal APIs\n// Subject to change without notice\nexport type Unstable_RouteProps = RouteProps;\nexport const unstable_HAS404_ID = HAS404_ID;\nexport const unstable_IS_STATIC_ID = IS_STATIC_ID;\nexport const unstable_ROUTE_ID = ROUTE_ID;\nexport const unstable_SKIP_HEADER = SKIP_HEADER;\nexport const unstable_encodeRoutePath = encodeRoutePath;\nexport const unstable_encodeSliceId = encodeSliceId;\nexport const unstable_getRouteSlotId = getRouteSlotId;\nexport const unstable_getSliceSlotId = getSliceSlotId;\nexport const unstable_getErrorInfo = getErrorInfo;\nexport const unstable_addBase = addBase;\nexport const unstable_removeBase = removeBase;\nexport const unstable_RouterContext = RouterContext;\nexport type Unstable_ChangeRoute = ChangeRoute;\nexport type Unstable_ChangeRouteEvent = ChangeRouteEvent;\nexport type Unstable_ChangeRouteCallback = ChangeRouteCallback;\nexport type Unstable_PrefetchRoute = PrefetchRoute;\nexport type Unstable_SliceId = SliceId;\nexport type Unstable_InferredPaths = InferredPaths;\nexport const unstable_parseRoute = parseRoute;\nexport const unstable_getHttpStatusFromMeta = getHttpStatusFromMeta;\n"],"names":["Component","createContext","startTransition","use","useCallback","useContext","useEffect","useRef","useState","useTransition","preloadModule","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","isAltClick","event","button","metaKey","altKey","ctrlKey","shiftKey","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter","router","Error","route","changeRoute","prefetchRoute","push","to","options","currentPath","newPath","shouldScroll","scroll","history","pushState","state","waku_new_path","replace","replaceState","reload","back","forward","prefetch","unstable_events","routeChangeEvents","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","refProp","props","isPending","startTransitionFn","fn","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","internalOnClick","onClick","defaultPrevented","preventDefault","onMouseEnter","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","getDerivedStateFromError","error","render","String","NotFound","has404","reset","then","setTimeout","catch","err","console","log","Redirect","handledErrorSet","has","add","hostname","finally","CustomErrorHandler","WeakSet","bind","setState","info","status","ThrowError","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","defaultRouteInterceptor","InnerRouter","initialRoute","routeInterceptor","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","Object","keys","enhanceFetchRscInternal","locationListenersRef","locationListeners","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","Promise","resolve","listener","setRoute","routeChangeListenersRef","listeners","start","complete","executeListeners","eventType","eventRoute","eventListenersSet","size","events","on","handler","off","prev","setErr","refetching","skipRefetch","__WAKU_ROUTER_PREFETCH__","as","callback","addEventListener","removeEventListener","search","routeElement","rootElement","meta","value","Router","unstable_routeInterceptor","initialRscPath","initialRscParams","MOCK_ROUTE_CHANGE_LISTENER","INTERNAL_ServerRouter","httpstatus","unstable_HAS404_ID","unstable_IS_STATIC_ID","unstable_ROUTE_ID","unstable_SKIP_HEADER","unstable_encodeRoutePath","unstable_encodeSliceId","unstable_getRouteSlotId","unstable_getSliceSlotId","unstable_getErrorInfo","unstable_addBase","unstable_removeBase","unstable_RouterContext","unstable_parseRoute","unstable_getHttpStatusFromMeta"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  use,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { preloadModule } from 'react-dom';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    signal?: AbortSignal;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\nconst PendingContext = createContext<boolean>(false);\n\n// Not sure whether this is necessary\n// We have navigation.transition\n// but it's not reactive\nexport function usePending() {\n  return use(PendingContext);\n}\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, prefetchRoute } = router;\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const push = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to);\n  }, []);\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const replace = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to, { history: 'replace' });\n  }, []);\n  /**\n   * @deprecated use window.navigation.reload() instead\n   */\n  const reload = useCallback(async () => {\n    window.navigation.reload();\n  }, []);\n  /**\n   * @deprecated use window.navigation.back() instead\n   */\n  const back = useCallback(() => {\n    window.navigation.back();\n  }, []);\n  /**\n   * @deprecated use window.navigation.forward() instead\n   */\n  const forward = useCallback(() => {\n    window.navigation.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = use(RouterContext);\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a {...props} href={to} onMouseEnter={onMouseEnter} ref={setRef}>\n      {children}\n    </a>\n  );\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode; error?: unknown },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state || 'error' in this.props) {\n      const error = this.state.error ?? this.props.error;\n      if (error instanceof Error) {\n        return renderError(error.message);\n      }\n      return renderError(String(error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: false })\n        .then(() => {\n          reset();\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    window.navigation\n      .navigate(url, { history: 'push' })\n      .committed?.then(() => {\n        // FIXME\n        // ssr-redirect > access sync page with client navigation\n        return new Promise((resolve) => setTimeout(resolve, 200));\n      })\n      ?.then(() => {\n        console.trace('Redirected to', to);\n        reset();\n      });\n  }, [error, handledErrorSet, reset, to]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  #handledErrorSet = new WeakSet();\n  constructor(props: {\n    has404: boolean;\n    error: unknown;\n    children?: ReactNode;\n  }) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset = () => {\n    this.setState({ error: null });\n  };\n  render() {\n    if (this.state.error !== null) {\n      const info = getErrorInfo(this.state.error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={this.state.error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.#handledErrorSet}\n          />\n        );\n      }\n      return <ErrorBoundary error={this.state.error}>{null}</ErrorBoundary>;\n    }\n    return this.props.children;\n  }\n}\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst defaultRouteInterceptor = (route: RouteProps) => route;\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n  routeInterceptor = defaultRouteInterceptor,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n  routeInterceptor: ((route: RouteProps) => RouteProps | false) | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(encodeURI(path));\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  // It doesn't have to be a ref\n  // But passing it to multiple function calls is too complicated\n  const signalRef = useRef<AbortSignal | null>(null);\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (\n        input: RequestInfo | URL,\n        init: RequestInit = { signal: signalRef.current },\n      ) => {\n        const skipStr = JSON.stringify(\n          Array.from(cachedIdSetRef.current).map((i) => encodeURI(i)),\n        );\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== encodeURI(path) ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  // redirected\n                  window.navigation.navigate(path, { history: 'push' });\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const customErrorHandlerRef = useRef<CustomErrorHandler>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      customErrorHandlerRef.current?.reset();\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          if (e instanceof Error && e.name === 'AbortError') {\n            // Noop\n          } else {\n            // Workaround: after setErr, CustomErrorHandler is not rerendered!\n            // Why is that?\n            // Luckily this is not on happy path.\n            // Update: this causes more bugs.\n            // flushSync(() => {\n            // });\n            throw e;\n          }\n        }\n      }\n      startTransitionFn(() => {\n        if (!options.signal?.aborted) {\n          if (options.shouldScroll) {\n            handleScroll();\n          }\n          setRoute(route);\n        }\n      });\n    },\n    [refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path, (id: string) => {\n      preloadModule(id, { as: 'script' });\n    });\n  }, []);\n\n  const [isPending, startTransition] = useTransition();\n\n  // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js\n  useEffect(() => {\n    const callback = ((event: NavigateEvent) => {\n      if (\n        !event.canIntercept ||\n        // If this is a download,\n        // let the browser perform the download.\n        event.downloadRequest ||\n        // If this is a form submission,\n        // let that go to the server.\n        event.formData\n      ) {\n        return;\n      } else if (\n        // If this is just a hashChange,\n        // just let the browser handle scrolling to the content.\n        event.hashChange\n      ) {\n        setRoute((prev) => ({\n          ...prev,\n          hash: new URL(event.destination.url).hash,\n        }));\n        return;\n      }\n      const url = new URL(event.destination.url);\n      const route = parseRoute(url);\n      // console.log(event);\n      const navigationType = event.navigationType;\n      const previousIndex = window.navigation.currentEntry!.index;\n      event.intercept({\n        async precommitHandler() {\n          if (signalRef.current) {\n            // It happens when click very fast.\n            console.warn('Potential race condition due to rapid navigation.');\n          }\n          signalRef.current = event.signal;\n          startTransition(async () => {\n            // addTransitionType('navigation-' + navigationType);\n            if (navigationType === 'traverse') {\n              // For traverse types it's useful to distinguish going back or forward.\n              const nextIndex = event.destination.index;\n              if (nextIndex > previousIndex) {\n                // addTransitionType('navigation-forward');\n              } else if (nextIndex < previousIndex) {\n                // addTransitionType('navigation-back');\n              }\n              const err = customErrorHandlerRef.current?.state.error;\n              if (err) {\n                const info = getErrorInfo(err);\n                if (info?.status === 404) {\n                  // if 404 sans 404.tsx, manually go back\n                  // should make CustomErrorHandler state\n                  // Haha, upstream is broken too\n\n                  customErrorHandlerRef.current?.reset();\n                }\n              }\n              await changeRoute(route, {\n                shouldScroll: false,\n                unstable_startTransition: startTransition,\n                signal: event.signal,\n              }).catch((err) => {\n                console.log('Error while navigating back:', err);\n              });\n            } else {\n              prefetchRoute(route);\n              try {\n                await changeRoute(route, {\n                  shouldScroll: false,\n                  unstable_startTransition: startTransition,\n                  signal: event.signal,\n                });\n              } catch (err) {\n                // Handle 404, etc here\n                customErrorHandlerRef.current?.setState({ error: err });\n                if (has404 && err) {\n                  const info = getErrorInfo(err);\n                  if (info?.status === 404) {\n                    await changeRoute(\n                      { path: '/404', query: '', hash: '' },\n                      {\n                        signal: event.signal,\n                        shouldScroll: false,\n                      },\n                    );\n                  }\n                }\n              }\n            }\n            if (signalRef.current === event.signal) {\n              signalRef.current = null;\n            }\n          });\n          await flushAsync();\n          return;\n        },\n        scroll: 'after-transition',\n      });\n    }) as EventListener;\n    window.navigation.addEventListener('navigate', callback);\n    return () => {\n      window.navigation.removeEventListener('navigate', callback);\n    };\n  }, [changeRoute, prefetchRoute, has404]);\n\n  // run after new route DOM mounted\n  useEffect(() => {\n    resolver.current?.(undefined);\n    resolver.current = null;\n  }, [route]);\n\n  const resolver = useRef<((value: undefined) => void) | null>(null);\n\n  async function flushAsync() {\n    const deferred = Promise.withResolvers();\n    resolver.current = deferred.resolve;\n    await deferred.promise;\n    return;\n  }\n\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler ref={customErrorHandlerRef} has404={has404}>\n        {routeElement}\n      </CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      <PendingContext value={isPending}>{rootElement}</PendingContext>\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n  unstable_routeInterceptor,\n}: {\n  initialRoute?: RouteProps;\n  unstable_routeInterceptor?: (route: RouteProps) => RouteProps | false;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter\n        initialRoute={initialRoute}\n        httpStatus={httpStatus}\n        routeInterceptor={unstable_routeInterceptor}\n      />\n    </Root>\n  );\n}\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n\n// Highly experimental to expose internal APIs\n// Subject to change without notice\nexport type Unstable_RouteProps = RouteProps;\nexport const unstable_HAS404_ID = HAS404_ID;\nexport const unstable_IS_STATIC_ID = IS_STATIC_ID;\nexport const unstable_ROUTE_ID = ROUTE_ID;\nexport const unstable_SKIP_HEADER = SKIP_HEADER;\nexport const unstable_encodeRoutePath = encodeRoutePath;\nexport const unstable_encodeSliceId = encodeSliceId;\nexport const unstable_getRouteSlotId = getRouteSlotId;\nexport const unstable_getSliceSlotId = getSliceSlotId;\nexport const unstable_getErrorInfo = getErrorInfo;\nexport const unstable_addBase = addBase;\nexport const unstable_removeBase = removeBase;\nexport const unstable_RouterContext = RouterContext;\nexport type Unstable_ChangeRoute = ChangeRoute;\nexport type Unstable_ChangeRouteEvent = ChangeRouteEvent;\nexport type Unstable_ChangeRouteCallback = ChangeRouteCallback;\nexport type Unstable_PrefetchRoute = PrefetchRoute;\nexport type Unstable_SliceId = SliceId;\nexport type Unstable_InferredPaths = InferredPaths;\nexport const unstable_parseRoute = parseRoute;\nexport const unstable_getHttpStatusFromMeta = getHttpStatusFromMeta;\n"],"names":["Component","createContext","use","useCallback","useEffect","useRef","useState","useTransition","preloadModule","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","savedRscParams","createRscParams","rscParams","URLSearchParams","PendingContext","usePending","RouterContext","useRouter","router","Error","route","prefetchRoute","push","to","navigation","navigate","replace","history","reload","back","forward","prefetch","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_prefetchOnEnter","unstable_prefetchOnView","refProp","props","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","onMouseEnter","event","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","state","getDerivedStateFromError","error","render","String","NotFound","has404","reset","changeRoute","shouldScroll","then","catch","err","console","log","Redirect","handledErrorSet","has","add","committed","Promise","resolve","setTimeout","trace","CustomErrorHandler","WeakSet","setState","info","status","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","finally","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","waku_new_path","defaultRouteInterceptor","InnerRouter","initialRoute","routeInterceptor","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","encodeURI","Object","keys","enhanceFetchRscInternal","signalRef","enhanceFetch","fetchFn","input","init","signal","skipStr","JSON","stringify","Array","from","map","i","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","setRoute","prev","customErrorHandlerRef","options","startTransitionFn","unstable_startTransition","fn","skipRefetch","aborted","__WAKU_ROUTER_PREFETCH__","as","isPending","startTransition","callback","canIntercept","downloadRequest","formData","hashChange","destination","navigationType","previousIndex","currentEntry","intercept","precommitHandler","warn","nextIndex","flushAsync","scroll","addEventListener","removeEventListener","resolver","deferred","withResolvers","promise","routeElement","rootElement","meta","value","Router","unstable_routeInterceptor","initialRscPath","initialRscParams","INTERNAL_ServerRouter","httpstatus","unstable_HAS404_ID","unstable_IS_STATIC_ID","unstable_ROUTE_ID","unstable_SKIP_HEADER","unstable_encodeRoutePath","unstable_encodeSliceId","unstable_getRouteSlotId","unstable_getSliceSlotId","unstable_getErrorInfo","unstable_addBase","unstable_removeBase","unstable_RouterContext","unstable_parseRoute","unstable_getHttpStatusFromMeta"],"mappings":"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"}

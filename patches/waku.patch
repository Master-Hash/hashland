diff --git a/dist/lib/utils/render.js b/dist/lib/utils/render.js
index dd1d832361b297579b7536bd1397346757940e7f..e913204b65e3a44c4eb8408b767ebb9145cac930 100644
--- a/dist/lib/utils/render.js
+++ b/dist/lib/utils/render.js
@@ -1,4 +1,11 @@
+import { encodeBase64 } from 'hono/utils/encode';
+const generateNonce = ()=>{
+    const arrayBuffer = new Uint8Array(16);
+    crypto.getRandomValues(arrayBuffer);
+    return 'toBase64' in arrayBuffer ? arrayBuffer.toBase64() : encodeBase64(arrayBuffer.buffer);
+};
 export function createRenderUtils(temporaryReferences, renderToReadableStream, createFromReadableStream, loadSsrEntryModule) {
+    const nonce = generateNonce();
     const onError = (e)=>{
         console.error('Error during rendering:', e);
         if (e && typeof e === 'object' && 'digest' in e && typeof e.digest === 'string') {
@@ -22,12 +29,14 @@ export function createRenderUtils(temporaryReferences, renderToReadableStream, c
             });
             const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {
                 formState: options?.actionResult,
-                rscPath: options?.rscPath
+                rscPath: options?.rscPath,
+                nonce
             });
             return new Response(htmlResult.stream, {
                 status: htmlResult.status || options?.status || 200,
                 headers: {
-                    'content-type': 'text/html'
+                    'content-type': 'text/html',
+                    'Content-Security-Policy': `script-src 'self' 'unsafe-eval' 'nonce-${nonce}'`
                 }
             });
         }
diff --git a/dist/lib/utils/render.js.map b/dist/lib/utils/render.js.map
index 54e9f4b0ccbbbc0383d457dc897018814abce1a2..e15b5890200abb4d393bb88ca808688d7e57665b 100644
--- a/dist/lib/utils/render.js.map
+++ b/dist/lib/utils/render.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../../src/lib/utils/render.ts"],"sourcesContent":["import type {\n  Unstable_ParseRsc,\n  Unstable_RenderHtml,\n  Unstable_RenderRsc,\n} from '../types.js';\n\nexport function createRenderUtils(\n  temporaryReferences: unknown,\n  renderToReadableStream: (data: unknown, options?: object) => ReadableStream,\n  createFromReadableStream: (\n    stream: ReadableStream,\n    options?: object,\n  ) => Promise<unknown>,\n  loadSsrEntryModule: () => Promise<\n    typeof import('../vite-entries/entry.ssr.js')\n  >,\n): {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n} {\n  const onError = (e: unknown) => {\n    console.error('Error during rendering:', e);\n    if (\n      e &&\n      typeof e === 'object' &&\n      'digest' in e &&\n      typeof e.digest === 'string'\n    ) {\n      return e.digest;\n    }\n  };\n\n  return {\n    async renderRsc(elements) {\n      return renderToReadableStream(elements, {\n        temporaryReferences,\n        onError,\n      });\n    },\n    async parseRsc(stream) {\n      return createFromReadableStream(stream, {}) as Promise<\n        Record<string, unknown>\n      >;\n    },\n    async renderHtml(\n      elementsStream,\n      html,\n      options?: { rscPath?: string; actionResult?: any; status?: number },\n    ) {\n      const { INTERNAL_renderHtmlStream: renderHtmlStream } =\n        await loadSsrEntryModule();\n\n      const rscHtmlStream = renderToReadableStream(html, {\n        onError,\n      });\n      const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {\n        formState: options?.actionResult,\n        rscPath: options?.rscPath,\n      });\n      return new Response(htmlResult.stream, {\n        status: htmlResult.status || options?.status || 200,\n        headers: { 'content-type': 'text/html' },\n      });\n    },\n  };\n}\n"],"names":["createRenderUtils","temporaryReferences","renderToReadableStream","createFromReadableStream","loadSsrEntryModule","onError","e","console","error","digest","renderRsc","elements","parseRsc","stream","renderHtml","elementsStream","html","options","INTERNAL_renderHtmlStream","renderHtmlStream","rscHtmlStream","htmlResult","formState","actionResult","rscPath","Response","status","headers"],"mappings":"AAMA,OAAO,SAASA,kBACdC,mBAA4B,EAC5BC,sBAA2E,EAC3EC,wBAGqB,EACrBC,kBAEC;IAMD,MAAMC,UAAU,CAACC;QACfC,QAAQC,KAAK,CAAC,2BAA2BF;QACzC,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEG,MAAM,KAAK,UACpB;YACA,OAAOH,EAAEG,MAAM;QACjB;IACF;IAEA,OAAO;QACL,MAAMC,WAAUC,QAAQ;YACtB,OAAOT,uBAAuBS,UAAU;gBACtCV;gBACAI;YACF;QACF;QACA,MAAMO,UAASC,MAAM;YACnB,OAAOV,yBAAyBU,QAAQ,CAAC;QAG3C;QACA,MAAMC,YACJC,cAAc,EACdC,IAAI,EACJC,OAAmE;YAEnE,MAAM,EAAEC,2BAA2BC,gBAAgB,EAAE,GACnD,MAAMf;YAER,MAAMgB,gBAAgBlB,uBAAuBc,MAAM;gBACjDX;YACF;YACA,MAAMgB,aAAa,MAAMF,iBAAiBJ,gBAAgBK,eAAe;gBACvEE,WAAWL,SAASM;gBACpBC,SAASP,SAASO;YACpB;YACA,OAAO,IAAIC,SAASJ,WAAWR,MAAM,EAAE;gBACrCa,QAAQL,WAAWK,MAAM,IAAIT,SAASS,UAAU;gBAChDC,SAAS;oBAAE,gBAAgB;gBAAY;YACzC;QACF;IACF;AACF"}
\ No newline at end of file
+{"version":3,"sources":["../../../src/lib/utils/render.ts"],"sourcesContent":["import { encodeBase64 } from 'hono/utils/encode';\nimport type {\n  Unstable_ParseRsc,\n  Unstable_RenderHtml,\n  Unstable_RenderRsc,\n} from '../types.js';\n\nconst generateNonce = () => {\n  const arrayBuffer = new Uint8Array(16);\n  crypto.getRandomValues(arrayBuffer);\n  return 'toBase64' in arrayBuffer\n    ? // @ts-expect-error toBase64 is not in the type definition\n      arrayBuffer.toBase64()\n    : encodeBase64(arrayBuffer.buffer);\n};\n\nexport function createRenderUtils(\n  temporaryReferences: unknown,\n  renderToReadableStream: (data: unknown, options?: object) => ReadableStream,\n  createFromReadableStream: (\n    stream: ReadableStream,\n    options?: object,\n  ) => Promise<unknown>,\n  loadSsrEntryModule: () => Promise<\n    typeof import('../vite-entries/entry.ssr.js')\n  >,\n): {\n  renderRsc: Unstable_RenderRsc;\n  parseRsc: Unstable_ParseRsc;\n  renderHtml: Unstable_RenderHtml;\n} {\n  const nonce = generateNonce();\n  const onError = (e: unknown) => {\n    console.error('Error during rendering:', e);\n    if (\n      e &&\n      typeof e === 'object' &&\n      'digest' in e &&\n      typeof e.digest === 'string'\n    ) {\n      return e.digest;\n    }\n  };\n\n  return {\n    async renderRsc(elements) {\n      return renderToReadableStream(elements, {\n        temporaryReferences,\n        onError,\n      });\n    },\n    async parseRsc(stream) {\n      return createFromReadableStream(stream, {}) as Promise<\n        Record<string, unknown>\n      >;\n    },\n    async renderHtml(\n      elementsStream,\n      html,\n      options?: { rscPath?: string; actionResult?: any; status?: number },\n    ) {\n      const { INTERNAL_renderHtmlStream: renderHtmlStream } =\n        await loadSsrEntryModule();\n\n      const rscHtmlStream = renderToReadableStream(html, {\n        onError,\n      });\n      const htmlResult = await renderHtmlStream(elementsStream, rscHtmlStream, {\n        formState: options?.actionResult,\n        rscPath: options?.rscPath,\n        nonce,\n      });\n      return new Response(htmlResult.stream, {\n        status: htmlResult.status || options?.status || 200,\n        headers: {\n          'content-type': 'text/html',\n          'Content-Security-Policy': `script-src 'self' 'unsafe-eval' 'nonce-${nonce}'`,\n        },\n      });\n    },\n  };\n}\n"],"names":["encodeBase64","generateNonce","arrayBuffer","Uint8Array","crypto","getRandomValues","toBase64","buffer","createRenderUtils","temporaryReferences","renderToReadableStream","createFromReadableStream","loadSsrEntryModule","nonce","onError","e","console","error","digest","renderRsc","elements","parseRsc","stream","renderHtml","elementsStream","html","options","INTERNAL_renderHtmlStream","renderHtmlStream","rscHtmlStream","htmlResult","formState","actionResult","rscPath","Response","status","headers"],"mappings":"AAAA,SAASA,YAAY,QAAQ,oBAAoB;AAOjD,MAAMC,gBAAgB;IACpB,MAAMC,cAAc,IAAIC,WAAW;IACnCC,OAAOC,eAAe,CAACH;IACvB,OAAO,cAAcA,cAEjBA,YAAYI,QAAQ,KACpBN,aAAaE,YAAYK,MAAM;AACrC;AAEA,OAAO,SAASC,kBACdC,mBAA4B,EAC5BC,sBAA2E,EAC3EC,wBAGqB,EACrBC,kBAEC;IAMD,MAAMC,QAAQZ;IACd,MAAMa,UAAU,CAACC;QACfC,QAAQC,KAAK,CAAC,2BAA2BF;QACzC,IACEA,KACA,OAAOA,MAAM,YACb,YAAYA,KACZ,OAAOA,EAAEG,MAAM,KAAK,UACpB;YACA,OAAOH,EAAEG,MAAM;QACjB;IACF;IAEA,OAAO;QACL,MAAMC,WAAUC,QAAQ;YACtB,OAAOV,uBAAuBU,UAAU;gBACtCX;gBACAK;YACF;QACF;QACA,MAAMO,UAASC,MAAM;YACnB,OAAOX,yBAAyBW,QAAQ,CAAC;QAG3C;QACA,MAAMC,YACJC,cAAc,EACdC,IAAI,EACJC,OAAmE;YAEnE,MAAM,EAAEC,2BAA2BC,gBAAgB,EAAE,GACnD,MAAMhB;YAER,MAAMiB,gBAAgBnB,uBAAuBe,MAAM;gBACjDX;YACF;YACA,MAAMgB,aAAa,MAAMF,iBAAiBJ,gBAAgBK,eAAe;gBACvEE,WAAWL,SAASM;gBACpBC,SAASP,SAASO;gBAClBpB;YACF;YACA,OAAO,IAAIqB,SAASJ,WAAWR,MAAM,EAAE;gBACrCa,QAAQL,WAAWK,MAAM,IAAIT,SAASS,UAAU;gBAChDC,SAAS;oBACP,gBAAgB;oBAChB,2BAA2B,CAAC,uCAAuC,EAAEvB,MAAM,CAAC,CAAC;gBAC/E;YACF;QACF;IACF;AACF"}
\ No newline at end of file
diff --git a/dist/router/client.d.ts b/dist/router/client.d.ts
index 46dac8d36ed164cc5853e4756ef88684385cdbf5..571ead8bf84ff5376707d701314085c3d418ee37 100644
--- a/dist/router/client.d.ts
+++ b/dist/router/client.d.ts
@@ -1,38 +1,20 @@
 import { Component } from 'react';
-import type { AnchorHTMLAttributes, ReactElement, ReactNode, Ref, TransitionFunction } from 'react';
+import type { AnchorHTMLAttributes, ReactElement, ReactNode, Ref } from 'react';
 import type { RouteConfig } from './base-types.js';
 import type { RouteProps } from './common.js';
 type AllowPathDecorators<Path extends string> = Path extends unknown ? Path | `${Path}?${string}` | `${Path}#${string}` : never;
 type InferredPaths = RouteConfig extends {
     paths: infer UserPaths extends string;
 } ? AllowPathDecorators<UserPaths> : string;
-type ChangeRouteEvent = 'start' | 'complete';
-type ChangeRouteCallback = (route: RouteProps) => void;
 type SliceId = string;
+export declare function usePending(): boolean;
 export declare function useRouter(): {
-    push: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
-    replace: (to: InferredPaths, options?: {
-        /**
-         * indicates if the link should scroll or not on navigation
-         * - `true`: always scroll
-         * - `false`: never scroll
-         * - `undefined`: scroll on path change (not on searchParams change)
-         */
-        scroll?: boolean;
-    }) => Promise<void>;
+    push: (to: InferredPaths) => void;
+    replace: (to: InferredPaths) => void;
     reload: () => Promise<void>;
     back: () => void;
     forward: () => void;
     prefetch: (to: string) => void;
-    unstable_events: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
     path: string;
     query: string;
     hash: string;
@@ -40,23 +22,14 @@ export declare function useRouter(): {
 export type LinkProps = {
     to: InferredPaths;
     children: ReactNode;
-    /**
-     * indicates if the link should scroll or not on navigation
-     * - `true`: always scroll
-     * - `false`: never scroll
-     * - `undefined`: scroll on path change (not on searchParams change)
-     */
-    scroll?: boolean;
-    unstable_pending?: ReactNode;
-    unstable_notPending?: ReactNode;
     unstable_prefetchOnEnter?: boolean;
     unstable_prefetchOnView?: boolean;
-    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
     ref?: Ref<HTMLAnchorElement> | undefined;
 } & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
-export declare function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }: LinkProps): ReactElement;
+export declare function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }: LinkProps): ReactElement;
 export declare class ErrorBoundary extends Component<{
     children: ReactNode;
+    error?: unknown;
 }, {
     error?: unknown;
 }> {
diff --git a/dist/router/client.js b/dist/router/client.js
index 0a31f0e879d581320d7bf33aa8a6899e0271df5c..7175f86cf082419301559c0bf087a8230def37e3 100644
--- a/dist/router/client.js
+++ b/dist/router/client.js
@@ -1,6 +1,6 @@
 'use client';
 import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
-import { Component, createContext, startTransition, use, useCallback, useContext, useEffect, useRef, useState, useTransition } from 'react';
+import { Component, createContext, use, useCallback, useEffect, useRef, useState, useTransition } from 'react';
 import { getErrorInfo } from '../lib/utils/custom-errors.js';
 import { addBase, removeBase } from '../lib/utils/path.js';
 import { Root, Slot, prefetchRsc, useElementsPromise_UNSTABLE as useElementsPromise, useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal, useRefetch } from '../minimal/client.js';
@@ -43,7 +43,6 @@ const parseRouteFromLocation = ()=>{
     }
     return parseRoute(new URL(window.location.href));
 };
-const isAltClick = (event)=>event.button !== 0 || !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
 let savedRscParams;
 const createRscParams = (query)=>{
     if (savedRscParams && savedRscParams[0] === query) {
@@ -58,60 +57,49 @@ const createRscParams = (query)=>{
     ];
     return rscParams;
 };
+const PendingContext = /*#__PURE__*/ createContext(false);
+// Not sure whether this is necessary
+// We have navigation.transition
+// but it's not reactive
+export function usePending() {
+    return use(PendingContext);
+}
 // This is an internal thing, not a public API
 const RouterContext = /*#__PURE__*/ createContext(null);
 export function useRouter() {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { route, changeRoute, prefetchRoute } = router;
-    const push = useCallback(async (to, options)=>{
+    const { route, prefetchRoute } = router;
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const push = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
-        });
-        if (window.location.pathname === currentPath) {
-            window.history.pushState({
-                ...window.history.state,
-                waku_new_path: newPath
-            }, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const replace = useCallback(async (to, options)=>{
+        window.navigation.navigate(to);
+    }, []);
+    /**
+   * @deprecated use window.navigation.navigate() instead
+   */ const replace = useCallback((to)=>{
         to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-        const url = new URL(to, window.location.href);
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        await changeRoute(parseRoute(url), {
-            shouldScroll: options?.scroll ?? newPath
+        window.navigation.navigate(to, {
+            history: 'replace'
         });
-        if (window.location.pathname === currentPath) {
-            window.history.replaceState(window.history.state, '', url);
-        }
-    }, [
-        changeRoute
-    ]);
-    const reload = useCallback(async ()=>{
-        const url = new URL(window.location.href);
-        await changeRoute(parseRoute(url), {
-            shouldScroll: true
-        });
-    }, [
-        changeRoute
-    ]);
-    const back = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.back();
     }, []);
-    const forward = useCallback(()=>{
-        // FIXME is this correct?
-        window.history.forward();
+    /**
+   * @deprecated use window.navigation.reload() instead
+   */ const reload = useCallback(async ()=>{
+        window.navigation.reload();
+    }, []);
+    /**
+   * @deprecated use window.navigation.back() instead
+   */ const back = useCallback(()=>{
+        window.navigation.back();
+    }, []);
+    /**
+   * @deprecated use window.navigation.forward() instead
+   */ const forward = useCallback(()=>{
+        window.navigation.forward();
     }, []);
     const prefetch = useCallback((to)=>{
         const url = new URL(to, window.location.href);
@@ -126,8 +114,7 @@ export function useRouter() {
         reload,
         back,
         forward,
-        prefetch,
-        unstable_events: router.routeChangeEvents
+        prefetch
     };
 }
 function useSharedRef(ref) {
@@ -163,17 +150,12 @@ function useSharedRef(ref) {
         handleRef
     ];
 }
-export function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }) {
+export function Link({ to, children, unstable_prefetchOnEnter, unstable_prefetchOnView, ref: refProp, ...props }) {
     to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
-    const router = useContext(RouterContext);
-    const changeRoute = router ? router.changeRoute : ()=>{
-        throw new Error('Missing Router');
-    };
+    const router = use(RouterContext);
     const prefetchRoute = router ? router.prefetchRoute : ()=>{
         throw new Error('Missing Router');
     };
-    const [isPending, startTransition] = useTransition();
-    const startTransitionFn = unstable_startTransition || (unstable_pending || unstable_notPending) && startTransition || ((fn)=>fn());
     const [ref, setRef] = useSharedRef(refProp);
     useEffect(()=>{
         if (unstable_prefetchOnView && ref.current) {
@@ -201,40 +183,6 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
         to,
         ref
     ]);
-    const internalOnClick = ()=>{
-        const url = new URL(to, window.location.href);
-        if (url.href !== window.location.href) {
-            const route = parseRoute(url);
-            prefetchRoute(route);
-            startTransitionFn(async ()=>{
-                const currentPath = window.location.pathname;
-                const newPath = url.pathname !== currentPath;
-                try {
-                    await changeRoute(route, {
-                        shouldScroll: scroll ?? newPath,
-                        unstable_startTransition: startTransitionFn
-                    });
-                } finally{
-                    if (window.location.pathname === currentPath) {
-                        // Update history if it wasn't already updated
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: newPath
-                        }, '', url);
-                    }
-                }
-            });
-        }
-    };
-    const onClick = (event)=>{
-        if (props.onClick) {
-            props.onClick(event);
-        }
-        if (!event.defaultPrevented && !isAltClick(event)) {
-            event.preventDefault();
-            internalOnClick();
-        }
-    };
     const onMouseEnter = unstable_prefetchOnEnter ? (event)=>{
         const url = new URL(to, window.location.href);
         if (url.href !== window.location.href) {
@@ -246,27 +194,10 @@ export function Link({ to, children, scroll, unstable_pending, unstable_notPendi
     const ele = /*#__PURE__*/ _jsx("a", {
         ...props,
         href: to,
-        onClick: onClick,
         onMouseEnter: onMouseEnter,
         ref: setRef,
         children: children
     });
-    if (isPending && unstable_pending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_pending
-            ]
-        });
-    }
-    if (!isPending && unstable_notPending !== undefined) {
-        return /*#__PURE__*/ _jsxs(_Fragment, {
-            children: [
-                ele,
-                unstable_notPending
-            ]
-        });
-    }
     return ele;
 }
 const notAvailableInServer = (name)=>()=>{
@@ -316,17 +247,18 @@ export class ErrorBoundary extends Component {
         };
     }
     render() {
-        if ('error' in this.state) {
-            if (this.state.error instanceof Error) {
-                return renderError(this.state.error.message);
+        if ('error' in this.state || 'error' in this.props) {
+            const error = this.state.error ?? this.props.error;
+            if (error instanceof Error) {
+                return renderError(error.message);
             }
-            return renderError(String(this.state.error));
+            return renderError(String(error));
         }
         return this.props.children;
     }
 }
 const NotFound = ({ has404, reset })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -335,13 +267,9 @@ const NotFound = ({ has404, reset })=>{
         if (has404) {
             const url = new URL('/404', window.location.href);
             changeRoute(parseRoute(url), {
-                shouldScroll: true
+                shouldScroll: false
             }).then(()=>{
-                // HACK: This timeout is required for canary-ci to work
-                // FIXME: As we understand it, we should have a proper solution.
-                setTimeout(()=>{
-                    reset();
-                }, 1);
+                reset();
             }).catch((err)=>{
                 console.log('Error while navigating to 404:', err);
             });
@@ -356,11 +284,10 @@ const NotFound = ({ has404, reset })=>{
     });
 };
 const Redirect = ({ error, to, reset, handledErrorSet })=>{
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
-    const { changeRoute } = router;
     useEffect(()=>{
         // ensure single re-fetch per server redirection error on StrictMode
         // https://github.com/wakujs/waku/pull/1512
@@ -369,62 +296,45 @@ const Redirect = ({ error, to, reset, handledErrorSet })=>{
         }
         handledErrorSet.add(error);
         const url = new URL(to, window.location.href);
-        // FIXME this condition seems too naive
-        if (url.hostname !== window.location.hostname) {
-            window.location.replace(to);
-            return;
-        }
-        const currentPath = window.location.pathname;
-        const newPath = url.pathname !== currentPath;
-        changeRoute(parseRoute(url), {
-            shouldScroll: newPath
-        }).then(()=>{
-            // FIXME: As we understand it, we should have a proper solution.
-            setTimeout(()=>{
-                reset();
-            }, 1);
-        }).catch((err)=>{
-            console.log('Error while navigating to redirect:', err);
-        }).finally(()=>{
-            if (window.location.pathname === currentPath) {
-                window.history.replaceState({
-                    ...window.history.state,
-                    waku_new_path: newPath
-                }, '', url);
-            }
+        window.navigation.navigate(url, {
+            history: 'push'
+        }).committed?.then(()=>{
+            // FIXME
+            // ssr-redirect > access sync page with client navigation
+            return new Promise((resolve)=>setTimeout(resolve, 200));
+        })?.then(()=>{
+            console.trace('Redirected to', to);
+            reset();
         });
     }, [
         error,
-        to,
+        handledErrorSet,
         reset,
-        changeRoute,
-        handledErrorSet
+        to
     ]);
     return null;
 };
 class CustomErrorHandler extends Component {
-    handledErrorSet = new WeakSet();
+    #handledErrorSet = new WeakSet();
     constructor(props){
         super(props);
         this.state = {
             error: null
         };
-        this.reset = this.reset.bind(this);
     }
     static getDerivedStateFromError(error) {
         return {
             error
         };
     }
-    reset() {
+    reset = ()=>{
         this.setState({
             error: null
         });
-    }
+    };
     render() {
-        const { error } = this.state;
-        if (error !== null) {
-            const info = getErrorInfo(error);
+        if (this.state.error !== null) {
+            const info = getErrorInfo(this.state.error);
             if (info?.status === 404) {
                 return /*#__PURE__*/ _jsx(NotFound, {
                     has404: this.props.has404,
@@ -433,24 +343,24 @@ class CustomErrorHandler extends Component {
             }
             if (info?.location) {
                 return /*#__PURE__*/ _jsx(Redirect, {
-                    error: error,
+                    error: this.state.error,
                     to: info.location,
                     reset: this.reset,
-                    handledErrorSet: this.handledErrorSet
+                    handledErrorSet: this.#handledErrorSet
                 });
             }
-            throw error;
+            return /*#__PURE__*/ _jsx(ErrorBoundary, {
+                error: this.state.error,
+                children: null
+            });
         }
         return this.props.children;
     }
 }
-const ThrowError = ({ error })=>{
-    throw error;
-};
 const getRouteSlotId = (path)=>'route:' + decodeURI(path);
 const getSliceSlotId = (id)=>'slice:' + id;
 export function Slice({ id, children, ...props }) {
-    const router = useContext(RouterContext);
+    const router = use(RouterContext);
     if (!router) {
         throw new Error('Missing Router');
     }
@@ -530,7 +440,7 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             if (routeData) {
                 const [path, _query] = routeData;
                 if (isStatic) {
-                    staticPathSetRef.current.add(path);
+                    staticPathSetRef.current.add(encodeURI(path));
                 }
             }
             cachedIdSetRef.current = new Set(Object.keys(rest));
@@ -539,11 +449,14 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
         elementsPromise
     ]);
     const enhanceFetchRscInternal = useEnhanceFetchRscInternal();
-    const locationListenersRef = useRef(new Set());
-    const locationListeners = locationListenersRef.current;
+    // It doesn't have to be a ref
+    // But passing it to multiple function calls is too complicated
+    const signalRef = useRef(null);
     useEffect(()=>{
-        const enhanceFetch = (fetchFn)=>(input, init = {})=>{
-                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));
+        const enhanceFetch = (fetchFn)=>(input, init = {
+                signal: signalRef.current
+            })=>{
+                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current).map((i)=>encodeURI(i)));
                 const headers = init.headers ||= {};
                 if (Array.isArray(headers)) {
                     headers.push([
@@ -562,16 +475,18 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
                     const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } = elements;
                     if (routeData) {
                         const [path, query] = routeData;
-                        if (requestedRouteRef.current.path !== path || !isStatic && requestedRouteRef.current.query !== query) {
-                            locationListeners.forEach((listener)=>listener(path, query));
+                        if (requestedRouteRef.current.path !== encodeURI(path) || !isStatic && requestedRouteRef.current.query !== query) {
+                            // redirected
+                            window.navigation.navigate(path, {
+                                history: 'push'
+                            });
                         }
                     }
                 }).catch(()=>{});
                 return elementsPromise;
             });
     }, [
-        enhanceFetchRscInternal,
-        locationListeners
+        enhanceFetchRscInternal
     ]);
     const refetch = useRefetch();
     const [route, setRoute] = useState(()=>({
@@ -582,38 +497,6 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             ...initialRoute,
             hash: ''
         }));
-    const routeChangeListenersRef = useRef(null);
-    if (routeChangeListenersRef.current === null) {
-        const listeners = {
-            start: new Set(),
-            complete: new Set()
-        };
-        const executeListeners = (eventType, eventRoute)=>{
-            const eventListenersSet = listeners[eventType];
-            if (!eventListenersSet.size) {
-                return;
-            }
-            for (const listener of eventListenersSet){
-                listener(eventRoute);
-            }
-        };
-        const events = (()=>{
-            const on = (event, handler)=>{
-                listeners[event].add(handler);
-            };
-            const off = (event, handler)=>{
-                listeners[event].delete(handler);
-            };
-            return {
-                on,
-                off
-            };
-        })();
-        routeChangeListenersRef.current = [
-            events,
-            executeListeners
-        ];
-    }
     // Update the route post-load to include the current hash.
     useEffect(()=>{
         setRoute((prev)=>{
@@ -625,16 +508,11 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
     }, [
         initialRoute
     ]);
-    const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;
-    const [err, setErr] = useState(null);
-    // FIXME this "refetching" hack doesn't seem ideal.
-    const refetching = useRef(null);
+    const customErrorHandlerRef = useRef(null);
     const changeRoute = useCallback(async (route, options)=>{
         requestedRouteRef.current = route;
-        executeListeners('start', route);
         const startTransitionFn = options.unstable_startTransition || ((fn)=>fn());
-        refetching.current = [];
-        setErr(null);
+        customErrorHandlerRef.current?.reset();
         const { skipRefetch } = options || {};
         if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {
             const rscPath = encodeRoutePath(route.path);
@@ -642,22 +520,28 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             try {
                 await refetch(rscPath, rscParams);
             } catch (e) {
-                refetching.current = null;
-                setErr(e);
-                throw e;
+                if (e instanceof Error && e.name === 'AbortError') {
+                // Noop
+                } else {
+                    // Workaround: after setErr, CustomErrorHandler is not rerendered!
+                    // Why is that?
+                    // Luckily this is not on happy path.
+                    // Update: this causes more bugs.
+                    // flushSync(() => {
+                    // });
+                    throw e;
+                }
             }
         }
         startTransitionFn(()=>{
-            if (options.shouldScroll) {
-                handleScroll();
+            if (!options.signal?.aborted) {
+                if (options.shouldScroll) {
+                    handleScroll();
+                }
+                setRoute(route);
             }
-            setRoute(route);
-            refetching.current[0]?.();
-            refetching.current = null;
-            executeListeners('complete', route);
         });
     }, [
-        executeListeners,
         refetch
     ]);
     const prefetchRoute = useCallback((route)=>{
@@ -669,60 +553,126 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
         prefetchRsc(rscPath, rscParams);
         globalThis.__WAKU_ROUTER_PREFETCH__?.(route.path);
     }, []);
+    const [isPending, startTransition] = useTransition();
+    // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js
     useEffect(()=>{
-        const callback = ()=>{
-            const route = parseRoute(new URL(window.location.href));
-            changeRoute(route, {
-                shouldScroll: true
-            }).catch((err)=>{
-                console.log('Error while navigating back:', err);
+        const callback = (event)=>{
+            if (!event.canIntercept || // If this is a download,
+            // let the browser perform the download.
+            event.downloadRequest || // If this is a form submission,
+            // let that go to the server.
+            event.formData) {
+                return;
+            } else if (// If this is just a hashChange,
+            // just let the browser handle scrolling to the content.
+            event.hashChange) {
+                setRoute((prev)=>({
+                        ...prev,
+                        hash: new URL(event.destination.url).hash
+                    }));
+                return;
+            }
+            const url = new URL(event.destination.url);
+            const route = parseRoute(url);
+            // console.log(event);
+            const navigationType = event.navigationType;
+            const previousIndex = window.navigation.currentEntry.index;
+            event.intercept({
+                async precommitHandler () {
+                    if (signalRef.current) {
+                        // It happens when click very fast.
+                        console.warn('Potential race condition due to rapid navigation.');
+                    }
+                    signalRef.current = event.signal;
+                    startTransition(async ()=>{
+                        // addTransitionType('navigation-' + navigationType);
+                        if (navigationType === 'traverse') {
+                            // For traverse types it's useful to distinguish going back or forward.
+                            const nextIndex = event.destination.index;
+                            if (nextIndex > previousIndex) {
+                            // addTransitionType('navigation-forward');
+                            } else if (nextIndex < previousIndex) {
+                            // addTransitionType('navigation-back');
+                            }
+                            const err = customErrorHandlerRef.current?.state.error;
+                            if (err) {
+                                const info = getErrorInfo(err);
+                                if (info?.status === 404) {
+                                    // if 404 sans 404.tsx, manually go back
+                                    // should make CustomErrorHandler state
+                                    // Haha, upstream is broken too
+                                    customErrorHandlerRef.current?.reset();
+                                }
+                            }
+                            await changeRoute(route, {
+                                shouldScroll: false,
+                                unstable_startTransition: startTransition,
+                                signal: event.signal
+                            }).catch((err)=>{
+                                console.log('Error while navigating back:', err);
+                            });
+                        } else {
+                            prefetchRoute(route);
+                            try {
+                                await changeRoute(route, {
+                                    shouldScroll: false,
+                                    unstable_startTransition: startTransition,
+                                    signal: event.signal
+                                });
+                            } catch (err) {
+                                // Handle 404, etc here
+                                customErrorHandlerRef.current?.setState({
+                                    error: err
+                                });
+                                if (has404 && err) {
+                                    const info = getErrorInfo(err);
+                                    if (info?.status === 404) {
+                                        await changeRoute({
+                                            path: '/404',
+                                            query: '',
+                                            hash: ''
+                                        }, {
+                                            signal: event.signal,
+                                            shouldScroll: false
+                                        });
+                                    }
+                                }
+                            }
+                        }
+                        if (signalRef.current === event.signal) {
+                            signalRef.current = null;
+                        }
+                    });
+                    await flushAsync();
+                    return;
+                },
+                scroll: 'after-transition'
             });
         };
-        window.addEventListener('popstate', callback);
+        window.navigation.addEventListener('navigate', callback);
         return ()=>{
-            window.removeEventListener('popstate', callback);
+            window.navigation.removeEventListener('navigate', callback);
         };
     }, [
-        changeRoute
+        changeRoute,
+        prefetchRoute,
+        has404
     ]);
+    // run after new route DOM mounted
     useEffect(()=>{
-        const callback = (path, query)=>{
-            const fn = ()=>{
-                const url = new URL(window.location.href);
-                url.pathname = path;
-                url.search = query;
-                url.hash = '';
-                changeRoute(parseRoute(url), {
-                    skipRefetch: true,
-                    shouldScroll: false
-                }).catch((err)=>{
-                    console.log('Error while handling location listeners:', err);
-                }).finally(()=>{
-                    if (path !== '/404') {
-                        window.history.pushState({
-                            ...window.history.state,
-                            waku_new_path: url.pathname !== window.location.pathname
-                        }, '', url);
-                    }
-                });
-            };
-            if (refetching.current) {
-                refetching.current.push(fn);
-            } else {
-                startTransition(fn);
-            }
-        };
-        locationListeners.add(callback);
-        return ()=>{
-            locationListeners.delete(callback);
-        };
+        resolver.current?.(undefined);
+        resolver.current = null;
     }, [
-        changeRoute,
-        locationListeners
+        route
     ]);
-    const routeElement = err !== null ? /*#__PURE__*/ _jsx(ThrowError, {
-        error: err
-    }) : /*#__PURE__*/ _jsx(Slot, {
+    const resolver = useRef(null);
+    async function flushAsync() {
+        const deferred = Promise.withResolvers();
+        resolver.current = deferred.resolve;
+        await deferred.promise;
+        return;
+    }
+    const routeElement = /*#__PURE__*/ _jsx(Slot, {
         id: getRouteSlotId(route.path)
     });
     const rootElement = /*#__PURE__*/ _jsxs(Slot, {
@@ -733,6 +683,7 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
                 content: httpStatus
             }),
             /*#__PURE__*/ _jsx(CustomErrorHandler, {
+                ref: customErrorHandlerRef,
                 has404: has404,
                 children: routeElement
             })
@@ -743,10 +694,12 @@ const InnerRouter = ({ initialRoute, httpStatus })=>{
             route,
             changeRoute,
             prefetchRoute,
-            routeChangeEvents,
             fetchingSlices: useRef(new Set()).current
         },
-        children: rootElement
+        children: /*#__PURE__*/ _jsx(PendingContext, {
+            value: isPending,
+            children: rootElement
+        })
     });
 };
 export function Router({ initialRoute = parseRouteFromLocation() }) {
@@ -762,10 +715,6 @@ export function Router({ initialRoute = parseRouteFromLocation() }) {
         })
     });
 }
-const MOCK_ROUTE_CHANGE_LISTENER = {
-    on: ()=>notAvailableInServer('routeChange:on'),
-    off: ()=>notAvailableInServer('routeChange:off')
-};
 /**
  * ServerRouter for SSR
  * This is not a public API.
@@ -789,7 +738,6 @@ const MOCK_ROUTE_CHANGE_LISTENER = {
                 route,
                 changeRoute: notAvailableInServer('changeRoute'),
                 prefetchRoute: notAvailableInServer('prefetchRoute'),
-                routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,
                 fetchingSlices: new Set()
             },
             children: rootElement
diff --git a/dist/router/client.js.map b/dist/router/client.js.map
index a5253a492c37b8d9282d640e37821d10e18fa96b..938ab4cab2f34140a34a3824b94f60442f785626 100644
--- a/dist/router/client.js.map
+++ b/dist/router/client.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  startTransition,\n  use,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nconst isAltClick = (event: MouseEvent<HTMLAnchorElement>) =>\n  event.button !== 0 ||\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype ChangeRouteEvent = 'start' | 'complete';\n\ntype ChangeRouteCallback = (route: RouteProps) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  routeChangeEvents: Record<\n    'on' | 'off',\n    (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n  >;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n      }\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.replaceState(window.history.state, '', url);\n      }\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(async () => {\n    const url = new URL(window.location.href);\n    await changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n    unstable_events: router.routeChangeEvents,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: TransitionFunction) => fn());\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const internalOnClick = () => {\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(async () => {\n        const currentPath = window.location.pathname;\n        const newPath = url.pathname !== currentPath;\n        try {\n          await changeRoute(route, {\n            shouldScroll: scroll ?? newPath,\n            unstable_startTransition: startTransitionFn,\n          });\n        } finally {\n          if (window.location.pathname === currentPath) {\n            // Update history if it wasn't already updated\n            window.history.pushState(\n              {\n                ...window.history.state,\n                waku_new_path: newPath,\n              },\n              '',\n              url,\n            );\n          }\n        }\n      });\n    }\n  };\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    if (props.onClick) {\n      props.onClick(event);\n    }\n    if (!event.defaultPrevented && !isAltClick(event)) {\n      event.preventDefault();\n      internalOnClick();\n    }\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a\n      {...props}\n      href={to}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={setRef}\n    >\n      {children}\n    </a>\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_pending}\n      </>\n    );\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_notPending}\n      </>\n    );\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true })\n        .then(() => {\n          // HACK: This timeout is required for canary-ci to work\n          // FIXME: As we understand it, we should have a proper solution.\n          setTimeout(() => {\n            reset();\n          }, 1);\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const currentPath = window.location.pathname;\n    const newPath = url.pathname !== currentPath;\n    changeRoute(parseRoute(url), { shouldScroll: newPath })\n      .then(() => {\n        // FIXME: As we understand it, we should have a proper solution.\n        setTimeout(() => {\n          reset();\n        }, 1);\n      })\n      .catch((err) => {\n        console.log('Error while navigating to redirect:', err);\n      })\n      .finally(() => {\n        if (window.location.pathname === currentPath) {\n          window.history.replaceState(\n            {\n              ...window.history.state,\n              waku_new_path: newPath,\n            },\n            '',\n            url,\n          );\n        }\n      });\n  }, [error, to, reset, changeRoute, handledErrorSet]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  private handledErrorSet = new WeakSet();\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.handledErrorSet}\n          />\n        );\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst ThrowError = ({ error }: { error: unknown }) => {\n  throw error;\n};\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(path);\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  const locationListenersRef = useRef(\n    new Set<(path: string, query: string) => void>(),\n  );\n  const locationListeners = locationListenersRef.current;\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (input: RequestInfo | URL, init: RequestInit = {}) => {\n        const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== path ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  locationListeners.forEach((listener) =>\n                    listener(path, query),\n                  );\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal, locationListeners]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  const routeChangeListenersRef =\n    useRef<\n      [\n        Record<\n          'on' | 'off',\n          (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n        >,\n        (\n          eventType: ChangeRouteEvent,\n          eventRoute: Parameters<ChangeRouteCallback>[0],\n        ) => void,\n      ]\n    >(null);\n  if (routeChangeListenersRef.current === null) {\n    const listeners: Record<ChangeRouteEvent, Set<ChangeRouteCallback>> = {\n      start: new Set(),\n      complete: new Set(),\n    };\n    const executeListeners = (\n      eventType: ChangeRouteEvent,\n      eventRoute: Parameters<ChangeRouteCallback>[0],\n    ) => {\n      const eventListenersSet = listeners[eventType];\n      if (!eventListenersSet.size) {\n        return;\n      }\n      for (const listener of eventListenersSet) {\n        listener(eventRoute);\n      }\n    };\n    const events = (() => {\n      const on = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].add(handler);\n      };\n      const off = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].delete(handler);\n      };\n      return { on, off };\n    })();\n\n    routeChangeListenersRef.current = [events, executeListeners];\n  }\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;\n  const [err, setErr] = useState<unknown>(null);\n  // FIXME this \"refetching\" hack doesn't seem ideal.\n  const refetching = useRef<[onFinish?: () => void] | null>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      executeListeners('start', route);\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      refetching.current = [];\n      setErr(null);\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          refetching.current = null;\n          setErr(e);\n          throw e;\n        }\n      }\n      startTransitionFn(() => {\n        if (options.shouldScroll) {\n          handleScroll();\n        }\n        setRoute(route);\n        refetching.current![0]?.();\n        refetching.current = null;\n        executeListeners('complete', route);\n      });\n    },\n    [executeListeners, refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n  }, []);\n\n  useEffect(() => {\n    const callback = () => {\n      const route = parseRoute(new URL(window.location.href));\n      changeRoute(route, { shouldScroll: true }).catch((err) => {\n        console.log('Error while navigating back:', err);\n      });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const fn = () => {\n        const url = new URL(window.location.href);\n        url.pathname = path;\n        url.search = query;\n        url.hash = '';\n        changeRoute(parseRoute(url), {\n          skipRefetch: true,\n          shouldScroll: false,\n        })\n          .catch((err) => {\n            console.log('Error while handling location listeners:', err);\n          })\n          .finally(() => {\n            if (path !== '/404') {\n              window.history.pushState(\n                {\n                  ...window.history.state,\n                  waku_new_path: url.pathname !== window.location.pathname,\n                },\n                '',\n                url,\n              );\n            }\n          });\n      };\n      if (refetching.current) {\n        refetching.current.push(fn);\n      } else {\n        startTransition(fn);\n      }\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement =\n    err !== null ? (\n      <ThrowError error={err} />\n    ) : (\n      <Slot id={getRouteSlotId(route.path)} />\n    );\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler has404={has404}>{routeElement}</CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        routeChangeEvents,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      {rootElement}\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n}: {\n  initialRoute?: RouteProps;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter initialRoute={initialRoute} httpStatus={httpStatus} />\n    </Root>\n  );\n}\n\nconst MOCK_ROUTE_CHANGE_LISTENER: Record<\n  'on' | 'off',\n  (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n> = {\n  on: () => notAvailableInServer('routeChange:on'),\n  off: () => notAvailableInServer('routeChange:off'),\n};\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n"],"names":["Component","createContext","startTransition","use","useCallback","useContext","useEffect","useRef","useState","useTransition","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","isAltClick","event","button","metaKey","altKey","ctrlKey","shiftKey","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter","router","Error","route","changeRoute","prefetchRoute","push","to","options","currentPath","newPath","shouldScroll","scroll","history","pushState","state","waku_new_path","replace","replaceState","reload","back","forward","prefetch","unstable_events","routeChangeEvents","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","refProp","props","isPending","startTransitionFn","fn","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","internalOnClick","onClick","defaultPrevented","preventDefault","onMouseEnter","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","getDerivedStateFromError","error","render","String","NotFound","has404","reset","then","setTimeout","catch","err","console","log","Redirect","handledErrorSet","has","add","hostname","finally","CustomErrorHandler","WeakSet","bind","setState","info","status","ThrowError","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","InnerRouter","initialRoute","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","Object","keys","enhanceFetchRscInternal","locationListenersRef","locationListeners","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","Promise","resolve","listener","setRoute","routeChangeListenersRef","listeners","start","complete","executeListeners","eventType","eventRoute","eventListenersSet","size","events","on","handler","off","prev","setErr","refetching","skipRefetch","__WAKU_ROUTER_PREFETCH__","callback","addEventListener","removeEventListener","search","routeElement","rootElement","meta","value","Router","initialRscPath","initialRscParams","MOCK_ROUTE_CHANGE_LISTENER","INTERNAL_ServerRouter","httpstatus"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  use,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    signal?: AbortSignal;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\nconst PendingContext = createContext<boolean>(false);\n\n// Not sure whether this is necessary\n// We have navigation.transition\n// but it's not reactive\nexport function usePending() {\n  return use(PendingContext);\n}\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, prefetchRoute } = router;\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const push = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to);\n  }, []);\n  /**\n   * @deprecated use window.navigation.navigate() instead\n   */\n  const replace = useCallback((to: InferredPaths) => {\n    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n    window.navigation.navigate(to, { history: 'replace' });\n  }, []);\n  /**\n   * @deprecated use window.navigation.reload() instead\n   */\n  const reload = useCallback(async () => {\n    window.navigation.reload();\n  }, []);\n  /**\n   * @deprecated use window.navigation.back() instead\n   */\n  const back = useCallback(() => {\n    window.navigation.back();\n  }, []);\n  /**\n   * @deprecated use window.navigation.forward() instead\n   */\n  const forward = useCallback(() => {\n    window.navigation.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = use(RouterContext);\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a {...props} href={to} onMouseEnter={onMouseEnter} ref={setRef}>\n      {children}\n    </a>\n  );\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode; error?: unknown },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state || 'error' in this.props) {\n      const error = this.state.error ?? this.props.error;\n      if (error instanceof Error) {\n        return renderError(error.message);\n      }\n      return renderError(String(error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: false })\n        .then(() => {\n          reset();\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    window.navigation\n      .navigate(url, { history: 'push' })\n      .committed?.then(() => {\n        // FIXME\n        // ssr-redirect > access sync page with client navigation\n        return new Promise((resolve) => setTimeout(resolve, 200));\n      })\n      ?.then(() => {\n        console.trace('Redirected to', to);\n        reset();\n      });\n  }, [error, handledErrorSet, reset, to]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  #handledErrorSet = new WeakSet();\n  constructor(props: {\n    has404: boolean;\n    error: unknown;\n    children?: ReactNode;\n  }) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset = () => {\n    this.setState({ error: null });\n  };\n  render() {\n    if (this.state.error !== null) {\n      const info = getErrorInfo(this.state.error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={this.state.error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.#handledErrorSet}\n          />\n        );\n      }\n      return <ErrorBoundary error={this.state.error}>{null}</ErrorBoundary>;\n    }\n    return this.props.children;\n  }\n}\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = use(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(encodeURI(path));\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  // It doesn't have to be a ref\n  // But passing it to multiple function calls is too complicated\n  const signalRef = useRef<AbortSignal | null>(null);\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (\n        input: RequestInfo | URL,\n        init: RequestInit = { signal: signalRef.current },\n      ) => {\n        const skipStr = JSON.stringify(\n          Array.from(cachedIdSetRef.current).map((i) => encodeURI(i)),\n        );\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== encodeURI(path) ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  // redirected\n                  window.navigation.navigate(path, { history: 'push' });\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const customErrorHandlerRef = useRef<CustomErrorHandler>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      customErrorHandlerRef.current?.reset();\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          if (e instanceof Error && e.name === 'AbortError') {\n            // Noop\n          } else {\n            // Workaround: after setErr, CustomErrorHandler is not rerendered!\n            // Why is that?\n            // Luckily this is not on happy path.\n            // Update: this causes more bugs.\n            // flushSync(() => {\n            // });\n            throw e;\n          }\n        }\n      }\n      startTransitionFn(() => {\n        if (!options.signal?.aborted) {\n          if (options.shouldScroll) {\n            handleScroll();\n          }\n          setRoute(route);\n        }\n      });\n    },\n    [refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n  }, []);\n\n  const [isPending, startTransition] = useTransition();\n\n  // https://github.com/facebook/react/blob/main/fixtures/view-transition/src/components/App.js\n  useEffect(() => {\n    const callback = ((event: NavigateEvent) => {\n      if (\n        !event.canIntercept ||\n        // If this is a download,\n        // let the browser perform the download.\n        event.downloadRequest ||\n        // If this is a form submission,\n        // let that go to the server.\n        event.formData\n      ) {\n        return;\n      } else if (\n        // If this is just a hashChange,\n        // just let the browser handle scrolling to the content.\n        event.hashChange\n      ) {\n        setRoute((prev) => ({\n          ...prev,\n          hash: new URL(event.destination.url).hash,\n        }));\n        return;\n      }\n      const url = new URL(event.destination.url);\n      const route = parseRoute(url);\n      // console.log(event);\n      const navigationType = event.navigationType;\n      const previousIndex = window.navigation.currentEntry!.index;\n      event.intercept({\n        async precommitHandler() {\n          if (signalRef.current) {\n            // It happens when click very fast.\n            console.warn('Potential race condition due to rapid navigation.');\n          }\n          signalRef.current = event.signal;\n          startTransition(async () => {\n            // addTransitionType('navigation-' + navigationType);\n            if (navigationType === 'traverse') {\n              // For traverse types it's useful to distinguish going back or forward.\n              const nextIndex = event.destination.index;\n              if (nextIndex > previousIndex) {\n                // addTransitionType('navigation-forward');\n              } else if (nextIndex < previousIndex) {\n                // addTransitionType('navigation-back');\n              }\n              const err = customErrorHandlerRef.current?.state.error;\n              if (err) {\n                const info = getErrorInfo(err);\n                if (info?.status === 404) {\n                  // if 404 sans 404.tsx, manually go back\n                  // should make CustomErrorHandler state\n                  // Haha, upstream is broken too\n\n                  customErrorHandlerRef.current?.reset();\n                }\n              }\n              await changeRoute(route, {\n                shouldScroll: false,\n                unstable_startTransition: startTransition,\n                signal: event.signal,\n              }).catch((err) => {\n                console.log('Error while navigating back:', err);\n              });\n            } else {\n              prefetchRoute(route);\n              try {\n                await changeRoute(route, {\n                  shouldScroll: false,\n                  unstable_startTransition: startTransition,\n                  signal: event.signal,\n                });\n              } catch (err) {\n                // Handle 404, etc here\n                customErrorHandlerRef.current?.setState({ error: err });\n                if (has404 && err) {\n                  const info = getErrorInfo(err);\n                  if (info?.status === 404) {\n                    await changeRoute(\n                      { path: '/404', query: '', hash: '' },\n                      {\n                        signal: event.signal,\n                        shouldScroll: false,\n                      },\n                    );\n                  }\n                }\n              }\n            }\n            if (signalRef.current === event.signal) {\n              signalRef.current = null;\n            }\n          });\n          await flushAsync();\n          return;\n        },\n        scroll: 'after-transition',\n      });\n    }) as EventListener;\n    window.navigation.addEventListener('navigate', callback);\n    return () => {\n      window.navigation.removeEventListener('navigate', callback);\n    };\n  }, [changeRoute, prefetchRoute, has404]);\n\n  // run after new route DOM mounted\n  useEffect(() => {\n    resolver.current?.(undefined);\n    resolver.current = null;\n  }, [route]);\n\n  const resolver = useRef<((value: undefined) => void) | null>(null);\n\n  async function flushAsync() {\n    const deferred = Promise.withResolvers();\n    resolver.current = deferred.resolve;\n    await deferred.promise;\n    return;\n  }\n\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler ref={customErrorHandlerRef} has404={has404}>\n        {routeElement}\n      </CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      <PendingContext value={isPending}>{rootElement}</PendingContext>\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n}: {\n  initialRoute?: RouteProps;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter initialRoute={initialRoute} httpStatus={httpStatus} />\n    </Root>\n  );\n}\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n"],"names":["Component","createContext","use","useCallback","useEffect","useRef","useState","useTransition","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","savedRscParams","createRscParams","rscParams","URLSearchParams","PendingContext","usePending","RouterContext","useRouter","router","Error","route","prefetchRoute","push","to","navigation","navigate","replace","history","reload","back","forward","prefetch","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_prefetchOnEnter","unstable_prefetchOnView","refProp","props","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","onMouseEnter","event","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","state","getDerivedStateFromError","error","render","String","NotFound","has404","reset","changeRoute","shouldScroll","then","catch","err","console","log","Redirect","handledErrorSet","has","add","committed","Promise","resolve","setTimeout","trace","CustomErrorHandler","WeakSet","setState","info","status","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","finally","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","waku_new_path","InnerRouter","initialRoute","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","encodeURI","Object","keys","enhanceFetchRscInternal","signalRef","enhanceFetch","fetchFn","input","init","signal","skipStr","JSON","stringify","Array","from","map","i","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","setRoute","prev","customErrorHandlerRef","options","startTransitionFn","unstable_startTransition","fn","skipRefetch","aborted","__WAKU_ROUTER_PREFETCH__","isPending","startTransition","callback","canIntercept","downloadRequest","formData","hashChange","destination","navigationType","previousIndex","currentEntry","intercept","precommitHandler","warn","nextIndex","flushAsync","scroll","addEventListener","removeEventListener","resolver","deferred","withResolvers","promise","routeElement","rootElement","meta","value","Router","initialRscPath","initialRscParams","INTERNAL_ServerRouter","httpstatus"],"mappings":"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"}
